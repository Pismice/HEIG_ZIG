<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-20 lun 19:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zig documentation</title>
<meta name="author" content="tetratrux" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Zig documentation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9339fc0">1. Introduction</a>
<ul>
<li><a href="#orgeb04ad2">1.1. What this documentation IS</a></li>
<li><a href="#org95bdd2d">1.2. What this documentation IS NOT</a></li>
<li><a href="#orgd8b5f9a">1.3. How to use this documentation</a></li>
<li><a href="#org39e8087">1.4. Build Emacs configuration</a>
<ul>
<li><a href="#org3cda9dd">1.4.1. Install Zig emacs org babel plugin</a></li>
<li><a href="#org6b55305">1.4.2. Create an emacs configuration file</a></li>
<li><a href="#org1fd1e73">1.4.3. Execute the configuration file from the configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org840e583">2. Basics of the language</a>
<ul>
<li><a href="#org2261ac0">2.1. Reading external files</a>
<ul>
<li><a href="#org1beddde">2.1.1. @embedFile</a></li>
<li><a href="#orgc671a4e">2.1.2. Use an allocator to dynamically store the content of the file</a></li>
<li><a href="#org9aa93f6">2.1.3. Read the file and put it in a buffer</a></li>
</ul>
</li>
<li><a href="#org433e176">2.2. Errors</a>
<ul>
<li><a href="#org3364e97">2.2.1. Handling errors in the application flow</a></li>
<li><a href="#org094f5d8">2.2.2. Errdefer</a></li>
<li><a href="#orgda5e33f">2.2.3. Coercing</a></li>
</ul>
</li>
<li><a href="#org5227581">2.3. Code styles</a>
<ul>
<li><a href="#org6035e73">2.3.1. Style guide</a></li>
<li><a href="#orgbfdd526">2.3.2. undefined and null values</a></li>
<li><a href="#org6871757">2.3.3. Zen</a></li>
</ul>
</li>
<li><a href="#orge721d8d">2.4. Zig version manager</a>
<ul>
<li><a href="#orgd29176a">2.4.1. Basic usage</a></li>
</ul>
</li>
<li><a href="#orgcbad7dc">2.5. defer</a>
<ul>
<li><a href="#org59b9d34">2.5.1. Exemple</a></li>
<li><a href="#orgde5e54d">2.5.2. Freeing memory</a></li>
</ul>
</li>
<li><a href="#org2389fd9">2.6. Testing code</a></li>
<li><a href="#orgcffde92">2.7. TCP stream</a>
<ul>
<li><a href="#org7403460">2.7.1. <span class="todo TODO">TODO</span> How Zig manages stream</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgfd992fe">3. Comptime</a>
<ul>
<li><a href="#orgef1190a">3.1. When to use and when NOT to use it</a>
<ul>
<li><a href="#orgaaa74d9">3.1.1. When to use it</a></li>
<li><a href="#org2d1dd56">3.1.2. When NOT to use it (source: ziglings)</a></li>
</ul>
</li>
<li><a href="#org0e6eb60">3.2. Compile-time evaluation</a>
<ul>
<li><a href="#org694dc09">3.2.1. Compile-time variable</a></li>
<li><a href="#orgde0957e">3.2.2. Compile-time expression</a></li>
<li><a href="#orgcb50963">3.2.3. Compile-time parameter</a></li>
</ul>
</li>
<li><a href="#orgb9e0c1f">3.3. Metaprogramming</a>
<ul>
<li><a href="#org2ced803">3.3.1. <code>@TypeOf</code></a></li>
<li><a href="#orgf0d87d7">3.3.2. <code>@typeInfo</code></a></li>
</ul>
</li>
<li><a href="#orgdea1c44">3.4. <span class="todo TODO">TODO</span> Optimization</a>
<ul>
<li><a href="#org59cd52e">3.4.1. How log works in Zig</a></li>
</ul>
</li>
<li><a href="#org7898e7b">3.5. Generic data structures</a></li>
<li><a href="#org1aef0a7">3.6. Example with a custom CSV writer based on type</a></li>
<li><a href="#org4871464">3.7. Bonus</a></li>
</ul>
</li>
<li><a href="#org77eb809">4. Zig and C</a>
<ul>
<li><a href="#org9cc8339">4.1. Introduction</a></li>
<li><a href="#org39c1a19">4.2. Main differences between Zig and C in the syntax</a>
<ul>
<li><a href="#org1df27a3">4.2.1. Types</a></li>
<li><a href="#org79b9e25">4.2.2. Loops</a></li>
<li><a href="#orge181b66">4.2.3. Pointers</a></li>
<li><a href="#orgae92f18">4.2.4. Type conversions</a></li>
</ul>
</li>
<li><a href="#org0212933">4.3. How to call a C function from Zig</a></li>
<li><a href="#orgc476cce">4.4. How to call a Zig function from C / Continuing a C project with Zig</a>
<ul>
<li><a href="#org1b8cfad">4.4.1. export and extern keywords</a></li>
</ul>
</li>
<li><a href="#orga6a57bf">4.5. How is it done under the hood</a></li>
<li><a href="#orgfe9420c">4.6. Util to translate C code to Zig</a>
<ul>
<li><a href="#org1760d64">4.6.1. Comparison with other langauges that use C code</a></li>
</ul>
</li>
<li><a href="#org876a864">4.7. Notes</a></li>
</ul>
</li>
<li><a href="#orgd09189b">5. Compilation - build system</a>
<ul>
<li><a href="#orgaf08c17">5.1. Zig package manager</a>
<ul>
<li><a href="#org3cd0adf">5.1.1. Add a package in your project</a></li>
<li><a href="#org3931586">5.1.2. Sources</a></li>
</ul>
</li>
<li><a href="#org4befd80">5.2. <span class="todo TODO">TODO</span> Comptime</a></li>
<li><a href="#orgeb47c8e">5.3. <span class="todo TODO">TODO</span> How to use the build system</a></li>
<li><a href="#orgf079041">5.4. Build modes</a>
<ul>
<li><a href="#org712aa2d">5.4.1. <span class="todo TODO">TODO</span> Build steps</a></li>
<li><a href="#org19356b5">5.4.2. <span class="todo TODO">TODO</span> Generate automatically documentation</a></li>
<li><a href="#org65b97d4">5.4.3. Strip output binary in Zig in Linux</a></li>
<li><a href="#org8a61df4">5.4.4. Separate debug symbols from ELF executable</a></li>
</ul>
</li>
<li><a href="#org6ceb9df">5.5. Cross-compilation</a>
<ul>
<li><a href="#org08e5dab">5.5.1. <span class="todo TODO">TODO</span> Cross-compile with an embedded linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd4e6d23">6. Allocator</a>
<ul>
<li><a href="#org55b4f94">6.1. General pattern</a></li>
<li><a href="#orgc30d3bc">6.2. Page allocator (<code>page_allocator</code>)</a></li>
<li><a href="#org20dc3da">6.3. Fixed buffer allocator</a></li>
<li><a href="#orgadc6104">6.4. Arena allocator</a>
<ul>
<li><a href="#org8f47dbd">6.4.1. Internal working of arena allocator</a></li>
</ul>
</li>
<li><a href="#orgd337121">6.5. General purpose allocator</a></li>
<li><a href="#orgd4ce63c">6.6. Testing allocator</a></li>
<li><a href="#orgdd261b3">6.7. <span class="todo TODO">TODO</span> Failing allocator</a></li>
<li><a href="#orgec6dd94">6.8. <span class="todo TODO">TODO</span> C allocator</a></li>
<li><a href="#orgb817ccb">6.9. <span class="todo TODO">TODO</span> implementing your own allocator</a></li>
<li><a href="#org2ffb022">6.10. <span class="todo TODO">TODO</span> How to use Zig to detect memory leaks</a>
<ul>
<li><a href="#org61b484a">6.10.1. <span class="todo TODO">TODO</span> Comparison between gcc-utils sanitizer, Valgrind, and Zig memory leak detection</a></li>
</ul>
</li>
<li><a href="#org2a23b62">6.11. <span class="todo TODO">TODO</span> ?</a></li>
<li><a href="#orgf660e16">6.12. Conclusion</a></li>
</ul>
</li>
<li><a href="#orga8c47f5">7. Comptime</a>
<ul>
<li><a href="#org231c379">7.1. When to use and when NOT to use it</a>
<ul>
<li><a href="#orged446ad">7.1.1. When to use it</a></li>
<li><a href="#orgadf217d">7.1.2. When NOT to use it (source: ziglings)</a></li>
</ul>
</li>
<li><a href="#org9ea0827">7.2. Compile-time evaluation</a>
<ul>
<li><a href="#orgedcb2e7">7.2.1. Compile-time variable</a></li>
<li><a href="#org435dc26">7.2.2. Compile-time expression</a></li>
<li><a href="#org423defa">7.2.3. Compile-time parameter</a></li>
</ul>
</li>
<li><a href="#org3fd7f54">7.3. Metaprogramming</a>
<ul>
<li><a href="#org36de831">7.3.1. <code>@TypeOf</code></a></li>
<li><a href="#org7aae3aa">7.3.2. <code>@typeInfo</code></a></li>
</ul>
</li>
<li><a href="#org9609f79">7.4. <span class="todo TODO">TODO</span> Optimization</a>
<ul>
<li><a href="#orge094852">7.4.1. How log works in Zig</a></li>
</ul>
</li>
<li><a href="#org525e3fa">7.5. Generic data structures</a></li>
<li><a href="#orgd8fb10d">7.6. Example with a custom CSV writer based on type</a></li>
<li><a href="#orgd648a82">7.7. Bonus</a></li>
</ul>
</li>
<li><a href="#orga3127bc">8. Zig and C</a>
<ul>
<li><a href="#org19d981b">8.1. Introduction</a></li>
<li><a href="#org7064094">8.2. Main differences between Zig and C in the syntax</a>
<ul>
<li><a href="#org3822581">8.2.1. Types</a></li>
<li><a href="#org37334b5">8.2.2. Loops</a></li>
<li><a href="#org2f36c4a">8.2.3. Pointers</a></li>
<li><a href="#orgf48020f">8.2.4. Type conversions</a></li>
</ul>
</li>
<li><a href="#orgef376cf">8.3. How to call a C function from Zig</a></li>
<li><a href="#orgf496195">8.4. How to call a Zig function from C / Continuing a C project with Zig</a>
<ul>
<li><a href="#org38dfb65">8.4.1. export and extern keywords</a></li>
</ul>
</li>
<li><a href="#org0767e2b">8.5. How is it done under the hood</a></li>
<li><a href="#org202544d">8.6. Util to translate C code to Zig</a>
<ul>
<li><a href="#orgc349102">8.6.1. Comparison with other langauges that use C code</a></li>
</ul>
</li>
<li><a href="#org5d77ceb">8.7. Notes</a></li>
</ul>
</li>
<li><a href="#org3deac6b">9. Concurrency</a>
<ul>
<li><a href="#orgd186a41">9.1. Introduction</a></li>
<li><a href="#org2449088">9.2. Definitions</a>
<ul>
<li><a href="#orgb1d2bbd">9.2.1. Coroutine</a></li>
<li><a href="#orgfa2139c">9.2.2. Green threads (userland threads)</a></li>
<li><a href="#org15c2c20">9.2.3. Fibers</a></li>
<li><a href="#orgfa2060d">9.2.4. Preemptive multitasking</a></li>
<li><a href="#org877bdce">9.2.5. Cooperative multitasking</a></li>
<li><a href="#org405fd1d">9.2.6. Thread (ChatGPT)</a></li>
<li><a href="#org1d434ca">9.2.7. Event-driven programming (ChatGPT)</a></li>
</ul>
</li>
<li><a href="#org5b23eea">9.3. Zig solutions</a>
<ul>
<li><a href="#org5e85aaa">9.3.1. OS threads (std)</a></li>
<li><a href="#org00ae371">9.3.2. async/await</a></li>
<li><a href="#orgdbc74ec">9.3.3. libxev</a></li>
<li><a href="#org87ff0fb">9.3.4. Fibers</a></li>
<li><a href="#org1874f14">9.3.5. zigcoro</a></li>
<li><a href="#orgf95f0b5">9.3.6. Using C libraries</a></li>
</ul>
</li>
<li><a href="#org79ef113">9.4. Conclusion</a></li>
<li><a href="#org9edddf2">9.5. Sources:</a></li>
</ul>
</li>
<li><a href="#org8288288">10. Web frameworks</a>
<ul>
<li><a href="#orgafc8260">10.1. Introduction</a></li>
<li><a href="#org2075a5d">10.2. Zig solutions</a></li>
<li><a href="#org7f8d6c8">10.3. Zap</a>
<ul>
<li><a href="#org2c361c4">10.3.1. Description</a></li>
<li><a href="#org45a5c85">10.3.2. Exemples</a></li>
<li><a href="#org7fa72d2">10.3.3. Alternatives and performance comparaison</a></li>
<li><a href="#org5b4df12">10.3.4. Conclusion</a></li>
<li><a href="#org9b01a45">10.3.5. Mes notes</a></li>
</ul>
</li>
<li><a href="#org9ab3d03">10.4. HTTP from the std</a>
<ul>
<li><a href="#orgd8207d3">10.4.1. Description</a></li>
<li><a href="#org7cc084b">10.4.2. Exemples</a></li>
<li><a href="#orgcd92717">10.4.3. Tokamak</a></li>
<li><a href="#orgcd19c41">10.4.4. Jetzig</a></li>
</ul>
</li>
<li><a href="#orge6ad9cc">10.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#orga0c13ce">11. Case studies</a>
<ul>
<li><a href="#org2ceca91">11.1. Interacting with processuses</a></li>
</ul>
</li>
<li><a href="#org047dfa0">12. Bibliography</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9339fc0" class="outline-2">
<h2 id="org9339fc0"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Nowadays, <a href="https://www.reddit.com/r/C_Programming/comments/nqkn93/what_do_people_think_of_the_c_replacements_are/">multiple languages</a> have emerged to compete with the well-established C language.
In fact, C is widely used in many places, learned by a lot of engineers, and used for many purposes.
C is a powerful tool, <i>but with great power comes great responsibility</i>, in fact, memory leaks can easily occur by mistake.
</p>

<p>
That's why new languages come to find a better way to handle errors and memory.
The Rust language relies strongly on its borrow checker to ensure safe memory but it comes at a cost: increased code complexity, that can slow down it's adoption.
</p>

<p>
In another case, the Zig language has a purpose to replace the C language.
Zig wants to simplify the programming development experience with no hidden control flow and no macro to avoid complex mistakes.
In contrary to rust, in Zig the memory is managed explicitly, you have to manually allocate and deallocate memory, just as in C.
Zig offers different allocators that have different purposes, but some can detect memory leaks (<a href="./allocators.html#General purpose allocator">General purpose allocator</a>).
</p>

<p>
In the sections below, certain aspects of this programming language will be explored in greater depth.
</p>

<p>
Note that this documentation is generated from emacs with org-mode and that you can find the Github repository <a href="https://pismice.github.io/HEIG_ZIG/">here</a>.
</p>
</div>

<div id="outline-container-orgeb04ad2" class="outline-3">
<h3 id="orgeb04ad2"><span class="section-number-3">1.1.</span> What this documentation IS</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This documentation is being worked on by 2 students from the HEIG-VD, in the context of a course for one and a Bachelor Thesis for the other.
The goal of this documentation is to explore the Zig language in-depth, by first learning a few basics of the language we judge interesting/useful, and then by exploring more advanced topics.
</p>

<p>
This work is mainly aimed at engineers who already have experiences in C but might consider using Zig as a replacement/alternative. If you are a complete beginner, you might still learn a lot by reading this, but we highly encourage you to look at other ressources aimed at beginners aswell.
</p>

<p>
The big + this project offers compare to other guides/documentations is that here we are going to learn the language with <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> (learning via interactive code exemples) because <b>one snippet of code is worth 1000 words</b>.
</p>

<p>
The advanced topics covered are mostly structured like so:
</p>
<ol class="org-ol">
<li>Explain the concept and see what is done in other languages (mostly C)</li>
<li>Show how to do it in Zig</li>
<li>Conclusion about the current state of Zig on this topic</li>
</ol>

<p>
Note that we wrote this documentation with the help of AI assistants like ChatGPT and GH Copilot.
</p>
</div>
</div>

<div id="outline-container-org95bdd2d" class="outline-3">
<h3 id="org95bdd2d"><span class="section-number-3">1.2.</span> What this documentation IS NOT</h3>
<div class="outline-text-3" id="text-1-2">
<p>
This is <b>not</b> a guide to learn Zig as first-language, this documentation wants to go in-depth in certain parts of the language.
</p>

<p>
To understand what is described in this documentation, you should first read up on the basics of the Zig language, in particular, its guide, which contains a wealth of information.
</p>
<ul class="org-ul">
<li><a href="https://zig.guide">Zig guide</a></li>
<li><a href="https://ziglang.org/documentation/0.11.0">Zig documentation</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd8b5f9a" class="outline-3">
<h3 id="orgd8b5f9a"><span class="section-number-3">1.3.</span> How to use this documentation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
This documentation is built to guide to user through different examples.
Those examples have been created to use literate programming, in fact, the documentation is built on Emacs with the org mode.
You can follow the examples and execute them directly in Emacs.
</p>

<p>
For that, you need to:
</p>
<ol class="org-ol">
<li>Install the configuration created for that (see the section below)</li>
<li>When all is configured, in Emacs you can select the example that you want to execute and use the command <code>C-c C-c</code>.
The output will be created or updated below the source block. If you want more documentation, you can check the <a href="https://orgmode.org/worg/org-contrib/babel/intro.html">Org babel documentation</a></li>
</ol>

<p>
You can follow the examples with the Zig version 0.12.
But Zig is in constant evolution we <b>may</b> have to use other versions at some point in this guide, but if that is the case we will precise it.
</p>
</div>
</div>

<div id="outline-container-org39e8087" class="outline-3">
<h3 id="org39e8087"><span class="section-number-3">1.4.</span> Build Emacs configuration</h3>
<div class="outline-text-3" id="text-1-4">
<p>
TODO RAJOUTER les etapes EN PARTANT DE 0, IL FAUT IMAGINER QUE L UTILISATEUR N AIT PAS EMACS, RIEN DU TOUT
</p>
</div>

<div id="outline-container-org3cda9dd" class="outline-4">
<h4 id="org3cda9dd"><span class="section-number-4">1.4.1.</span> Install Zig emacs org babel plugin</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Use <code>C-c C-c</code> (<code>ctrl-c ctrl-c</code>) to evaluate the code below.
It will add a shell interpreter inside org-babel configuration, it will be used when shell commands are evaluated.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'org-babel-load-languages '(shell . t))
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
</pre>
</div>

<p>
The shell command will clone an org babel <a href="https://github.com/samuel-schlaeppy/ob-zig.el.git">zig plugin</a> necessary to execute some Zig example directly in Emacs with Org babel.
</p>

<p>
The <code>HEADER</code> parameter below configures the directory path by default.
You can change the directory where the plugin will be installed (change the argument after the <code>:dir</code>).
</p>
<div class="org-src-container">
<pre class="src src-shell">git clone https://github.com/samuel-schlaeppy/ob-zig.el.git
</pre>
</div>
</div>
</div>

<div id="outline-container-org6b55305" class="outline-4">
<h4 id="org6b55305"><span class="section-number-4">1.4.2.</span> Create an emacs configuration file</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
TODO le prof n a pas compris cette phrase entre guillemets et moi non plus apres relecture :-)
</p>

<p>
"To use the plugin installed before, you need to modify the first path to give the path where the plugin is installed (see section upper),"
and a path to the Zig executable need also to be referenced.
</p>

<p>
After that, the following command <code>C-c C-v t</code> (<code>ctrl-c ctrl-v t</code>) will produce a <code>zigIterativeProgramming.el</code> file.
This file can be loaded from your emacs configuration (see section below).
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">setq</span> base_dir <span style="color: #e9b96e;">"~/PATH-WHERE-THE-ZIG-PLUGIN-IS-INSTALLED/ob-zig.el"</span>)
(<span style="color: #b4fa70;">setq</span> org-babel-zig-compiler <span style="color: #e9b96e;">"PATH-TO-THE-ZIG-EXECUTABLE"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">require</span> '<span style="color: #e9b2e3;">package</span>)
(add-to-list 'package-archives
             '(<span style="color: #e9b96e;">"melpa"</span> . <span style="color: #e9b96e;">"https://melpa.org/packages/"</span>))
(package-initialize)
(package-refresh-contents)

(<span style="color: #b4fa70;">defun</span> <span style="color: #fce94f;">install-custom-pkg</span> (pck)
  (<span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">featurep</span> <span style="color: #e9b2e3;">pck</span>)
      (message <span style="color: #e9b96e;">"The package %s is already installed !"</span> pck)
    (package-install pck)
    ))

(install-custom-pkg 'zig-mode)
(install-custom-pkg 'lsp-mode)
(<span style="color: #b4fa70;">require</span> '<span style="color: #e9b2e3;">lsp-mode</span>)
(add-hook 'zig-mode-hook #'lsp)

(<span style="color: #b4fa70;">let</span> ((local-file-path (expand-file-name <span style="color: #e9b96e;">"ob-zig.el"</span> base_dir)))
  (<span style="color: #b4fa70;">setq</span> org-babel-zig-compiler local-file-path)
  (load-file local-file-path)
  )

(custom-set-variables
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">custom-set-variables was added by Custom.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">If you edit it by hand, you could mess it up, so be careful.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">Your init file should contain only one such instance.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">If there is more than one, they won't work right.</span>
 '(org-babel-load-languages '((C . t) (emacs-lisp . t) (shell . t))))
</pre>
</div>
</div>
</div>

<div id="outline-container-org1fd1e73" class="outline-4">
<h4 id="org1fd1e73"><span class="section-number-4">1.4.3.</span> Execute the configuration file from the configuration</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
You can put the code below in your <code>init.el</code> it will load the file produced before and load the necessary package to learn Zig with literate programming.
But you need the specify the directory path of the <code>zigIterativeProgramming.el</code> file (first line below).
(the <code>init.el</code> can be found in <code>~/.emacs.d/</code> or can be created in <code>~/.config/emacs/</code>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">let</span> ((file_dir <span style="color: #e9b96e;">"~/PATH-TO-THE-zigIterativeProgramming-file"</span>))
(load-file (expand-file-name <span style="color: #e9b96e;">"zigIterativeProgramming.el"</span> file_dir)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org840e583" class="outline-2">
<h2 id="org840e583"><span class="section-number-2">2.</span> Basics of the language</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org2261ac0" class="outline-3">
<h3 id="org2261ac0"><span class="section-number-3">2.1.</span> Reading external files</h3>
<div class="outline-text-3" id="text-2-1">
<p>
There are multiple ways to do it in ZIG:
</p>
</div>
<div id="outline-container-org1beddde" class="outline-4">
<h4 id="org1beddde"><span class="section-number-4">2.1.1.</span> @embedFile</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
This method is simply going to embed the file in the binary at compile time.
</p>

<p>
Beware that by using this method the path to the file is going to be relative to the file you are calling it from and that the file must be in the same package.
</p>

<p>
By using the other methods below you can use a file from anywhere but relative to your root folder and not main.zig.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">input</span> = <span style="color: #e090d7;">@embedFile</span>(<span style="color: #e9b96e;">"input.txt"</span>);
std.debug.print(<span style="color: #e9b96e;">"{s}"</span>, .{input});
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc671a4e" class="outline-4">
<h4 id="orgc671a4e"><span class="section-number-4">2.1.2.</span> Use an allocator to dynamically store the content of the file</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
By using the method: readToEndAlloc 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #73d216;">// </span><span style="color: #73d216;">Alocator</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gp</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> gp.deinit();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gp.allocator();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Path</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">path_buffer</span>: [std.fs.MAX_PATH_BYTES]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">path</span> = <span style="color: #b4fa70;">try</span> std.fs.realpath(<span style="color: #e9b96e;">"./input.txt"</span>, &amp;path_buffer);

<span style="color: #73d216;">// </span><span style="color: #73d216;">Open file</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file</span> = <span style="color: #b4fa70;">try</span> std.fs.openFileAbsolute(path, .{});
<span style="color: #b4fa70;">defer</span> file.close();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Read</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file_content</span> = <span style="color: #b4fa70;">try</span> file.readToEndAlloc(allocator, std.math.maxInt(<span style="color: #8cc4ff;">usize</span>));
<span style="color: #b4fa70;">defer</span> allocator.free(file_content);
</pre>
</div>
</div>
</div>

<div id="outline-container-org9aa93f6" class="outline-4">
<h4 id="org9aa93f6"><span class="section-number-4">2.1.3.</span> Read the file and put it in a buffer</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
By using the method readAll 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #73d216;">// </span><span style="color: #73d216;">Path</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">path_buffer</span>: [std.fs.MAX_PATH_BYTES]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">path</span> = <span style="color: #b4fa70;">try</span> std.fs.realpath(<span style="color: #e9b96e;">"./input.txt"</span>, &amp;path_buffer);

<span style="color: #73d216;">// </span><span style="color: #73d216;">Open file</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file</span> = <span style="color: #b4fa70;">try</span> std.fs.openFileAbsolute(path, .{});
<span style="color: #b4fa70;">defer</span> file.close();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Read</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">content_buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">size</span> = <span style="color: #b4fa70;">try</span> file.readAll(&amp;content_buffer);

std.debug.print(<span style="color: #e9b96e;">"{s}"</span>, .{content_buffer[0..size]});
</pre>
</div>

<p>
TODO reading files with org babel doesnt work yet idk why
</p>

<p>
Sources: 
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/master/std/#std.fs.File.readToEndAlloc">https://ziglang.org/documentation/master/std/#std.fs.File.readToEndAlloc</a></li>
<li><a href="https://ziglang.org/documentation/master/std/#std.fs.File.readAll">https://ziglang.org/documentation/master/std/#std.fs.File.readAll</a></li>
<li><a href="https://ziglang.org/documentation/master/#embedFile">https://ziglang.org/documentation/master/#embedFile</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org433e176" class="outline-3">
<h3 id="org433e176"><span class="section-number-3">2.2.</span> Errors</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<a href="https://ziglang.org/documentation/0.11.1/#Errors">https://ziglang.org/documentation/0.11.1/#Errors</a>
</p>

<p>
In ZIG errors are juste values.
</p>

<p>
Those values are those of an special type of enum "error".
</p>

<p>
When you declare your enum using this keyword instead of "enum", the compiler is going to know that those values are going to be errors, therefore they can be catched, tried, &#x2026;
</p>
</div>


<div id="outline-container-org3364e97" class="outline-4">
<h4 id="org3364e97"><span class="section-number-4">2.2.1.</span> Handling errors in the application flow</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Functions can return either a value or an error, this is done by adding the "!" to the return type of a function
With the "!" the return type of the function below is the coerced "anyerror!u8"
</p>

<p>
Note 1: "anyerror" is just a u16 under the hood.
Note 2: It is important that the syntax is ErrorSet!Payload if you write it by hand and NOT Payload!ErrorSet
</p>

<p>
When a function can return an error we have to either "try" or "catch" it.
</p>

<div class="org-src-container">
<pre class="src src-zig" id="orgb6855d2"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">maybeErrorMaybeValue</span>(<span style="color: #fcaf3e;">isError</span>: <span style="color: #8cc4ff;">bool</span>) !<span style="color: #8cc4ff;">u8</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">... might return an u8 or an error</span>
    <span style="color: #b4fa70;">if</span> (isError) {
        <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.Bar;
    } <span style="color: #b4fa70;">else</span> {
        <span style="color: #b4fa70;">return</span> 2;
    }
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"return value or error"</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">"try" version</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">res</span> = <span style="color: #b4fa70;">try</span> maybeErrorMaybeValue(<span style="color: #e9b2e3;">false</span>); <span style="color: #73d216;">// </span><span style="color: #73d216;">if error, return the error</span>
    <span style="color: #b4fa70;">try</span> std.testing.expect(res == 2);

    <span style="color: #73d216;">// </span><span style="color: #73d216;">"catch" version</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">err</span> = maybeErrorMaybeValue(<span style="color: #e9b2e3;">true</span>) <span style="color: #b4fa70;">catch</span> 3;
    <span style="color: #b4fa70;">try</span> std.testing.expect(err == 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should panic"</span> {
    _ = maybeErrorMaybeValue(<span style="color: #e9b2e3;">true</span>) <span style="color: #b4fa70;">catch</span> <span style="color: #b4fa70;">unreachable</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org094f5d8" class="outline-4">
<h4 id="org094f5d8"><span class="section-number-4">2.2.2.</span> Errdefer</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
This exemple is taken from the <a href="https://ziglang.org/documentation/master/#errdefer">official documentation</a>
Errdefer is a particularity of ZIG, it allows the user to execute some code when the function returns an error, it is useful exemple for deallocating variables you would have normally returned from the function, but since the function failed you deallocate that memory to avoid a memory leak.
</p>
<div class="org-src-container">
<pre class="src src-zig" id="org7ace9b4"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">createFoo</span>(<span style="color: #fcaf3e;">param</span>: <span style="color: #8cc4ff;">i32</span>) !Foo {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">foo</span> = <span style="color: #b4fa70;">try</span> tryToAllocateFoo();
    <span style="color: #73d216;">// </span><span style="color: #73d216;">now we have allocated foo. we need to free it if the function fails.</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">but we want to return it if the function succeeds.</span>
    <span style="color: #b4fa70;">errdefer</span> deallocateFoo(foo);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">tmp_buf</span> = allocateTmpBuffer() <span style="color: #b4fa70;">orelse</span> <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.OutOfMemory;
    <span style="color: #73d216;">// </span><span style="color: #73d216;">tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">before this block leaves scope</span>
    <span style="color: #b4fa70;">defer</span> deallocateTmpBuffer(tmp_buf);

    <span style="color: #b4fa70;">if</span> (param &gt; 1337) <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.InvalidParam;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">here the errdefer will not run since we're returning success from the function.</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">but the defer will run!</span>
    <span style="color: #b4fa70;">return</span> foo;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgda5e33f" class="outline-4">
<h4 id="orgda5e33f"><span class="section-number-4">2.2.3.</span> Coercing</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
The rule is simple: you can coerce an error from a subset to a superset but you cannot coerce an error from a superset to a subset
</p>

<div class="org-src-container">
<pre class="src src-zig" id="org8316096"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">SuperErrors</span> = <span style="color: #b4fa70;">error</span>{
    Foo,
    Bar,
    Baz,
};
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">SubErrors</span> = <span style="color: #b4fa70;">error</span>{
    Foo,
    Bar,
};

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"coerce subset to superset"</span> {
    tac(SubErrors.Foo) <span style="color: #b4fa70;">catch</span> {}; <span style="color: #73d216;">// </span><span style="color: #73d216;">PASSED</span>
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"coerce superset to subset"</span> {
    tic(SuperErrors.Foo) <span style="color: #b4fa70;">catch</span> {}; <span style="color: #73d216;">// </span><span style="color: #73d216;">FAILED</span>
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">tic</span>(<span style="color: #fcaf3e;">err</span>: <span style="color: #8cc4ff;">SuperErrors</span>) SubErrors {
    <span style="color: #b4fa70;">return</span> err;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">tac</span>(<span style="color: #fcaf3e;">err</span>: <span style="color: #8cc4ff;">SubErrors</span>) SuperErrors {
    <span style="color: #b4fa70;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5227581" class="outline-3">
<h3 id="org5227581"><span class="section-number-3">2.3.</span> Code styles</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org6035e73" class="outline-4">
<h4 id="org6035e73"><span class="section-number-4">2.3.1.</span> Style guide</h4>
<div class="outline-text-4" id="text-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org099d47c"></a>fmt<br />
<div class="outline-text-5" id="text-2-3-1-1">
<p>
First it is important to know that Zig comes with a formatter that you can use using:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig fmt file.zig
</pre>
</div>
<p>
This util is going to enforce basic things for you like:
</p>
<ul class="org-ul">
<li>Indentation</li>
<li>Braces alignment</li>
<li>Line length</li>
<li>&#x2026;.</li>
</ul>
</div>
</li>
<li><a id="orgc2e0b21"></a>Naming conventions<br />
<div class="outline-text-5" id="text-2-3-1-2">
<ol class="org-ol">
<li>TitleCaseTypeName: for types and structs that are callable (for "classes" in other languages basically)</li>
<li>camelCaseFunctionName: for functions</li>
<li>snake\<sub>case</sub>\<sub>variable</sub><sub>name</sub>: for variables and everything else TODO formatter le snake<sub>case</sub>_&#x2026; car sur le web ca affiche pas comme il faut</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgbfdd526" class="outline-4">
<h4 id="orgbfdd526"><span class="section-number-4">2.3.2.</span> undefined and null values</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
TODO for some reason the 2 org block code are not working, maybe i should "testsuite"
TODO how can i make the second one print the error ?
</p>

<p>
In Zig you can leave variables uninitialized, but you have to do that explicitly contrary to C where you can leave variables uninitialized and never truly notice it. Note that leaving the value undefined is going to leave the memory of this variable to some complete nonsense value (except in Debug mode where it will be <a href="https://github.com/ziglang/zig/issues/15603%20">set to 0xaa</a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">my_var</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
std.debug.print(<span style="color: #e9b96e;">"my_var: {}\n"</span>, .{my_var});
</pre>
</div>

<p>
This is to be avoided as much as possible, if you have some in your code it might makes sense to use an Optional type instead so that compiler can scream at you :)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">my_var</span>: ?<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">null</span>;

<span style="color: #73d216;">// </span><span style="color: #73d216;">.? is syntaxic sugar for "orelse unreachable" which is going</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">unreachable is going to emit a panic (unable to unwrapp null) !</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">THIS CODE WILL PANIC IF UNCOMMENTED</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">_ = my_var.?;</span>

<span style="color: #73d216;">// </span><span style="color: #73d216;">if value is "null" then "42" will be assigned</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">u8</span> = my_var <span style="color: #b4fa70;">orelse</span> 42;

<span style="color: #73d216;">// </span><span style="color: #73d216;">print 42 because value was null before</span>
std.debug.print(<span style="color: #e9b96e;">"my_var = {}\n"</span>, .{value});
</pre>
</div>
</div>
</div>

<div id="outline-container-org6871757" class="outline-4">
<h4 id="org6871757"><span class="section-number-4">2.3.3.</span> Zen</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Zig encourages you to use the Zen philosophy, I find them quite interesting to have in mind when coding, here they are:
</p>
<ul class="org-ul">
<li>Communicate intent precisely.</li>
<li>Edge cases matter.</li>
<li>Favor reading code over writing code.</li>
<li>Only one obvious way to do things.</li>
<li>Runtime crashes are better than bugs.</li>
<li>Compile errors are better than runtime crashes.</li>
<li>Incremental improvements.</li>
<li>Avoid local maximums.</li>
<li>Reduce the amount one must remember.</li>
<li>Focus on code rather than style.</li>
<li>Resource allocation may fail; resource deallocation must succeed.</li>
<li>Memory is a resource.</li>
<li>Together we serve the users.</li>
</ul>

<p>
Sources:
<a href="https://ziglang.org/documentation/master/#Type-Coercion-undefined">https://ziglang.org/documentation/master/#Type-Coercion-undefined</a>
<a href="https://nathancraddock.com/blog/zig-naming-conventions/o">https://nathancraddock.com/blog/zig-naming-conventions/o</a>
<a href="https://ziglang.org/documentation/master/#undefined">https://ziglang.org/documentation/master/#undefined</a>
<a href="https://ziglang.org/documentation/master/#Style-Guide">https://ziglang.org/documentation/master/#Style-Guide</a>
<a href="https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig">https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orge721d8d" class="outline-3">
<h3 id="orge721d8d"><span class="section-number-3">2.4.</span> Zig version manager</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Using ZIG before 1.0 might require you to often switch between master and the last official release.
</p>

<p>
One solution would be to install both (or more) versions of ZIG and switch the PATH environment variable to the version you want to use.
</p>

<p>
But the best solution is to use the ZIG version manager, which is a tool that allows you to install and switch between different versions of ZIG.
</p>

<p>
We recommend using ZVM (Zig Version Manager ^^) which is a simple and easy to use tool. (<a href="https://github.com/tristanisham/zvm">https://github.com/tristanisham/zvm</a>)
</p>
</div>

<div id="outline-container-orgd29176a" class="outline-4">
<h4 id="orgd29176a"><span class="section-number-4">2.4.1.</span> Basic usage</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Installing the tool:
</p>
<div class="org-src-container">
<pre class="src src-bash">curl https://raw.githubusercontent.com/tristanisham/zvm/master/install.sh | bash
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"# ZVM"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">ZVM_INSTALL</span>=<span style="color: #e9b96e;">"$HOME/.zvm/self"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">PATH</span>=<span style="color: #e9b96e;">"$PATH:$HOME/.zvm/bin"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">PATH</span>=<span style="color: #e9b96e;">"$PATH:$ZVM_INSTALL/"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
</pre>
</div>

<p>
Listing all the versions available to download:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm ls --all
</pre>
</div>

<p>
Downloading a specific version:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm i master
</pre>
</div>

<p>
Display all your downloaded versions:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm ls
</pre>
</div>

<p>
Use one of those versions:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm use master
</pre>
</div>

<p>
There are other commands available, you can check them by running: 'zvm help' or checking the repository: <a href="https://github.com/tristanisham/zvm">https://github.com/tristanisham/zvm</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgcbad7dc" class="outline-3">
<h3 id="orgcbad7dc"><span class="section-number-3">2.5.</span> defer</h3>
<div class="outline-text-3" id="text-2-5">
<p>
If you are coming from the C world, this keyword might surprise you and greatly impact your life, if you already know it from other languages like Go, bear with us to see how it is particulary useful in a language that has to manage its own memory.
</p>

<p>
`defer` is a really simple keyword all it does is: <b>execute code at the end of the current scope</b>.
</p>

<p>
Might not sound like much, because you might think "I could just put it at the of my scope", you are not entirely wrong but:
</p>
<ul class="org-ul">
<li>Doing so makes your code less readable/understandable, because you have to scroll to the end of the function to find the code you might need that is related something hundred of lines above.</li>
<li>Humans are error proned and sometimes forget, by instantly adding a defer after the related code you can be sure not to forget it later.</li>
</ul>

<p>
TODO mettre un lien vers errors/errdefer
</p>
</div>

<div id="outline-container-org59b9d34" class="outline-4">
<h4 id="org59b9d34"><span class="section-number-4">2.5.1.</span> Exemple</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Here is an exemple where `defer` really shines:
</p>
</div>
</div>

<div id="outline-container-orgde5e54d" class="outline-4">
<h4 id="orgde5e54d"><span class="section-number-4">2.5.2.</span> Freeing memory</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
In the following code, the programmer forgot to free the memory assigned to ptr<sub>cool</sub><sub>number</sub> by calling <b>destroy</b>. Memeory leaks like that could be hard to find in a large codebase because you would have to check every single allocation and find its corresponding free somewhere in the code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"we sometime forget to free memory"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.testing.allocator; <span style="color: #73d216;">// </span><span style="color: #73d216;">Allocator that detect memory leaks</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">bytes</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u64</span>, 10);

    <span style="color: #b4fa70;">for</span> (0..9) |i| {
        bytes[i] = i;
    }

    <span style="color: #73d216;">// </span><span style="color: #73d216;">BLA BLA BLA lot of code normally here :)</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ptr_cool_number</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u64</span>);
    ptr_cool_number.* = bytes[2];

    <span style="color: #73d216;">//</span><span style="color: #73d216;">allocator.destroy(ptr_cool_number);</span>
    allocator.free(bytes);
}
</pre>
</div>

<p>
But this could be better by using the <b>defer</b> keyword and writing the dealloaction code right after the allocation one. This way if you have a memory leak, you just have to see everywhere you allocated and be sure there is a deallocation next to it.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"and sometimes we just use defer and life is better"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.testing.allocator; <span style="color: #73d216;">// </span><span style="color: #73d216;">Allocator that detect memory leaks</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">bytes</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u64</span>, 10);
    <span style="color: #b4fa70;">defer</span> allocator.free(bytes);

    <span style="color: #b4fa70;">for</span> (0..9) |i| {
        bytes[i] = i;
    }

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ptr_cool_number</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u64</span>);
    <span style="color: #b4fa70;">defer</span> allocator.destroy(ptr_cool_number);

    ptr_cool_number.* = bytes[2];
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org2389fd9" class="outline-3">
<h3 id="org2389fd9"><span class="section-number-3">2.6.</span> Testing code</h3>
<div class="outline-text-3" id="text-2-6">
<p>
## Tracking
### Race conditions
</p>

<p>
### Memory leak
#### C allocations
For high performances and very few safety checks, you might want to use the <a href="https://ziglang.org/documentation/master/std/#std.heap.c_allocator">std.heap.c<sub>allocator</sub></a>.
</p>

<p>
Those allocations are not tracked by the Zig runtime, so you will have to use a tool like Valgrind to track memory leaks which can be done via the <a href="https://ziglang.org/documentation/master/std/#std.valgrind">std</a>.
</p>

<p>
TODO exemple, j attends d avoir eu le cours de HPC sur valgrind
</p>

<p>
#### Zig allocations
The General Purpose Allocator (GPA) is a general-purpose memory allocator that is used by the Zig standard library. Its advantages over the other implementations in the std it that it is designed for safety over performance.
</p>

<p>
Note that all those problems are given to us a runtime and not compile time.
</p>

<p>
It can in fact detect memory problems like:
</p>
<ul class="org-ul">
<li>memory leaks</li>
<li>use-after-free</li>
<li>double-free</li>
</ul>

<p>
But it cannot yet detect things like data races (which you could think it could with the <b>.thread<sub>safe</sub></b> option).
</p>

<p>
What <b>.thread<sub>safe</sub></b> does is that it makes the allocator thread-safe, meaning that it can be used in a multi-threaded environment without any problem. If you don't and use the same allocator for multiples threads, the allocator might not behave correctly.
</p>

<p>
You can have more informations on the topic following a discussion I had on the Zig discord server <a href="https://discord.com/channels/605571803288698900/1237126868927512718">here</a>.
</p>

<p>
#### Memory leaks
In the exemple below, the memory allocated to <b>a</b> is freed (with <b>destroy</b> here), if you were to comment the <b>destroy</b> line, the GPA would detect a memory leak and tell you what memory leaked giving a stacktrace and the memory address of the leaked memory.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">status</span> = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

    <span style="color: #b4fa70;">if</span> (status == .leak) {
        std.debug.print(<span style="color: #e9b96e;">"Memory leak detected\n"</span>, .{});
    } <span style="color: #b4fa70;">else</span> {
        std.debug.print(<span style="color: #e9b96e;">"No memory leak detected\n"</span>, .{});
    }
}
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>
</pre>
</div>

<p>
#### Use after free
Following the previous exemple we are going to try to access the memory after it has been freed, this will result in a use-after-free error.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> _ = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>

a.* = 4; <span style="color: #73d216;">// </span><span style="color: #73d216;">USE AFTER FREE</span>
</pre>
</div>

<p>
#### Invalid free
By still keeping the previous exemples, we are going to double free and get an error.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> _ = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">DOUBLE FREE</span>
</pre>
</div>

<p>
### Sources 
</p>
<ul class="org-ul">
<li><a href="https://discord.com/channels/605571803288698900/1235733415886721064">https://discord.com/channels/605571803288698900/1235733415886721064</a></li>
<li><a href="https://zig.guide/standard-library/allocators">https://zig.guide/standard-library/allocators</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgcffde92" class="outline-3">
<h3 id="orgcffde92"><span class="section-number-3">2.7.</span> TCP stream</h3>
<div class="outline-text-3" id="text-2-7">
</div>
<div id="outline-container-org7403460" class="outline-4">
<h4 id="org7403460"><span class="section-number-4">2.7.1.</span> <span class="todo TODO">TODO</span> How Zig manages stream</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
Does Zig manage tcp stream with the OS stream or has it created its own implementation ?
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfd992fe" class="outline-2">
<h2 id="orgfd992fe"><span class="section-number-2">3.</span> Comptime</h2>
<div class="outline-text-2" id="text-3">
<p>
Zig has a concept called <code>comptime</code>, it's stands for "compile-time".
Comptime is used to evaluate an expression at compile time and not at runtime.
In comparison with C, Zig comptime has the purpose of replacing marco with a more explicit syntax.
In fact, C's macro tends to be error-prone when using it.
The advantage of using comptime over macro is the type safety of Zig when writing comptime.
</p>
</div>

<div id="outline-container-orgef1190a" class="outline-3">
<h3 id="orgef1190a"><span class="section-number-3">3.1.</span> When to use and when NOT to use it</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgaaa74d9" class="outline-4">
<h4 id="orgaaa74d9"><span class="section-number-4">3.1.1.</span> When to use it</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Because the compiler can now do things at compilation time, leaving less work to be done at runtime. (if the compiler gives you the power to do things at compile time so easily, you should use it ^^)
</p>

<p>
So you should basically try to use it as much as you can.
</p>
</div>
</div>

<div id="outline-container-org2d1dd56" class="outline-4">
<h4 id="org2d1dd56"><span class="section-number-4">3.1.2.</span> When NOT to use it (source: ziglings)</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The following contexts are already IMPLICITLY evaluated at
compile time, and adding the 'comptime' keyword would be
superfluous, redundant, and smelly:
</p>

<ul class="org-ul">
<li>The container-level scope (outside of any function in a source file)</li>
<li>Type declarations of:
<ul class="org-ul">
<li>Variables</li>
<li>Functions (types of parameters and return values)</li>
<li>Structs</li>
<li>Unions</li>
<li>Enums</li>
</ul></li>
<li>The test expressions in inline for and while loops</li>
<li>An expression passed to the @cImport() builtin</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org0e6eb60" class="outline-3">
<h3 id="org0e6eb60"><span class="section-number-3">3.2.</span> Compile-time evaluation</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org694dc09" class="outline-4">
<h4 id="org694dc09"><span class="section-number-4">3.2.1.</span> Compile-time variable</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
In Zig, there are variables that can be evaluated at compile-time, in fact, Zig allows computing mutating variables at compile-time but all the inputs need to be known also at compile-time.
If not, the compiler will throw a compile error. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
For a mutating variable at compile-time, Zig requires naming the variables with a <code>comptime var</code>.
But if the variable is a constant, the compiler requires to use a <code>const</code>. 
</p>

<p>
Like in the example below, the variable named <code>variableAtCompileTime</code> is evaluated at compile-time because all the inputs are known.
On the other hand, the variable named <code>constantAtRuntime</code> cannot be a comptime variable because its dependency is based on unknown before runtime.
</p>

<p>
Moreover, in the example, the <code>inline for</code> is used to unroll the for loop.
This allows to use for loops in comptime indeed, if a standard for loop is used, it will cause an error because the capture value will be evaluated at runtime.<a href="#citeproc_bib_item_1">[1]</a> 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">randVariable</span> = std.crypto.random.float(<span style="color: #8cc4ff;">f32</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">selectedConstant</span> = 6;

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">constantAtRuntime</span> = randVariable * selectedConstant;

<span style="color: #b4fa70;">comptime</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">variableAtCompileTime</span> = selectedConstant * selectedConstant;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">array</span> = [_]<span style="color: #8cc4ff;">comptime_int</span> { 3, 2, 1};

<span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (array) |item| {
    variableAtCompileTime += item;
}

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"constant-at-runtime {d:.2}\n"</span>, .{constantAtRuntime});
<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"variable-at-compile-time  {d}"</span>, .{variableAtCompileTime});

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">constant-at-runtime</td>
<td class="org-right">5.62</td>
</tr>

<tr>
<td class="org-left">variable-at-compile-time</td>
<td class="org-right">42</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgde0957e" class="outline-4">
<h4 id="orgde0957e"><span class="section-number-4">3.2.2.</span> Compile-time expression</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
In Zig, an expression can have a <code>comptime</code> to tell the compiler to evaluate the expression at compile-time.
Like a compile-time variable, if an expression cannot be evaluated at compile-time, a compile-time error will be thrown.
</p>

<p>
With a prefixed <code>comptime</code> keyword Zig can interpret a function at compile-time instead of runtime. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
A good example of demonstrating comptime expression is in the standard documentation <a href="#citeproc_bib_item_1">[1]</a>.
The results show that the comptime expression is faster than the runtime one when the code is executed (runtime) because the work has already been done.
But this will work only with code that hasn't runtime dependency code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Timer</span> = std.time.Timer;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">fib</span>(<span style="color: #fcaf3e;">iteration</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">if</span> (iteration &lt; 2) <span style="color: #b4fa70;">return</span> iteration;

    <span style="color: #b4fa70;">return</span> fib(iteration - 1) + fib(iteration - 2);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"comptime fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">comptime</span> fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-comptime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(610, result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">result</span> = fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-runtime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expect(610 == result);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb50963" class="outline-4">
<h4 id="orgcb50963"><span class="section-number-4">3.2.3.</span> Compile-time parameter</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Zig implements generic by using duck typing at compile-time.
To use generic, Zig needs to know the type at compile-time.
</p>
<div class="org-src-container">
<pre class="src src-zig">
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">greater</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">array</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">T</span>) !?T {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">max</span>: ?<span style="color: #8cc4ff;">T</span> = <span style="color: #e9b2e3;">null</span>;
    <span style="color: #b4fa70;">for</span> (array) |item| {
        <span style="color: #b4fa70;">if</span> (max) |m| {
            <span style="color: #b4fa70;">if</span> (m &lt; item) {
                max = item;
            }
        } <span style="color: #b4fa70;">else</span> {
            max = item;
        }
    }
    <span style="color: #b4fa70;">return</span> max;
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an i32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intArray</span> = [_]<span style="color: #8cc4ff;">i32</span>{ 2, 9, 4, 6, 7, 1};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">i32</span>, &amp;intArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 9);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an f32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">floatArray</span> = [_]<span style="color: #8cc4ff;">f32</span>{ 2.34, 14.55, 4.12, 6.876, 7.111 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">f32</span>, &amp;floatArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 14.55);
}


</pre>
</div>

<p>
But with duck typing, if the same method is used, an error will be thrown at compile time:
</p>
<div class="org-src-container">
<pre class="src src-Zig">test "should fail with bool" {
    const boolArray = [_]bool{ true, false, true, true };
    const result = greater(bool, &amp;boolArray);
}
</pre>
</div>

<p>
The error will be:
</p>
<pre class="example" id="org783fd14">
error: operator &lt; not allowed for type 'bool'
</pre>

<p>
Moreover, comptime can also be used as a type definition.
For this, the function needs to return a <code>type</code>.
The example below is based on <a href="https://zig.guide/language-basics/comptime">the zig guide</a> <a href="#citeproc_bib_item_2">[2]</a>, it's shows that it can define a new type with a function.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">width</span>: <span style="color: #8cc4ff;">comptime_int</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">height</span>: <span style="color: #8cc4ff;">comptime_int</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> [height][width]T;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix3x3</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> Matrix(T, 3, 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a type"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix(<span style="color: #8cc4ff;">f32</span>, 4, 4) == [4][4]<span style="color: #8cc4ff;">f32</span>);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a 3x3 matrix"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix3x3(<span style="color: #8cc4ff;">f32</span>) == [3][3]<span style="color: #8cc4ff;">f32</span>);
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb9e0c1f" class="outline-3">
<h3 id="orgb9e0c1f"><span class="section-number-3">3.3.</span> Metaprogramming</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org2ced803" class="outline-4">
<h4 id="org2ced803"><span class="section-number-4">3.3.1.</span> <code>@TypeOf</code></h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
The <code>@TypeOf</code> builtin function can be used to take as a parameter an expression and return a type.
</p>
</div>
</div>

<div id="outline-container-orgf0d87d7" class="outline-4">
<h4 id="orgf0d87d7"><span class="section-number-4">3.3.2.</span> <code>@typeInfo</code></h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
This built-in function provides type reflection, it returns information on type.
</p>

<p>
See the example <code>Example with a custom CSV writer based on type</code> to have a view of the usability.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdea1c44" class="outline-3">
<h3 id="orgdea1c44"><span class="section-number-3">3.4.</span> <span class="todo TODO">TODO</span> Optimization</h3>
<div class="outline-text-3" id="text-3-4">
<p>
inline for / while
</p>
</div>

<div id="outline-container-org59cd52e" class="outline-4">
<h4 id="org59cd52e"><span class="section-number-4">3.4.1.</span> How log works in Zig</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
In the C language, a common use to use debug print is with Marco.
Like in this example, if the <code>DEBUG</code> is defined to <code>1</code> the code will print the debug info.
If the <code>DEBUG</code> is not set, at the compilation, all the print information will be removed.
</p>
<div class="org-src-container">
<pre class="src src-C">
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">DEBUG</span> 1

<span style="color: #e090d7;">#if</span> DEBUG 
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>) <span style="color: #8cc4ff;">printf</span> <span style="color: #fcaf3e;">x</span>;
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>)
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  TRACE((<span style="color: #e9b96e;">"Hello World! : %d\n"</span>, 12));
}
</pre>
</div>

<p>
In Zig, logging uses this same principle, a message level is set at the start of the program (at compile-time) and if the log is not enabled, all the code about the print is removed.
However, if the log level is greater than the limit, the message will be printed.
</p>

<p>
The code below shows an extract of the standard library for logging.
</p>
<div class="org-src-container">
<pre class="src src-zig"> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">log</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">message_level</span>: <span style="color: #8cc4ff;">Level</span>,
    <span style="color: #b4fa70;">comptime</span> scope: <span style="color: #e090d7;">@Type</span>(.EnumLiteral),
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">format</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">args</span>: <span style="color: #8cc4ff;">anytype</span>,
) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">comptime</span> !logEnabled(message_level, scope)) <span style="color: #b4fa70;">return</span>;

    std.options.logFn(message_level, scope, format, args);
}
</pre>
</div>

<p>
In addition, Zig provides some helper functions for logging, such as :
</p>
<ul class="org-ul">
<li><code>std.log.debug</code></li>
<li><code>std.log.info</code></li>
<li><code>std.log.warn</code></li>
<li><code>std.log.err</code></li>
</ul>

<p>
And if the release mode is set to <code>Debug</code>, the debug log will be printed.
But if the release mode is set to <code>Release*</code>, the debug log will not print, there is no need to configure the logging to have this behavior.
</p>
</div>
</div>
</div>

<div id="outline-container-org7898e7b" class="outline-3">
<h3 id="org7898e7b"><span class="section-number-3">3.5.</span> Generic data structures</h3>
<div class="outline-text-3" id="text-3-5">
<p>
To create a generic data structure, the same pattern is used as a comptime parameter.
A function needs to return an anonymous struct as a type <code>type</code>.
</p>

<p>
In a generic data structure, the <code>@This()</code> is used to get the type of the data structure because it is anonymous.
</p>

<p>
Moreover, a generic data structure can have two type of function:
</p>
<ol class="org-ol">
<li>a function that can be called on the structure type</li>
<li>a function that can be called on the instance of the structure.</li>
</ol>

<p>
To have an instance function, the first argument needs to be a parameter of the type of the struct.
That's why a constant <code>Self</code> is used with <code>@This()</code>.
And after that, the parameter <code>self</code> can be used to get the members of the struct.
</p>

<p>
The example shows the difference between a function that can be called on a struct and a function that can be called on an instance of a struct.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">structFunction</span>(<span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structFunction\n"</span>, .{});
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">instanceFunction</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structInstance: {d}\n"</span>, .{self.myNumber});
        }
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

    <span style="color: #b4fa70;">try</span> MyStruct(<span style="color: #8cc4ff;">f32</span>).structFunction(stdout);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = MyStruct(<span style="color: #8cc4ff;">f32</span>){
        .myNumber = 42,
    };

    <span style="color: #b4fa70;">try</span> myStruct.instanceFunction(stdout);
}

</pre>
</div>

<p>
In Zig, a structure name can be explicitly given or Zig can infer the name of a struct when there are created:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure name is infered</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct1</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>) {
        .myNumber = 42,
    };
    _ = myStruct1;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure has a explicit name</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intStruct</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct2</span> =  intStruct {
        .myNumber = 42,
    };
    _ = myStruct2;
}
</pre>
</div>

<p>
Here's an compete example of an generic linked list :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">LinkedList</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Node</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">data</span>: <span style="color: #8cc4ff;">T</span>,
            <span style="color: #fcaf3e;">prev</span>: ?*<span style="color: #8cc4ff;">Node</span>,
            <span style="color: #fcaf3e;">next</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        };

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">LinkedListError</span> = <span style="color: #b4fa70;">error</span>{headNull};
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();
        <span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator,
        <span style="color: #fcaf3e;">head</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        <span style="color: #fcaf3e;">len</span>: <span style="color: #8cc4ff;">u32</span> = 0,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .head = <span style="color: #e9b2e3;">null</span>,
                .allocator = allocator,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>) <span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">curr</span> = self.head;

            <span style="color: #b4fa70;">while</span> (curr) |currNotNull| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">node</span> = currNotNull;
                curr = currNotNull.next;
                self.allocator.destroy(node);
            }
            self.len = 0;
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">push</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">node</span> = <span style="color: #b4fa70;">try</span> self.allocator.create(Node);
            node.*.data = value;
            self.len += 1;

            <span style="color: #b4fa70;">if</span> (self.head) |head| {
                node.next = head;
                head.prev = node;
                self.head = node;
            } <span style="color: #b4fa70;">else</span> {
                self.head = node;
                node.*.next = <span style="color: #e9b2e3;">null</span>;
                node.*.prev = <span style="color: #e9b2e3;">null</span>;
            }
        }
    };
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a i32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 42;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a f32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">f32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 3.1415;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1aef0a7" class="outline-3">
<h3 id="org1aef0a7"><span class="section-number-3">3.6.</span> Example with a custom CSV writer based on type</h3>
<div class="outline-text-3" id="text-3-6">
<p>
This example shows that Zig has a type reflection with the keyword <code>@typeInfo</code>.
The goal of this example is to create CSV output with a generic struct as input.
Only with the <code>try csv.stringify(&amp;arrayList, stream.writer());</code> function the <code>CsvWriter</code> can infer at comptime the struct pass as argument.
For this example, a basic struct named <code>Person</code> will be transformed to CSV.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">CsvWriter</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">separator</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b96e;">','</span>,
        };
        <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .config = config,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">stringify</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">arrayList</span>: *<span style="color: #8cc4ff;">std</span>.ArrayList(T), <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writeHeader(self, &amp;writer);
            <span style="color: #b4fa70;">for</span> (arrayList.items) |item| {
                <span style="color: #b4fa70;">try</span> writeType(self, item, &amp;writer);
            }
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeHeader</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{field.name});
                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeType</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">item</span>: <span style="color: #8cc4ff;">T</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">if</span> (<span style="color: #e090d7;">@TypeOf</span>(fields) != []<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span>.builtin.Type.StructField)
                <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"The type is not the a struct"</span>);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span> = <span style="color: #e090d7;">@field</span>(item, field.name);

                <span style="color: #b4fa70;">switch</span> (<span style="color: #e090d7;">@typeInfo</span>(<span style="color: #e090d7;">@TypeOf</span>(f))) {
                    .Int =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Float =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Pointer =&gt; |pointer| {
                        <span style="color: #b4fa70;">if</span> (pointer.size == std.builtin.Type.Pointer.Size.Slice <span style="color: #b4fa70;">and</span> pointer.child == <span style="color: #8cc4ff;">u8</span>) {
                            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{f});
                        } <span style="color: #b4fa70;">else</span> {
                            <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>);
                        }
                    },
                    <span style="color: #b4fa70;">else</span> =&gt; <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>),
                }

                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }
    };
}

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Person</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">sexe</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">date</span>: <span style="color: #8cc4ff;">u32</span>,
};


<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person1</span> = .{ .sexe = <span style="color: #e9b96e;">"M"</span>, .name = <span style="color: #e9b96e;">"Lucas"</span>, .date = 2000 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person2</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Ava"</span>, .date = 2020 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person3</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Sophia"</span>, .date = 1989 };

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arrayList</span> = std.ArrayList(Person).init(gpa.allocator());
    <span style="color: #b4fa70;">defer</span> arrayList.deinit();

    <span style="color: #b4fa70;">try</span> arrayList.append(person1);
    <span style="color: #b4fa70;">try</span> arrayList.append(person2);
    <span style="color: #b4fa70;">try</span> arrayList.append(person3);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">stream</span> = std.io.fixedBufferStream(buffer[0..]);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">personCsvWriter</span> = CsvWriter(Person);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">csv</span> = personCsvWriter.init(.{ .separator = <span style="color: #e9b96e;">' '</span> });
    <span style="color: #b4fa70;">try</span> csv.stringify(&amp;arrayList, stream.writer());

    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"{s}"</span>, .{stream.getWritten()});

}

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sexe</td>
<td class="org-left">name</td>
<td class="org-right">date</td>
</tr>

<tr>
<td class="org-left">M</td>
<td class="org-left">Lucas</td>
<td class="org-right">2000</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Ava</td>
<td class="org-right">2020</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Sophia</td>
<td class="org-right">1989</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4871464" class="outline-3">
<h3 id="org4871464"><span class="section-number-3">3.7.</span> Bonus</h3>
<div class="outline-text-3" id="text-3-7">
<p>
Here is a very nice blog written by a core member of the ZIG community if you want to dig further: <a href="https://kristoff.it/blog/what-is-zig-comptime/">https://kristoff.it/blog/what-is-zig-comptime/</a>
</p>

<p>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</p>
</div>
</div>
</div>
<div id="outline-container-org77eb809" class="outline-2">
<h2 id="org77eb809"><span class="section-number-2">4.</span> Zig and C</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org9cc8339" class="outline-3">
<h3 id="org9cc8339"><span class="section-number-3">4.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The interoperability between Zig and C is one of the most important feature of Zig. But why ?
</p>

<p>
It is one of the main goal of Zig to <a href="https://ziglang.org/">incrementally improve your C/C++/Zig codebase</a>, so you could use C code almost as much as easy as you could use Zig code.
</p>

<p>
It allows to have both of a <b>modern</b> language and a <b>mature</b> ecosystem.
</p>
</div>
</div>

<div id="outline-container-org39c1a19" class="outline-3">
<h3 id="org39c1a19"><span class="section-number-3">4.2.</span> Main differences between Zig and C in the syntax</h3>
<div class="outline-text-3" id="text-4-2">
<p>
There are a few main differences between the 2 languages that you have high chance of encountering but obviously not all of them are listed here.
</p>
</div>

<div id="outline-container-org1df27a3" class="outline-4">
<h4 id="org1df27a3"><span class="section-number-4">4.2.1.</span> Types</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Here you can find all the primitive types in Zig and their C equivalent:
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Primitive-Types">https://ziglang.org/documentation/master/#Primitive-Types</a>
</p>

<p>
<a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a>
</p>

<p>
TODO would it be better if i do the array in the doc rather than having a link to it ?
</p>
</div>
</div>

<div id="outline-container-org79b9e25" class="outline-4">
<h4 id="org79b9e25"><span class="section-number-4">4.2.2.</span> Loops</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
In Zig, the for loop is not used as much as in C. 
Instead, the while loop is used more often. The for loop is used when iterating over multiples elements of a container (typically slices or arrays), so it basically is a kind of foreach loop. In all the other cases the while loop is used.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">items</span> = [_]<span style="color: #8cc4ff;">u16</span> { 1, 4, 0, 1 };
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">sum</span>: <span style="color: #8cc4ff;">u16</span> = 0;
<span style="color: #b4fa70;">for</span> (items) |value| {
    sum += value;
}
std.debug.print(<span style="color: #e9b96e;">"Sum: {}\n"</span>, .{sum});
</pre>
</div>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">for</span> (0..3) |i| {
    i += 1;
    std.debug.print(<span style="color: #e9b96e;">"i: {}\n"</span>, .{i});
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge181b66" class="outline-4">
<h4 id="orge181b66"><span class="section-number-4">4.2.3.</span> Pointers</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
Zig has 2 different pointers:
</p>
<ul class="org-ul">
<li>Single-item pointers: *T</li>
<li>Many-item pointers: [*]T</li>
</ul>
<p>
Which can both be optional by adding a "?".
</p>

<p>
But actually&#x2026;. there is a third pointer type:
</p>
<ul class="org-ul">
<li>The C pointer: [*c]T</li>
</ul>
<p>
This one is to be avoided as much as possible. The only reasons for its existence is for the translation from C code to Zig code, when the translater is not able to know what to convert it to in Zig (eg. sometimes it does not know if it can convert it to a non-optional pointer or not which could cause UBs).
</p>
</div>
</div>

<div id="outline-container-orgae92f18" class="outline-4">
<h4 id="orgae92f18"><span class="section-number-4">4.2.4.</span> Type conversions</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
Since in Zig there is no implicit conversions, depending on the project you might end up having "ugly" code with a lot of explicit type conversions. The code is more verbose but it is also less error-prone.
Exemple:
ZIG:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">rgb_to_grayscale_1d</span>(<span style="color: #fcaf3e;">img</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t, <span style="color: #fcaf3e;">result</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.height * img.width))) : (i += 1) {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">index</span> = i * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.components));
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">grayscale_value</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e090d7;">@intFromFloat</span>(imageh.FACTOR_R * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.R_OFFSET + index])) +
            imageh.FACTOR_G * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.G_OFFSET + index])) +
            imageh.FACTOR_B * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.B_OFFSET + index])));
        result.data[i] = grayscale_value;
    }
}
</pre>
</div>
<p>
C:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">rgb_to_grayscale_1D</span>(<span style="color: #b4fa70;">const</span> <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">img</span>, <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">result</span>) {
  printf(<span style="color: #e9b96e;">"height: %d"</span>, img-&gt;height);
  <span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">i</span> = 0; i &lt; img-&gt;height * img-&gt;width; i++) {
    <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">index</span> = i * img-&gt;components;
    <span style="color: #8cc4ff;">uint8_t</span> <span style="color: #fcaf3e;">grayscale_value</span> = (<span style="color: #8cc4ff;">uint8_t</span>)(FACTOR_R * img-&gt;data[R_OFFSET] +
                                        FACTOR_G * img-&gt;data[G_OFFSET] +
                                        FACTOR_B * img-&gt;data[B_OFFSET]);
    result-&gt;data[i] = grayscale_value;
  }
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org0212933" class="outline-3">
<h3 id="org0212933"><span class="section-number-3">4.3.</span> How to call a C function from Zig</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Add those lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addIncludePath(.{ .path = <span style="color: #e9b96e;">"c-src"</span> }); <span style="color: #73d216;">// </span><span style="color: #73d216;">Folder containing the C files</span>
exe.linkLibC(); <span style="color: #73d216;">// </span><span style="color: #73d216;">Link the C standard library (which is zig own libc btw)</span>
</pre>
</div>

<p>
Then you can call the C functions like this from your Zig code:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c_hello</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"hello.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    c_hello.hello();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">res</span> = c_hello.add(1, 2);
    std.debug.print(<span style="color: #e9b96e;">"1 + 2 = {d}\n"</span>, .{res});
}
</pre>
</div>
<p>
Note that you can only do 1 @cImport per project. So what i recommend you to do is create a file containing all the c libraries you need in a file like so:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdio.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdlib.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"image.h"</span>);
});
</pre>
</div>
<p>
Then call this zig file in your other zig files.
</p>
</div>
</div>

<div id="outline-container-orgc476cce" class="outline-3">
<h3 id="orgc476cce"><span class="section-number-3">4.4.</span> How to call a Zig function from C / Continuing a C project with Zig</h3>
<div class="outline-text-3" id="text-4-4">
<p>
You can continue your C project without using Clang or GCC but by using Zig with all its toolchain it comes with.
</p>

<p>
In order to have a c file (main.c) as the entry point of your project using the zig build tool you have to add/comment the following lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">exe</span> = b.addExecutable(.{
    .name = <span style="color: #e9b96e;">"c_project"</span>,
    <span style="color: #73d216;">// </span><span style="color: #73d216;">.root_source_file = b.path("src/main.zig"),</span>
    .target = target,
    .optimize = optimize,
});
exe.root_module.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"src/main.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
exe.linkLibC();
</pre>
</div>

<p>
If you want to have more C files than just main.c you can add them like so:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"c-src/image.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
</pre>
</div>

<p>
TODO utiliser code zig dans project C <a href="https://zig.guide/working-with-c/calling-conventions">https://zig.guide/working-with-c/calling-conventions</a>
</p>
</div>

<div id="outline-container-org1b8cfad" class="outline-4">
<h4 id="org1b8cfad"><span class="section-number-4">4.4.1.</span> export and extern keywords</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
<b>export</b> make the the function visible from outside so that the C ABI can see it.
</p>

<p>
<b>extern</b> is used to link against an exported variable from an other object.
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Variables">Zig documentation for those 2 keywords.</a>
</p>

<p>
TODO jai oublie d ajouter du code zig, ne pas oublier export/extern
</p>

<p>
TODO pros and cons of using zig toolchain instead of clang or gcc
</p>
</div>
</div>
</div>

<div id="outline-container-orga6a57bf" class="outline-3">
<h3 id="orga6a57bf"><span class="section-number-3">4.5.</span> How is it done under the hood</h3>
<div class="outline-text-3" id="text-4-5">
<p>
When you do @cImport(@cInclude("foo.h")) in your zig code it runs translate-c and exposes the function and type definitions.
</p>

<p>
TODO talk about C ABI
</p>
</div>
</div>

<div id="outline-container-orgfe9420c" class="outline-3">
<h3 id="orgfe9420c"><span class="section-number-3">4.6.</span> Util to translate C code to Zig</h3>
<div class="outline-text-3" id="text-4-6">
<p>
zig translate-c is an util built in the zig toolchains that allows you to translate C code to Zig code.
You can translate any code but the code is going to be UNREADABLE, so I would not recommend this tool if you plan on modifying the code afterwards.
You have better time importing the C code in your Zig code.
Note that if you want to translate a C file that uses the libc you have to add the -lc flag like so:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig translate-c main.c -lc
</pre>
</div>
</div>

<div id="outline-container-org1760d64" class="outline-4">
<h4 id="org1760d64"><span class="section-number-4">4.6.1.</span> Comparison with other langauges that use C code</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
To test if integrating C code in Zig projects is really as seemless as some claims, I have decided to compare the C integration with Python aswell.
</p>

<p>
In order to do that I wrote a small C library:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">add</span>(<span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">a</span>, <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">b</span>) { <span style="color: #b4fa70;">return</span> a + b; }
</pre>
</div>

<p>
What I am going to do is test how much time it takes each program to run this function x times. (in this case x = 100'000'000)
</p>

<p>
Note: I didnt use any optimization in flag in python (because it did not change anything) and neither in Zig because I didnt want the compiler to try to optimize the code and be lazy.
</p>

<p>
Then in order to compare the 2 languages I wrote 4 programs:
</p>
<ul class="org-ul">
<li>Zig code that has and add function implementation in Zig</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">add</span>(<span style="color: #fcaf3e;">a</span>: <span style="color: #8cc4ff;">u32</span>, <span style="color: #fcaf3e;">b</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">return</span> a + b;
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.38sec
</p>

<ul class="org-ul">
<li>Vanilla Python code that has and add function implementation in Python</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">add</span>(a, b):
    <span style="color: #b4fa70;">return</span> a + b


<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    add(3, 7)
<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"done!"</span>)
</pre>
</div>
<p>
Result: ~10sec
</p>

<ul class="org-ul">
<li>Zig code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"mylib.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = c.add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done!\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.41sec
</p>

<ul class="org-ul">
<li>Python code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">import</span> ctypes

<span style="color: #fcaf3e;">mylib</span> = ctypes.CDLL(<span style="color: #e9b96e;">'./mylib.so'</span>)

mylib.add.<span style="color: #fcaf3e;">argtypes</span> = (ctypes.c_int, ctypes.c_int)
mylib.add.<span style="color: #fcaf3e;">restype</span> = ctypes.c_int

<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    <span style="color: #fcaf3e;">result</span> = mylib.add(3, 4)

<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"Result of last addition:"</span>, result)
</pre>
</div>
<p>
Result: ~50sec
</p>

<p>
TODO faire un joli graphique quand jaurai d autres languages
TODO idk if it would be possible to compile my c library and then use it in my python code, and all of that all in emacs, that would be cool :)
TODO do with other languages aswell
</p>
</div>

<ol class="org-ol">
<li><a id="org908e350"></a>Conclusion<br />
<div class="outline-text-5" id="text-4-6-1-1">
<p>
First thing that we notice immediately is how much faster the Zig code is compared to the Python code. This is not surprising since Zig is a compiled language and Python is an interpreted language.
</p>

<p>
TODO why is python so slow ?
</p>

<p>
The second interesting thing is that the 2 Zig codes dont vary that much (if they even do) compared to the 2 python codes which have a 5x ratio. This is interesting because it shows that the overhead of calling a C function from Zig is not that big (in fact it is even not existent since all the compiler does is translating the C code to Zig code at compilation time).
</p>

<p>
We can conclude that calling C code from Zig is really seemless, because at runtime &#x2026; everything is Zig code.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org876a864" class="outline-3">
<h3 id="org876a864"><span class="section-number-3">4.7.</span> Notes</h3>
<div class="outline-text-3" id="text-4-7">
<p>
TODO For some unkown reason yet my LSP becomes very slow when working in a Zig project with C files and sometimes crashes. I have to investigate this further.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/master/#C-Pointers">https://ziglang.org/documentation/master/#C-Pointers</a></li>
<li><a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a></li>
<li><a href="https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8">https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8</a></li>
<li><a href="https://mtlynch.io/notes/zig-call-c-simple/">https://mtlynch.io/notes/zig-call-c-simple/</a></li>
<li><a href="https://ziglang.org/documentation/master/#cImport-vs-translate-c">https://ziglang.org/documentation/master/#cImport-vs-translate-c</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd09189b" class="outline-2">
<h2 id="orgd09189b"><span class="section-number-2">5.</span> Compilation - build system</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgaf08c17" class="outline-3">
<h3 id="orgaf08c17"><span class="section-number-3">5.1.</span> Zig package manager</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Since 0.11, Zig has now an official built-in package manager named.
</p>

<p>
There is no global repository like <a href="https://crates.io">crates.io</a>(Rust) or <a href="https://npm.js.com">npmjs</a>(Node.js) for Zig packages. Instead, Zig packages are distributed as git repositories.
</p>

<p>
In order to add packages to your project you are going to create and edit a file in the root of your project named "build.zig.zon" (zon stands for Zig Object Notation, which is an equivalent to json).
</p>
</div>

<div id="outline-container-org3cd0adf" class="outline-4">
<h4 id="org3cd0adf"><span class="section-number-4">5.1.1.</span> Add a package in your project</h4>
<div class="outline-text-4" id="text-5-1-1">
<ol class="org-ol">
<li>Add the packages you want in your build.zig.zon file</li>
</ol>
<div class="org-src-container">
<pre class="src src-zon">.{
    .name = "name-of-my-project",
    .version = "0.0.1",

    .dependencies = .{
        // Here you add all the packages you want, in this exemple I have imported zap which is a web framework
        .zap = .{
            .url = "https://github.com/zigzap/zap/archive/refs/tags/v0.1.7-pre.tar.gz",
            .hash = "1220002d24d73672fe8b1e39717c0671598acc8ec27b8af2e1caf623a4fd0ce0d1bd",
        },
    }
}
</pre>
</div>
<p>
You can get further understanding in how to write your build.zig.zon following the official doc: <a href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md">https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md</a>
</p>

<p>
With 0.12.0 you can now use the "zig fetch" command from the root of your zig project to fetch the packages you need:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig fetch --save git+https://github.com/zigzap/zap/#HEAD
</pre>
</div>

<p>
If you are prior to 0.12.0, you can write the "url" parameter without the "hash", then "zig build" and the outpout will give you the correct hash that you can then put back in your build.zig.zon file.
</p>

<ol class="org-ol">
<li>Add those added packages in your build.zig</li>
</ol>
<p>
Simply add the following code after the "addExectuable" function
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">zap</span> = b.dependency(<span style="color: #e9b96e;">"zap"</span>, .{
        .target = target,
        .optimize = optimize,
});
exe.addModule(<span style="color: #e9b96e;">"zap"</span>, zap.module(<span style="color: #e9b96e;">"zap"</span>));
exe.linkLibrary(zap.artifact(<span style="color: #e9b96e;">"facil.io"</span>));
</pre>
</div>
<p>
Note: here it is specific to the zap package, you might have different options and no need to link a library for an other package (zap uses facil.io under the hood)
</p>

<ol class="org-ol">
<li>Simply "@import" them and use them in your code :)</li>
</ol>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">zap</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"zap"</span>);
</pre>
</div>

<p>
Your packages will be downloaded and compiled when you build your project.
</p>
</div>
</div>

<div id="outline-container-org3931586" class="outline-4">
<h4 id="org3931586"><span class="section-number-4">5.1.2.</span> Sources</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
<a href="https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e">https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e</a>
<a href="https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3">https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3</a>
<a href="https://ziglang.org/download/0.11.0/release-notes.html#Package-Management">https://ziglang.org/download/0.11.0/release-notes.html#Package-Management</a>
<a href="https://ziggit.dev/t/how-to-package-a-zig-source-module-and-how-to-use-it/3457">https://ziggit.dev/t/how-to-package-a-zig-source-module-and-how-to-use-it/3457</a>
<a href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md">https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md</a>
<a href="https://ziglang.org/download/0.11.0/release-notes.html#Package-Management">https://ziglang.org/download/0.11.0/release-notes.html#Package-Management</a>
<a href="https://github.com/zigzap/zap">https://github.com/zigzap/zap</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org4befd80" class="outline-3">
<h3 id="org4befd80"><span class="section-number-3">5.2.</span> <span class="todo TODO">TODO</span> Comptime</h3>
</div>

<div id="outline-container-orgeb47c8e" class="outline-3">
<h3 id="orgeb47c8e"><span class="section-number-3">5.3.</span> <span class="todo TODO">TODO</span> How to use the build system</h3>
</div>

<div id="outline-container-orgf079041" class="outline-3">
<h3 id="orgf079041"><span class="section-number-3">5.4.</span> Build modes</h3>
<div class="outline-text-3" id="text-5-4">
<p>
Zig build modes are way easier for beginners to graps compared to <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">C</a>
</p>

<p>
There are only 4 different build modes:
</p>
<ul class="org-ul">
<li>Debug (default)</li>
<li>ReleaseFast</li>
<li>ReleaseSafe</li>
<li>ReleaseSmall</li>
</ul>

<p>
You can check them in more details <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a>
</p>

<p>
There are also a few other options you can tweak like avx <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a>
</p>
</div>

<div id="outline-container-org712aa2d" class="outline-4">
<h4 id="org712aa2d"><span class="section-number-4">5.4.1.</span> <span class="todo TODO">TODO</span> Build steps</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
<a href="https://zig.guide/build-system/build-steps">https://zig.guide/build-system/build-steps</a>
</p>
</div>
</div>

<div id="outline-container-org19356b5" class="outline-4">
<h4 id="org19356b5"><span class="section-number-4">5.4.2.</span> <span class="todo TODO">TODO</span> Generate automatically documentation</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
In Zig there is an experimental feature, it's automatically generated documentation.
It will scan all the public structures and functions and will create documentation.
Moreover, the comments like <code>///</code> are used to give more information to types.
</p>

<p>
This example is created with the help of the <code>build.zig</code> of the Zig language GitHub repository.
This is used the same way as the Zig teams auto-generate the standard library documentation. See: <a href="https://github.com/ziglang/zig/blob/master/build.zig">build.zig</a>
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">build</span>(<span style="color: #fcaf3e;">b</span>: *<span style="color: #8cc4ff;">std</span>.Build) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">autodoc_test</span> = b.addTest(.{
         .root_source_file = .{ .path = <span style="color: #e9b96e;">"src/main.zig"</span> },
     });
     <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">install_std_docs</span> = b.addInstallDirectory(.{
         .source_dir = autodoc_test.getEmittedDocs(),
         .install_dir = .prefix,
         .install_subdir = <span style="color: #e9b96e;">"doc"</span>,
     });

     <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">doc_step</span> = b.step(<span style="color: #e9b96e;">"docs"</span>, <span style="color: #e9b96e;">"Generate documentation"</span>);
     doc_step.dependOn(&amp;install_std_docs.step);
     doc_step.makeFn = generateDocumentation;
 }

 <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">generateDocumentation</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">std</span>.build.Step, <span style="color: #fcaf3e;">progress</span>: *<span style="color: #8cc4ff;">std</span>.Progress.Node) !<span style="color: #8cc4ff;">void</span> {
     _ = self;
     _ = progress;
     std.log.info(<span style="color: #e9b96e;">"The documentation has been generated"</span>, .{});
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-org65b97d4" class="outline-4">
<h4 id="org65b97d4"><span class="section-number-4">5.4.3.</span> Strip output binary in Zig in Linux</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">ELF format</a>
In an <code>ELF</code> executable there are various sections that hold program and control information.
For example:
</p>
<ul class="org-ul">
<li><code>.bss</code>: it holds uninitialized variables and data.</li>
<li><code>.text</code>: it holds the instruction of the program</li>
<li><code>.debug</code>: it holds unspecified information for debugging</li>
</ul>

<p>
Removing the debug symbols will reduce his size, make it harder to reverse engineering, and improve speed performance.
</p>

<p>
By default, Zig will produce an executable that has all the debug symbols.
However, Zig has reproduced a drop-in replacement for the program GNU <code>objcopy</code>.
</p>

<p>
To strip an output in the zig command line :
</p>
<div class="org-src-container">
<pre class="src src-sh">zig build-exe -fstrip src/main.zig
</pre>
</div>

<p>
To be sure that the output executable is stripped, the command <code>file</code> can be useful :
</p>
<div class="org-src-container">
<pre class="src src-sh">file main
</pre>
</div>
<p>
And the output : 
</p>
<pre class="example">
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
</pre>

<p>
With the Zig build system (<code>build.zig</code>) there is an option to strip an executable :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">target</span> = b.standardTargetOptions(.{});
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">optimize</span> = b.standardOptimizeOption(.{});

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">exe</span> = b.addExecutable(.{
    .name = <span style="color: #e9b96e;">"linkedlist"</span>,
    .root_source_file = .{ .path = <span style="color: #e9b96e;">"src/main.zig"</span> },
    .target = target,
    .optimize = optimize,
});

exe.strip = <span style="color: #e9b2e3;">true</span>;
</pre>
</div>

<p>
If the option strip is set to false, we have :
</p>
<pre class="example">
$file linkedlist
linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</pre>

<p>
And with the option to <code>true</code> :
</p>
<pre class="example">
$file linkedlist
linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
</pre>
</div>
</div>

<div id="outline-container-org8a61df4" class="outline-4">
<h4 id="org8a61df4"><span class="section-number-4">5.4.4.</span> Separate debug symbols from ELF executable</h4>
<div class="outline-text-4" id="text-5-4-4">
<p>
The chapter above shows how to remove all the symbols for the executable directly in the Zig build system.
In this section, the interest is more about the Zig objcopy command.
In fact, Zig has implemented his own <code>objcopy</code> utils to strip, and remove symbols like the objcopy from the bin utils (GNU utils).
(<i>Note: for now, the Zig objcopy has fewer features</i>)
</p>

<p>
The interest in having objcopy directly in Zig is there is no need to have multiple objcopy executables.
Indeed, in a cross-compilation world, each binutil needs to be compatible with the CPU architecture target.
So, it avoids using different toolchains and scripts to build on various targets.
</p>

<p>
Here's how to invoke the help of the Zig build objcopy:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --help
</pre>
</div>

<p>
The following example illustrates several applications of the objcopy command.
First, remove the debug symbols of the executable.
After that, keep only the debug symbols in a separate file.
And finally, how to link the debug symbols file to an executable (that has no debug file).
</p>

<p>
For this example, the output executable of the Zig build toolchain is named <code>main</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh">$<span style="color: #fcaf3e;">file</span> main
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</pre>
</div>

<p>
The first step is to strip the debug file from the executable:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --strip-debug main mainStripped
</pre>
</div>

<p>
The small flag alternative can also be used:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy -g main mainNoDebugInfo
</pre>
</div>

<p>
After this command, the new executable has no longer the debug info.
</p>
<div class="org-src-container">
<pre class="src src-sh">$<span style="color: #fcaf3e;">file</span> mainNoDebugInfo
mainNoDebugInfo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
</pre>
</div>

<p>
The second step shows how to keep only the debug symbols in the <code>main.dbg</code> file:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --only-keep-debug main main.dbg
</pre>
</div>

<p>
Finally, to recreate an executable with a link to a debug symbols file, the following command can be used:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --add-gnu-debuglink=main.dbg mainNoDebugInfo mainWithDbgSymbols
</pre>
</div>

<p>
Now, the executable named <code>mainWithDbgSymbols</code> can be used, for example in GDB to debug it (GDB will know where its debug symbols file is located).
</p>

<p>
Removing the debug symbol will create a smaller executable.
Bellow shows the process with a mini-example:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">executable name</th>
<th scope="col" class="org-left">size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">main</td>
<td class="org-left">1.9M</td>
</tr>

<tr>
<td class="org-left">main.dbg</td>
<td class="org-left">1.2M</td>
</tr>

<tr>
<td class="org-left">mainNoDebugInfo</td>
<td class="org-left">690K</td>
</tr>

<tr>
<td class="org-left">mainWithDbgSymbols</td>
<td class="org-left">690K</td>
</tr>
</tbody>
</table>

<p>
The advantage of this method is that the executable can be sent to production without debug symbols (it's more difficult to reverse engineering the exe, and it has a smaller size).
But when a bug is reported, it is always possible to debug it because all you have to do is link the debug symbol to the executable.
</p>
</div>
</div>
</div>

<div id="outline-container-org6ceb9df" class="outline-3">
<h3 id="org6ceb9df"><span class="section-number-3">5.5.</span> Cross-compilation</h3>
<div class="outline-text-3" id="text-5-5">
</div>
<div id="outline-container-org08e5dab" class="outline-4">
<h4 id="org08e5dab"><span class="section-number-4">5.5.1.</span> <span class="todo TODO">TODO</span> Cross-compile with an embedded linux</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
TODO: Add iterate programming to cross compile automaticlly the app
</p>

<p>
The <code>-target</code> flag of <code>zig build-exe</code> can select the target architecture for the cross-compilation.
There are multiple target selections, see <a href="#citeproc_bib_item_3">[3]</a> to have the entire list of targets.
</p>

<p>
Here's an example of a test that was performed, the aim being to run an executable produced by Zig (from a <code>x86_64</code>) for a -nanopi neo plus 2- which has an arm64 architecture and runs a Linux kernel.
The information of the embedded target :
</p>
<div class="org-src-container">
<pre class="src src-sh">uname -a
Linux csel 5.15.148 <span style="color: #73d216;">#</span><span style="color: #73d216;">2 SMP PREEMPT Mon Mar 4 21:21:00 UTC 2024 aarch64 GNU/Linux</span>
</pre>
</div>

<p>
Here's the command to cross-compile the executable (the executable is also stripped to have a smaller size):
</p>
<div class="org-src-container">
<pre class="src src-sh">zig build-exe src/main.zig -target aarch64-linux -fstrip
</pre>
</div>

<p>
The executable on the embedded target runs flawlessly, below is shown the output of the target:
</p>
<pre class="example" id="org1b78fcf">
# ./main
All your codebase are belong to us.
Run `zig build test` to run the tests.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd4e6d23" class="outline-2">
<h2 id="orgd4e6d23"><span class="section-number-2">6.</span> Allocator</h2>
<div class="outline-text-2" id="text-6">
<p>
The Zig language doesn't hide the memory management, the mantra of Zig is to have no hidden control flow.
Like the C language, Zig has manual memory management however, Zig will offer the programmer different allocators that allow him to handle exactly how to use his memory.
That's why Zig doesn't have a runtime and it can be used without the <code>libc</code> runtime.
</p>

<p>
Different allocators will be presented in the next sections.
</p>

<p>
This part is documented thanks to various resources:
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/0.11.0/#Memory">Zig documentation - Memory</a></li>
<li><a href="https://zig.guide/standard-library/allocators/">Zig guide about allocator</a></li>
<li><a href="https://www.openmymind.net/learning_zig/heap_memory/">openmymind - learning zig - heap memory</a></li>
<li>The Zig's standard library code</li>
</ul>
</div>

<div id="outline-container-org55b4f94" class="outline-3">
<h3 id="org55b4f94"><span class="section-number-3">6.1.</span> General pattern</h3>
<div class="outline-text-3" id="text-6-1">
<p>
TODO selon le prof il faudrait "prouver" ou "sourcer" cette affirmation comme quoi cest une good practice mais je ne sais pas trop quoi dire:
</p>

<p>
"In Zig for library development, a good practice is to pass an allocator as a parameter, so the programmer can choose the best allocator for his use case."
</p>

<p>
In the Zig standard library, this pattern is used a lot.
</p>

<p>
For example, the <code>ArrayList</code> of the standard library uses this pattern :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(gpa.allocator());
<span style="color: #b4fa70;">defer</span> list.deinit();

<span style="color: #b4fa70;">try</span> list.append(42);

<span style="color: #b4fa70;">for</span> (list.items) |value| {
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Output:  {d}"</span>, .{value});
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgc30d3bc" class="outline-3">
<h3 id="orgc30d3bc"><span class="section-number-3">6.2.</span> Page allocator (<code>page_allocator</code>)</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The page allocator is the basic allocator that will directly ask the OS for memory. 
This is not the most efficient allocator because it will request memory pages from the OS via systems calls.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.heap.page_allocator;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">memory</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 42);
<span style="color: #b4fa70;">defer</span> allocator.free(memory);

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Len of the memory: {}\n"</span>, .{memory.len});

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct); 
<span style="color: #b4fa70;">defer</span> allocator.destroy(myStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});

</pre>
</div>
</div>
</div>

<div id="outline-container-org20dc3da" class="outline-3">
<h3 id="org20dc3da"><span class="section-number-3">6.3.</span> Fixed buffer allocator</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The <code>FixedBufferAllocator</code> will allocate memory into a fixed buffer, the size of the buffer needs to be known at comptime.
The benefit of this allocator is that it will not make heap allocation. It's very useful for embedded systems and kernel development.
This allocator is very performant and it will give an error if the allocator runs out of memory, with an <code>OutOfMemory</code> error.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [100]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">fixedBuffAlloc</span> = std.heap.FixedBufferAllocator.init(&amp;buffer);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = fixedBuffAlloc.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">memory</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 50);
<span style="color: #b4fa70;">defer</span> allocator.free(memory);

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Len of the memory: {}\n"</span>, .{memory.len});

<span style="color: #73d216;">// </span><span style="color: #73d216;">Example of OutOfMemory error</span>
_ = allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 51) <span style="color: #b4fa70;">catch</span> |err| {
  <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"There is an error: {}\n"</span>, .{err});
};

</pre>
</div>

<p>
Moreover, there is also a thread-safe fixed buffer allocator for thread-safety use case: <code>std.heap.ThreadSafeFixedBufferAllocator</code>.
</p>
</div>
</div>

<div id="outline-container-orgadc6104" class="outline-3">
<h3 id="orgadc6104"><span class="section-number-3">6.4.</span> Arena allocator</h3>
<div class="outline-text-3" id="text-6-4">
<p>
The arena allocator takes a child allocator as input. This pattern is used to allocate multiple pieces of memory and free them at once.
There is no need in the arena allocator to free memory manually, it's the function <code>deinit</code> that is responsible for freeing <b>all</b> the allocated memory by this allocator.
</p>

<p>
The Zig documentation recommends this pattern when an application runs from start to end without a cyclic pattern.
For example: command line application.
</p>

<p>
Here's an example of how to use the arena allocator.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">page_allocator</span> = std.heap.page_allocator;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arena</span> = std.heap.ArenaAllocator.init(page_allocator);
<span style="color: #b4fa70;">defer</span> arena.deinit();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = arena.allocator();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});
<span style="color: #73d216;">// </span><span style="color: #73d216;">No need to manual free myStuct</span>

</pre>
</div>
</div>

<div id="outline-container-org8f47dbd" class="outline-4">
<h4 id="org8f47dbd"><span class="section-number-4">6.4.1.</span> Internal working of arena allocator</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
<a href="https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works">Zig how arena allocator works</a>
Internally, the arena allocator uses a linked list to keep track of the created buffers.
</p>

<p>
The example below shows a code snippet of the arena allocation (from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/arena_allocator.zig">arena<sub>allocator.zig</sub></a>).
The internals of the arena allocator are the child allocator and a state that contains a singly linked list of buffers.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ArenaAllocator</span> = <span style="color: #b4fa70;">struct</span> {
  <span style="color: #fcaf3e;">child_allocator</span>: <span style="color: #8cc4ff;">Allocator</span>,
  <span style="color: #fcaf3e;">state</span>: <span style="color: #8cc4ff;">State</span>,

  <span style="color: #e9b96e;">/// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator</span>
  <span style="color: #e9b96e;">/// as a memory-saving optimization.</span>
  <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">State</span> = <span style="color: #b4fa70;">struct</span> {
      <span style="color: #fcaf3e;">buffer_list</span>: <span style="color: #8cc4ff;">std</span>.SinglyLinkedList(<span style="color: #8cc4ff;">usize</span>) = .{},
      <span style="color: #fcaf3e;">end_index</span>: <span style="color: #8cc4ff;">usize</span> = 0,

      <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">promote</span>(<span style="color: #fcaf3e;">self</span>: <span style="color: #8cc4ff;">State</span>, <span style="color: #fcaf3e;">child_allocator</span>: <span style="color: #8cc4ff;">Allocator</span>) ArenaAllocator {
          <span style="color: #b4fa70;">return</span> .{
              .child_allocator = child_allocator,
              .state = self,
          };
      }
  };
  <span style="color: #e9b96e;">/// ...</span>
};
</pre>
</div>

<p>
The <code>deinit</code> function of the arena allocator will free all the buffers by iterating over each node and calling the <code>rawFree</code> from the child allocator.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/arena_allocator.zig">arena<sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig">  <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: <span style="color: #8cc4ff;">ArenaAllocator</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">NOTE: When changing this, make sure `reset()` is adjusted accordingly!</span>

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">it</span> = self.state.buffer_list.first;
    <span style="color: #b4fa70;">while</span> (it) |node| {
        <span style="color: #73d216;">// </span><span style="color: #73d216;">this has to occur before the free because the free frees node</span>
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">next_it</span> = node.next;
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">align_bits</span> = std.math.log2_int(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@alignOf</span>(BufNode));
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">alloc_buf</span> = <span style="color: #e090d7;">@as</span>([*]<span style="color: #8cc4ff;">u8</span>, <span style="color: #e090d7;">@ptrCast</span>(node))[0..node.data];
        self.child_allocator.rawFree(alloc_buf, align_bits, <span style="color: #e090d7;">@returnAddress</span>());
        it = next_it;
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd337121" class="outline-3">
<h3 id="orgd337121"><span class="section-number-3">6.5.</span> General purpose allocator</h3>
<div class="outline-text-3" id="text-6-5">
<p>
A general purpose allocator is available in Zig, this is a safe allocator that can prevent double free memory, "use after free" and detect memory leaks.
The general purpose allocator is safety first design, but it's still faster than the page allocator (<a href="https://zig.guide/standard-library/allocators/">Zig guide allocator</a>)
</p>

<p>
The general purpose allocator is a function that takes as argument a comptime configuration struct and return a type.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/general_purpose_allocator.zig">general<sub>purpose</sub><sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">GeneralPurposeAllocator</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #e9b96e;">/// Implementation ....</span>
    };
}
</pre>
</div>

<p>
The configuration struct of the general purpose allocator shown below, has different options, like thread safety, memory limit, and debug utils.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/general_purpose_allocator.zig">general<sub>purpose</sub><sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #e9b96e;">/// Number of stack frames to capture.</span>
    <span style="color: #fcaf3e;">stack_trace_frames</span>: <span style="color: #8cc4ff;">usize</span> = default_stack_trace_frames,

    <span style="color: #e9b96e;">/// If true, the allocator will have two fields:</span>
    <span style="color: #e9b96e;">///  * `total_requested_bytes` which tracks the total allocated bytes of memory requested.</span>
    <span style="color: #e9b96e;">///  * `requested_memory_limit` which causes allocations to return `error.OutOfMemory`</span>
    <span style="color: #e9b96e;">///    when the `total_requested_bytes` exceeds this limit.</span>
    <span style="color: #e9b96e;">/// If false, these fields will be `void`.</span>
    <span style="color: #fcaf3e;">enable_memory_limit</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// Whether to enable safety checks.</span>
    <span style="color: #fcaf3e;">safety</span>: <span style="color: #8cc4ff;">bool</span> = std.debug.runtime_safety,

    <span style="color: #e9b96e;">/// Whether the allocator may be used simultaneously from multiple threads.</span>
    <span style="color: #fcaf3e;">thread_safe</span>: <span style="color: #8cc4ff;">bool</span> = !builtin.single_threaded,

    <span style="color: #e9b96e;">/// What type of mutex you'd like to use, for thread safety.</span>
    <span style="color: #e9b96e;">/// when specified, the mutex type must have the same shape as `std.Thread.Mutex` and</span>
    <span style="color: #e9b96e;">/// `DummyMutex`, and have no required fields. Specifying this field causes</span>
    <span style="color: #e9b96e;">/// the `thread_safe` field to be ignored.</span>
    <span style="color: #e9b96e;">///</span>
    <span style="color: #e9b96e;">/// when null (default):</span>
    <span style="color: #e9b96e;">/// * the mutex type defaults to `std.Thread.Mutex` when thread_safe is enabled.</span>
    <span style="color: #e9b96e;">/// * the mutex type defaults to `DummyMutex` otherwise.</span>
    <span style="color: #fcaf3e;">MutexType</span>: ?<span style="color: #8cc4ff;">type</span> = <span style="color: #e9b2e3;">null</span>,

    <span style="color: #e9b96e;">/// This is a temporary debugging trick you can use to turn segfaults into more helpful</span>
    <span style="color: #e9b96e;">/// logged error messages with stack trace details. The downside is that every allocation</span>
    <span style="color: #e9b96e;">/// will be leaked, unless used with retain_metadata!</span>
    <span style="color: #fcaf3e;">never_unmap</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// This is a temporary debugging aid that retains metadata about allocations indefinitely.</span>
    <span style="color: #e9b96e;">/// This allows a greater range of double frees to be reported. All metadata is freed when</span>
    <span style="color: #e9b96e;">/// deinit is called. When used with never_unmap, deliberately leaked memory is also freed</span>
    <span style="color: #e9b96e;">/// during deinit. Currently should be used with never_unmap to avoid segfaults.</span>
    <span style="color: #e9b96e;">/// TODO https://github.com/ziglang/zig/issues/4298 will allow use without never_unmap</span>
    <span style="color: #fcaf3e;">retain_metadata</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// Enables emitting info messages with the size and address of every allocation.</span>
    <span style="color: #fcaf3e;">verbose_log</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,
};
</pre>
</div>

<p>
The example below shows a basic usage of the Zig's GPA:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Returns `Check.leak` if there were leaks; `Check.ok` otherwise.</span>
<span style="color: #b4fa70;">defer</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">checkStatus</span> = gpa.deinit();
    <span style="color: #b4fa70;">if</span> (checkStatus == std.heap.Check.leak) {
        std.log.err(<span style="color: #e9b96e;">"Leaks detected !!!"</span>, .{});
    }
}

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct);
<span style="color: #b4fa70;">defer</span> allocator.destroy(myStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});

</pre>
</div>
</div>
</div>


<div id="outline-container-orgd4ce63c" class="outline-3">
<h3 id="orgd4ce63c"><span class="section-number-3">6.6.</span> Testing allocator</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The testing allocator is available in tests and the test runner will report all the memory leaks that have occurred during testing.<a href="#citeproc_bib_item_4">[4]</a> <a href="#citeproc_bib_item_5">[5]</a>
</p>

<p>
The example below shows how to use the testing allocator.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Test ArrayList"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">array</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> array.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span>: <span style="color: #8cc4ff;">i32</span> = 42;
    <span style="color: #b4fa70;">try</span> array.append(expected);

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(expected, array.items[0]);
}
</pre>
</div>

<p>
If the code below is run, the test will fail and it will display a leaked test memory.
Zig will help the programmer to detect memory leaks using code tests.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Test ArrayList"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">array</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(std.testing.allocator);
    <span style="color: #73d216;">//</span><span style="color: #73d216;">defer array.deinit(); -&gt; the array will not be free</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span>: <span style="color: #8cc4ff;">i32</span> = 42;
    <span style="color: #b4fa70;">try</span> array.append(expected);

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(expected, array.items[0]);
}
</pre>
</div>

<p>
Under the hood, the testing allocator is an instance of the general purpose allocator.
Below, an extract of testing allocator of the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/testing.zig">testing.zig</a>.
If the testing allocator is used outside of the tests, a compilation error will be thrown.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #e9b96e;">/// This should only be used in temporary test programs.</span>
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = allocator_instance.allocator();
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">allocator_instance</span> = b: {
    <span style="color: #b4fa70;">if</span> (!builtin.is_test)
        <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Cannot use testing allocator outside of test block"</span>);
    <span style="color: #b4fa70;">break</span> :<span style="color: #8cc4ff;">b</span> std.heap.GeneralPurposeAllocator(.{}){};
};
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdd261b3" class="outline-3">
<h3 id="orgdd261b3"><span class="section-number-3">6.7.</span> <span class="todo TODO">TODO</span> Failing allocator</h3>
<div class="outline-text-3" id="text-6-7">
<p>
The failing allocator can be used to ensure that the <code>error.OutOfMemory</code> is well handled.
</p>

<p>
The failling allocator need to have a child allocator to run.
In fact, the failing allocator can set in his <code>init</code> function the number of allocation that will be performed without errors (see the <code>numberOfAllocation</code> variable).
This pattern is pretty useful in restricted memory environments such as embedded development.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"test alloc falling"</span> {
  <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">numberOfAllocation</span> = 0;
  <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">failingAlloc</span> = std.testing.FailingAllocator.init(std.testing.allocator, numberOfAllocation);
  <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(failingAlloc.allocator());
  <span style="color: #b4fa70;">defer</span> list.deinit();

  <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 45;

  <span style="color: #b4fa70;">try</span> std.testing.expectError(std.mem.Allocator.Error.OutOfMemory, list.append(expected));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgec6dd94" class="outline-3">
<h3 id="orgec6dd94"><span class="section-number-3">6.8.</span> <span class="todo TODO">TODO</span> C allocator</h3>
<div class="outline-text-3" id="text-6-8">
<p>
The <code>C</code> standard allocator can also be used, this allocator has high performance but it has less safety feature.
</p>
</div>
</div>

<div id="outline-container-orgb817ccb" class="outline-3">
<h3 id="orgb817ccb"><span class="section-number-3">6.9.</span> <span class="todo TODO">TODO</span> implementing your own allocator</h3>
<div class="outline-text-3" id="text-6-9">
<p>
However, to use this allocator, the <code>libC</code> is required.
Adding the <code>libC</code> in the project will add more dependencies.
</p>
</div>
</div>

<div id="outline-container-org2ffb022" class="outline-3">
<h3 id="org2ffb022"><span class="section-number-3">6.10.</span> <span class="todo TODO">TODO</span> How to use Zig to detect memory leaks</h3>
<div class="outline-text-3" id="text-6-10">
</div>
<div id="outline-container-org61b484a" class="outline-4">
<h4 id="org61b484a"><span class="section-number-4">6.10.1.</span> <span class="todo TODO">TODO</span> Comparison between gcc-utils sanitizer, Valgrind, and Zig memory leak detection</h4>
</div>
</div>

<div id="outline-container-org2a23b62" class="outline-3">
<h3 id="org2a23b62"><span class="section-number-3">6.11.</span> <span class="todo TODO">TODO</span> ?</h3>
<div class="outline-text-3" id="text-6-11">
<p>
TODO talk about how malloc and calloc work in C with the on demand memory allocation (page fault each time with need more memory) is there a similar system in zig ? can we choose to have on demand memory or can we all allocate at once ?
</p>
</div>
</div>

<div id="outline-container-orgf660e16" class="outline-3">
<h3 id="orgf660e16"><span class="section-number-3">6.12.</span> Conclusion</h3>
<div class="outline-text-3" id="text-6-12">
<p>
TODO selon le prof cest bien de faire une conclusion et introduction sur la plupart des concepts abordés
</p>
</div>
</div>
</div>

<div id="outline-container-orga8c47f5" class="outline-2">
<h2 id="orga8c47f5"><span class="section-number-2">7.</span> Comptime</h2>
<div class="outline-text-2" id="text-7">
<p>
Zig has a concept called <code>comptime</code>, it's stands for "compile-time".
Comptime is used to evaluate an expression at compile time and not at runtime.
In comparison with C, Zig comptime has the purpose of replacing marco with a more explicit syntax.
In fact, C's macro tends to be error-prone when using it.
The advantage of using comptime over macro is the type safety of Zig when writing comptime.
</p>
</div>

<div id="outline-container-org231c379" class="outline-3">
<h3 id="org231c379"><span class="section-number-3">7.1.</span> When to use and when NOT to use it</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-orged446ad" class="outline-4">
<h4 id="orged446ad"><span class="section-number-4">7.1.1.</span> When to use it</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
Because the compiler can now do things at compilation time, leaving less work to be done at runtime. (if the compiler gives you the power to do things at compile time so easily, you should use it ^^)
</p>

<p>
So you should basically try to use it as much as you can.
</p>
</div>
</div>

<div id="outline-container-orgadf217d" class="outline-4">
<h4 id="orgadf217d"><span class="section-number-4">7.1.2.</span> When NOT to use it (source: ziglings)</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
The following contexts are already IMPLICITLY evaluated at
compile time, and adding the 'comptime' keyword would be
superfluous, redundant, and smelly:
</p>

<ul class="org-ul">
<li>The container-level scope (outside of any function in a source file)</li>
<li>Type declarations of:
<ul class="org-ul">
<li>Variables</li>
<li>Functions (types of parameters and return values)</li>
<li>Structs</li>
<li>Unions</li>
<li>Enums</li>
</ul></li>
<li>The test expressions in inline for and while loops</li>
<li>An expression passed to the @cImport() builtin</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org9ea0827" class="outline-3">
<h3 id="org9ea0827"><span class="section-number-3">7.2.</span> Compile-time evaluation</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-orgedcb2e7" class="outline-4">
<h4 id="orgedcb2e7"><span class="section-number-4">7.2.1.</span> Compile-time variable</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
In Zig, there are variables that can be evaluated at compile-time, in fact, Zig allows computing mutating variables at compile-time but all the inputs need to be known also at compile-time.
If not, the compiler will throw a compile error. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
For a mutating variable at compile-time, Zig requires naming the variables with a <code>comptime var</code>.
But if the variable is a constant, the compiler requires to use a <code>const</code>. 
</p>

<p>
Like in the example below, the variable named <code>variableAtCompileTime</code> is evaluated at compile-time because all the inputs are known.
On the other hand, the variable named <code>constantAtRuntime</code> cannot be a comptime variable because its dependency is based on unknown before runtime.
</p>

<p>
Moreover, in the example, the <code>inline for</code> is used to unroll the for loop.
This allows to use for loops in comptime indeed, if a standard for loop is used, it will cause an error because the capture value will be evaluated at runtime.<a href="#citeproc_bib_item_1">[1]</a> 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">randVariable</span> = std.crypto.random.float(<span style="color: #8cc4ff;">f32</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">selectedConstant</span> = 6;

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">constantAtRuntime</span> = randVariable * selectedConstant;

<span style="color: #b4fa70;">comptime</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">variableAtCompileTime</span> = selectedConstant * selectedConstant;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">array</span> = [_]<span style="color: #8cc4ff;">comptime_int</span> { 3, 2, 1};

<span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (array) |item| {
    variableAtCompileTime += item;
}

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"constant-at-runtime {d:.2}\n"</span>, .{constantAtRuntime});
<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"variable-at-compile-time  {d}"</span>, .{variableAtCompileTime});

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">constant-at-runtime</td>
<td class="org-right">1.85</td>
</tr>

<tr>
<td class="org-left">variable-at-compile-time</td>
<td class="org-right">42</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org435dc26" class="outline-4">
<h4 id="org435dc26"><span class="section-number-4">7.2.2.</span> Compile-time expression</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
In Zig, an expression can have a <code>comptime</code> to tell the compiler to evaluate the expression at compile-time.
Like a compile-time variable, if an expression cannot be evaluated at compile-time, a compile-time error will be thrown.
</p>

<p>
With a prefixed <code>comptime</code> keyword Zig can interpret a function at compile-time instead of runtime. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
A good example of demonstrating comptime expression is in the standard documentation <a href="#citeproc_bib_item_1">[1]</a>.
The results show that the comptime expression is faster than the runtime one when the code is executed (runtime) because the work has already been done.
But this will work only with code that hasn't runtime dependency code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Timer</span> = std.time.Timer;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">fib</span>(<span style="color: #fcaf3e;">iteration</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">if</span> (iteration &lt; 2) <span style="color: #b4fa70;">return</span> iteration;

    <span style="color: #b4fa70;">return</span> fib(iteration - 1) + fib(iteration - 2);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"comptime fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">comptime</span> fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-comptime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(610, result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">result</span> = fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-runtime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expect(610 == result);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org423defa" class="outline-4">
<h4 id="org423defa"><span class="section-number-4">7.2.3.</span> Compile-time parameter</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
Zig implements generic by using duck typing at compile-time.
To use generic, Zig needs to know the type at compile-time.
</p>
<div class="org-src-container">
<pre class="src src-zig">
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">greater</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">array</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">T</span>) !?T {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">max</span>: ?<span style="color: #8cc4ff;">T</span> = <span style="color: #e9b2e3;">null</span>;
    <span style="color: #b4fa70;">for</span> (array) |item| {
        <span style="color: #b4fa70;">if</span> (max) |m| {
            <span style="color: #b4fa70;">if</span> (m &lt; item) {
                max = item;
            }
        } <span style="color: #b4fa70;">else</span> {
            max = item;
        }
    }
    <span style="color: #b4fa70;">return</span> max;
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an i32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intArray</span> = [_]<span style="color: #8cc4ff;">i32</span>{ 2, 9, 4, 6, 7, 1};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">i32</span>, &amp;intArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 9);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an f32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">floatArray</span> = [_]<span style="color: #8cc4ff;">f32</span>{ 2.34, 14.55, 4.12, 6.876, 7.111 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">f32</span>, &amp;floatArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 14.55);
}


</pre>
</div>

<p>
But with duck typing, if the same method is used, an error will be thrown at compile time:
</p>
<div class="org-src-container">
<pre class="src src-Zig">test "should fail with bool" {
    const boolArray = [_]bool{ true, false, true, true };
    const result = greater(bool, &amp;boolArray);
}
</pre>
</div>

<p>
The error will be:
</p>
<pre class="example" id="orged9908e">
error: operator &lt; not allowed for type 'bool'
</pre>

<p>
Moreover, comptime can also be used as a type definition.
For this, the function needs to return a <code>type</code>.
The example below is based on <a href="https://zig.guide/language-basics/comptime">the zig guide</a> <a href="#citeproc_bib_item_2">[2]</a>, it's shows that it can define a new type with a function.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">width</span>: <span style="color: #8cc4ff;">comptime_int</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">height</span>: <span style="color: #8cc4ff;">comptime_int</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> [height][width]T;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix3x3</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> Matrix(T, 3, 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a type"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix(<span style="color: #8cc4ff;">f32</span>, 4, 4) == [4][4]<span style="color: #8cc4ff;">f32</span>);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a 3x3 matrix"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix3x3(<span style="color: #8cc4ff;">f32</span>) == [3][3]<span style="color: #8cc4ff;">f32</span>);
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3fd7f54" class="outline-3">
<h3 id="org3fd7f54"><span class="section-number-3">7.3.</span> Metaprogramming</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org36de831" class="outline-4">
<h4 id="org36de831"><span class="section-number-4">7.3.1.</span> <code>@TypeOf</code></h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
The <code>@TypeOf</code> builtin function can be used to take as a parameter an expression and return a type.
</p>
</div>
</div>

<div id="outline-container-org7aae3aa" class="outline-4">
<h4 id="org7aae3aa"><span class="section-number-4">7.3.2.</span> <code>@typeInfo</code></h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
This built-in function provides type reflection, it returns information on type.
</p>

<p>
See the example <code>Example with a custom CSV writer based on type</code> to have a view of the usability.
</p>
</div>
</div>
</div>

<div id="outline-container-org9609f79" class="outline-3">
<h3 id="org9609f79"><span class="section-number-3">7.4.</span> <span class="todo TODO">TODO</span> Optimization</h3>
<div class="outline-text-3" id="text-7-4">
<p>
inline for / while
</p>
</div>

<div id="outline-container-orge094852" class="outline-4">
<h4 id="orge094852"><span class="section-number-4">7.4.1.</span> How log works in Zig</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
In the C language, a common use to use debug print is with Marco.
Like in this example, if the <code>DEBUG</code> is defined to <code>1</code> the code will print the debug info.
If the <code>DEBUG</code> is not set, at the compilation, all the print information will be removed.
</p>
<div class="org-src-container">
<pre class="src src-C">
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">DEBUG</span> 1

<span style="color: #e090d7;">#if</span> DEBUG 
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>) <span style="color: #8cc4ff;">printf</span> <span style="color: #fcaf3e;">x</span>;
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>)
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  TRACE((<span style="color: #e9b96e;">"Hello World! : %d\n"</span>, 12));
}
</pre>
</div>

<p>
In Zig, logging uses this same principle, a message level is set at the start of the program (at compile-time) and if the log is not enabled, all the code about the print is removed.
However, if the log level is greater than the limit, the message will be printed.
</p>

<p>
The code below shows an extract of the standard library for logging.
</p>
<div class="org-src-container">
<pre class="src src-zig"> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">log</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">message_level</span>: <span style="color: #8cc4ff;">Level</span>,
    <span style="color: #b4fa70;">comptime</span> scope: <span style="color: #e090d7;">@Type</span>(.EnumLiteral),
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">format</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">args</span>: <span style="color: #8cc4ff;">anytype</span>,
) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">comptime</span> !logEnabled(message_level, scope)) <span style="color: #b4fa70;">return</span>;

    std.options.logFn(message_level, scope, format, args);
}
</pre>
</div>

<p>
In addition, Zig provides some helper functions for logging, such as :
</p>
<ul class="org-ul">
<li><code>std.log.debug</code></li>
<li><code>std.log.info</code></li>
<li><code>std.log.warn</code></li>
<li><code>std.log.err</code></li>
</ul>

<p>
And if the release mode is set to <code>Debug</code>, the debug log will be printed.
But if the release mode is set to <code>Release*</code>, the debug log will not print, there is no need to configure the logging to have this behavior.
</p>
</div>
</div>
</div>

<div id="outline-container-org525e3fa" class="outline-3">
<h3 id="org525e3fa"><span class="section-number-3">7.5.</span> Generic data structures</h3>
<div class="outline-text-3" id="text-7-5">
<p>
To create a generic data structure, the same pattern is used as a comptime parameter.
A function needs to return an anonymous struct as a type <code>type</code>.
</p>

<p>
In a generic data structure, the <code>@This()</code> is used to get the type of the data structure because it is anonymous.
</p>

<p>
Moreover, a generic data structure can have two type of function:
</p>
<ol class="org-ol">
<li>a function that can be called on the structure type</li>
<li>a function that can be called on the instance of the structure.</li>
</ol>

<p>
To have an instance function, the first argument needs to be a parameter of the type of the struct.
That's why a constant <code>Self</code> is used with <code>@This()</code>.
And after that, the parameter <code>self</code> can be used to get the members of the struct.
</p>

<p>
The example shows the difference between a function that can be called on a struct and a function that can be called on an instance of a struct.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">structFunction</span>(<span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structFunction\n"</span>, .{});
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">instanceFunction</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structInstance: {d}\n"</span>, .{self.myNumber});
        }
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

    <span style="color: #b4fa70;">try</span> MyStruct(<span style="color: #8cc4ff;">f32</span>).structFunction(stdout);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = MyStruct(<span style="color: #8cc4ff;">f32</span>){
        .myNumber = 42,
    };

    <span style="color: #b4fa70;">try</span> myStruct.instanceFunction(stdout);
}

</pre>
</div>

<p>
In Zig, a structure name can be explicitly given or Zig can infer the name of a struct when there are created:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure name is infered</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct1</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>) {
        .myNumber = 42,
    };
    _ = myStruct1;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure has a explicit name</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intStruct</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct2</span> =  intStruct {
        .myNumber = 42,
    };
    _ = myStruct2;
}
</pre>
</div>

<p>
Here's an compete example of an generic linked list :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">LinkedList</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Node</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">data</span>: <span style="color: #8cc4ff;">T</span>,
            <span style="color: #fcaf3e;">prev</span>: ?*<span style="color: #8cc4ff;">Node</span>,
            <span style="color: #fcaf3e;">next</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        };

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">LinkedListError</span> = <span style="color: #b4fa70;">error</span>{headNull};
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();
        <span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator,
        <span style="color: #fcaf3e;">head</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        <span style="color: #fcaf3e;">len</span>: <span style="color: #8cc4ff;">u32</span> = 0,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .head = <span style="color: #e9b2e3;">null</span>,
                .allocator = allocator,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>) <span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">curr</span> = self.head;

            <span style="color: #b4fa70;">while</span> (curr) |currNotNull| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">node</span> = currNotNull;
                curr = currNotNull.next;
                self.allocator.destroy(node);
            }
            self.len = 0;
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">push</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">node</span> = <span style="color: #b4fa70;">try</span> self.allocator.create(Node);
            node.*.data = value;
            self.len += 1;

            <span style="color: #b4fa70;">if</span> (self.head) |head| {
                node.next = head;
                head.prev = node;
                self.head = node;
            } <span style="color: #b4fa70;">else</span> {
                self.head = node;
                node.*.next = <span style="color: #e9b2e3;">null</span>;
                node.*.prev = <span style="color: #e9b2e3;">null</span>;
            }
        }
    };
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a i32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 42;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a f32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">f32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 3.1415;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd8fb10d" class="outline-3">
<h3 id="orgd8fb10d"><span class="section-number-3">7.6.</span> Example with a custom CSV writer based on type</h3>
<div class="outline-text-3" id="text-7-6">
<p>
This example shows that Zig has a type reflection with the keyword <code>@typeInfo</code>.
The goal of this example is to create CSV output with a generic struct as input.
Only with the <code>try csv.stringify(&amp;arrayList, stream.writer());</code> function the <code>CsvWriter</code> can infer at comptime the struct pass as argument.
For this example, a basic struct named <code>Person</code> will be transformed to CSV.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">CsvWriter</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">separator</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b96e;">','</span>,
        };
        <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .config = config,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">stringify</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">arrayList</span>: *<span style="color: #8cc4ff;">std</span>.ArrayList(T), <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writeHeader(self, &amp;writer);
            <span style="color: #b4fa70;">for</span> (arrayList.items) |item| {
                <span style="color: #b4fa70;">try</span> writeType(self, item, &amp;writer);
            }
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeHeader</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{field.name});
                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeType</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">item</span>: <span style="color: #8cc4ff;">T</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">if</span> (<span style="color: #e090d7;">@TypeOf</span>(fields) != []<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span>.builtin.Type.StructField)
                <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"The type is not the a struct"</span>);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span> = <span style="color: #e090d7;">@field</span>(item, field.name);

                <span style="color: #b4fa70;">switch</span> (<span style="color: #e090d7;">@typeInfo</span>(<span style="color: #e090d7;">@TypeOf</span>(f))) {
                    .Int =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Float =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Pointer =&gt; |pointer| {
                        <span style="color: #b4fa70;">if</span> (pointer.size == std.builtin.Type.Pointer.Size.Slice <span style="color: #b4fa70;">and</span> pointer.child == <span style="color: #8cc4ff;">u8</span>) {
                            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{f});
                        } <span style="color: #b4fa70;">else</span> {
                            <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>);
                        }
                    },
                    <span style="color: #b4fa70;">else</span> =&gt; <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>),
                }

                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }
    };
}

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Person</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">sexe</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">date</span>: <span style="color: #8cc4ff;">u32</span>,
};


<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person1</span> = .{ .sexe = <span style="color: #e9b96e;">"M"</span>, .name = <span style="color: #e9b96e;">"Lucas"</span>, .date = 2000 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person2</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Ava"</span>, .date = 2020 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person3</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Sophia"</span>, .date = 1989 };

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arrayList</span> = std.ArrayList(Person).init(gpa.allocator());
    <span style="color: #b4fa70;">defer</span> arrayList.deinit();

    <span style="color: #b4fa70;">try</span> arrayList.append(person1);
    <span style="color: #b4fa70;">try</span> arrayList.append(person2);
    <span style="color: #b4fa70;">try</span> arrayList.append(person3);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">stream</span> = std.io.fixedBufferStream(buffer[0..]);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">personCsvWriter</span> = CsvWriter(Person);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">csv</span> = personCsvWriter.init(.{ .separator = <span style="color: #e9b96e;">' '</span> });
    <span style="color: #b4fa70;">try</span> csv.stringify(&amp;arrayList, stream.writer());

    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"{s}"</span>, .{stream.getWritten()});

}

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sexe</td>
<td class="org-left">name</td>
<td class="org-right">date</td>
</tr>

<tr>
<td class="org-left">M</td>
<td class="org-left">Lucas</td>
<td class="org-right">2000</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Ava</td>
<td class="org-right">2020</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Sophia</td>
<td class="org-right">1989</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgd648a82" class="outline-3">
<h3 id="orgd648a82"><span class="section-number-3">7.7.</span> Bonus</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Here is a very nice blog written by a core member of the ZIG community if you want to dig further: <a href="https://kristoff.it/blog/what-is-zig-comptime/">https://kristoff.it/blog/what-is-zig-comptime/</a>
</p>

<p>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</p>
</div>
</div>
</div>
<div id="outline-container-orga3127bc" class="outline-2">
<h2 id="orga3127bc"><span class="section-number-2">8.</span> Zig and C</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-org19d981b" class="outline-3">
<h3 id="org19d981b"><span class="section-number-3">8.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-8-1">
<p>
The interoperability between Zig and C is one of the most important feature of Zig. But why ?
</p>

<p>
It is one of the main goal of Zig to <a href="https://ziglang.org/">incrementally improve your C/C++/Zig codebase</a>, so you could use C code almost as much as easy as you could use Zig code.
</p>

<p>
It allows to have both of a <b>modern</b> language and a <b>mature</b> ecosystem.
</p>
</div>
</div>

<div id="outline-container-org7064094" class="outline-3">
<h3 id="org7064094"><span class="section-number-3">8.2.</span> Main differences between Zig and C in the syntax</h3>
<div class="outline-text-3" id="text-8-2">
<p>
There are a few main differences between the 2 languages that you have high chance of encountering but obviously not all of them are listed here.
</p>
</div>

<div id="outline-container-org3822581" class="outline-4">
<h4 id="org3822581"><span class="section-number-4">8.2.1.</span> Types</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Here you can find all the primitive types in Zig and their C equivalent:
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Primitive-Types">https://ziglang.org/documentation/master/#Primitive-Types</a>
</p>

<p>
<a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a>
</p>

<p>
TODO would it be better if i do the array in the doc rather than having a link to it ?
</p>
</div>
</div>

<div id="outline-container-org37334b5" class="outline-4">
<h4 id="org37334b5"><span class="section-number-4">8.2.2.</span> Loops</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
In Zig, the for loop is not used as much as in C. 
Instead, the while loop is used more often. The for loop is used when iterating over multiples elements of a container (typically slices or arrays), so it basically is a kind of foreach loop. In all the other cases the while loop is used.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">items</span> = [_]<span style="color: #8cc4ff;">u16</span> { 1, 4, 0, 1 };
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">sum</span>: <span style="color: #8cc4ff;">u16</span> = 0;
<span style="color: #b4fa70;">for</span> (items) |value| {
    sum += value;
}
std.debug.print(<span style="color: #e9b96e;">"Sum: {}\n"</span>, .{sum});
</pre>
</div>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">for</span> (0..3) |i| {
    i += 1;
    std.debug.print(<span style="color: #e9b96e;">"i: {}\n"</span>, .{i});
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2f36c4a" class="outline-4">
<h4 id="org2f36c4a"><span class="section-number-4">8.2.3.</span> Pointers</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
Zig has 2 different pointers:
</p>
<ul class="org-ul">
<li>Single-item pointers: *T</li>
<li>Many-item pointers: [*]T</li>
</ul>
<p>
Which can both be optional by adding a "?".
</p>

<p>
But actually&#x2026;. there is a third pointer type:
</p>
<ul class="org-ul">
<li>The C pointer: [*c]T</li>
</ul>
<p>
This one is to be avoided as much as possible. The only reasons for its existence is for the translation from C code to Zig code, when the translater is not able to know what to convert it to in Zig (eg. sometimes it does not know if it can convert it to a non-optional pointer or not which could cause UBs).
</p>
</div>
</div>

<div id="outline-container-orgf48020f" class="outline-4">
<h4 id="orgf48020f"><span class="section-number-4">8.2.4.</span> Type conversions</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
Since in Zig there is no implicit conversions, depending on the project you might end up having "ugly" code with a lot of explicit type conversions. The code is more verbose but it is also less error-prone.
Exemple:
ZIG:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">rgb_to_grayscale_1d</span>(<span style="color: #fcaf3e;">img</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t, <span style="color: #fcaf3e;">result</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.height * img.width))) : (i += 1) {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">index</span> = i * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.components));
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">grayscale_value</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e090d7;">@intFromFloat</span>(imageh.FACTOR_R * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.R_OFFSET + index])) +
            imageh.FACTOR_G * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.G_OFFSET + index])) +
            imageh.FACTOR_B * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.B_OFFSET + index])));
        result.data[i] = grayscale_value;
    }
}
</pre>
</div>
<p>
C:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">rgb_to_grayscale_1D</span>(<span style="color: #b4fa70;">const</span> <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">img</span>, <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">result</span>) {
  printf(<span style="color: #e9b96e;">"height: %d"</span>, img-&gt;height);
  <span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">i</span> = 0; i &lt; img-&gt;height * img-&gt;width; i++) {
    <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">index</span> = i * img-&gt;components;
    <span style="color: #8cc4ff;">uint8_t</span> <span style="color: #fcaf3e;">grayscale_value</span> = (<span style="color: #8cc4ff;">uint8_t</span>)(FACTOR_R * img-&gt;data[R_OFFSET] +
                                        FACTOR_G * img-&gt;data[G_OFFSET] +
                                        FACTOR_B * img-&gt;data[B_OFFSET]);
    result-&gt;data[i] = grayscale_value;
  }
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgef376cf" class="outline-3">
<h3 id="orgef376cf"><span class="section-number-3">8.3.</span> How to call a C function from Zig</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Add those lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addIncludePath(.{ .path = <span style="color: #e9b96e;">"c-src"</span> }); <span style="color: #73d216;">// </span><span style="color: #73d216;">Folder containing the C files</span>
exe.linkLibC(); <span style="color: #73d216;">// </span><span style="color: #73d216;">Link the C standard library (which is zig own libc btw)</span>
</pre>
</div>

<p>
Then you can call the C functions like this from your Zig code:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c_hello</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"hello.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    c_hello.hello();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">res</span> = c_hello.add(1, 2);
    std.debug.print(<span style="color: #e9b96e;">"1 + 2 = {d}\n"</span>, .{res});
}
</pre>
</div>
<p>
Note that you can only do 1 @cImport per project. So what i recommend you to do is create a file containing all the c libraries you need in a file like so:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdio.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdlib.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"image.h"</span>);
});
</pre>
</div>
<p>
Then call this zig file in your other zig files.
</p>
</div>
</div>

<div id="outline-container-orgf496195" class="outline-3">
<h3 id="orgf496195"><span class="section-number-3">8.4.</span> How to call a Zig function from C / Continuing a C project with Zig</h3>
<div class="outline-text-3" id="text-8-4">
<p>
You can continue your C project without using Clang or GCC but by using Zig with all its toolchain it comes with.
</p>

<p>
In order to have a c file (main.c) as the entry point of your project using the zig build tool you have to add/comment the following lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">exe</span> = b.addExecutable(.{
    .name = <span style="color: #e9b96e;">"c_project"</span>,
    <span style="color: #73d216;">// </span><span style="color: #73d216;">.root_source_file = b.path("src/main.zig"),</span>
    .target = target,
    .optimize = optimize,
});
exe.root_module.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"src/main.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
exe.linkLibC();
</pre>
</div>

<p>
If you want to have more C files than just main.c you can add them like so:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"c-src/image.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
</pre>
</div>

<p>
TODO utiliser code zig dans project C <a href="https://zig.guide/working-with-c/calling-conventions">https://zig.guide/working-with-c/calling-conventions</a>
</p>
</div>

<div id="outline-container-org38dfb65" class="outline-4">
<h4 id="org38dfb65"><span class="section-number-4">8.4.1.</span> export and extern keywords</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
<b>export</b> make the the function visible from outside so that the C ABI can see it.
</p>

<p>
<b>extern</b> is used to link against an exported variable from an other object.
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Variables">Zig documentation for those 2 keywords.</a>
</p>

<p>
TODO jai oublie d ajouter du code zig, ne pas oublier export/extern
</p>

<p>
TODO pros and cons of using zig toolchain instead of clang or gcc
</p>
</div>
</div>
</div>

<div id="outline-container-org0767e2b" class="outline-3">
<h3 id="org0767e2b"><span class="section-number-3">8.5.</span> How is it done under the hood</h3>
<div class="outline-text-3" id="text-8-5">
<p>
When you do @cImport(@cInclude("foo.h")) in your zig code it runs translate-c and exposes the function and type definitions.
</p>

<p>
TODO talk about C ABI
</p>
</div>
</div>

<div id="outline-container-org202544d" class="outline-3">
<h3 id="org202544d"><span class="section-number-3">8.6.</span> Util to translate C code to Zig</h3>
<div class="outline-text-3" id="text-8-6">
<p>
zig translate-c is an util built in the zig toolchains that allows you to translate C code to Zig code.
You can translate any code but the code is going to be UNREADABLE, so I would not recommend this tool if you plan on modifying the code afterwards.
You have better time importing the C code in your Zig code.
Note that if you want to translate a C file that uses the libc you have to add the -lc flag like so:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig translate-c main.c -lc
</pre>
</div>
</div>

<div id="outline-container-orgc349102" class="outline-4">
<h4 id="orgc349102"><span class="section-number-4">8.6.1.</span> Comparison with other langauges that use C code</h4>
<div class="outline-text-4" id="text-8-6-1">
<p>
To test if integrating C code in Zig projects is really as seemless as some claims, I have decided to compare the C integration with Python aswell.
</p>

<p>
In order to do that I wrote a small C library:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">add</span>(<span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">a</span>, <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">b</span>) { <span style="color: #b4fa70;">return</span> a + b; }
</pre>
</div>

<p>
What I am going to do is test how much time it takes each program to run this function x times. (in this case x = 100'000'000)
</p>

<p>
Note: I didnt use any optimization in flag in python (because it did not change anything) and neither in Zig because I didnt want the compiler to try to optimize the code and be lazy.
</p>

<p>
Then in order to compare the 2 languages I wrote 4 programs:
</p>
<ul class="org-ul">
<li>Zig code that has and add function implementation in Zig</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">add</span>(<span style="color: #fcaf3e;">a</span>: <span style="color: #8cc4ff;">u32</span>, <span style="color: #fcaf3e;">b</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">return</span> a + b;
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.38sec
</p>

<ul class="org-ul">
<li>Vanilla Python code that has and add function implementation in Python</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">add</span>(a, b):
    <span style="color: #b4fa70;">return</span> a + b


<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    add(3, 7)
<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"done!"</span>)
</pre>
</div>
<p>
Result: ~10sec
</p>

<ul class="org-ul">
<li>Zig code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"mylib.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = c.add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done!\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.41sec
</p>

<ul class="org-ul">
<li>Python code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">import</span> ctypes

<span style="color: #fcaf3e;">mylib</span> = ctypes.CDLL(<span style="color: #e9b96e;">'./mylib.so'</span>)

mylib.add.<span style="color: #fcaf3e;">argtypes</span> = (ctypes.c_int, ctypes.c_int)
mylib.add.<span style="color: #fcaf3e;">restype</span> = ctypes.c_int

<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    <span style="color: #fcaf3e;">result</span> = mylib.add(3, 4)

<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"Result of last addition:"</span>, result)
</pre>
</div>
<p>
Result: ~50sec
</p>

<p>
TODO faire un joli graphique quand jaurai d autres languages
TODO idk if it would be possible to compile my c library and then use it in my python code, and all of that all in emacs, that would be cool :)
TODO do with other languages aswell
</p>
</div>

<ol class="org-ol">
<li><a id="org687e04e"></a>Conclusion<br />
<div class="outline-text-5" id="text-8-6-1-1">
<p>
First thing that we notice immediately is how much faster the Zig code is compared to the Python code. This is not surprising since Zig is a compiled language and Python is an interpreted language.
</p>

<p>
TODO why is python so slow ?
</p>

<p>
The second interesting thing is that the 2 Zig codes dont vary that much (if they even do) compared to the 2 python codes which have a 5x ratio. This is interesting because it shows that the overhead of calling a C function from Zig is not that big (in fact it is even not existent since all the compiler does is translating the C code to Zig code at compilation time).
</p>

<p>
We can conclude that calling C code from Zig is really seemless, because at runtime &#x2026; everything is Zig code.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org5d77ceb" class="outline-3">
<h3 id="org5d77ceb"><span class="section-number-3">8.7.</span> Notes</h3>
<div class="outline-text-3" id="text-8-7">
<p>
TODO For some unkown reason yet my LSP becomes very slow when working in a Zig project with C files and sometimes crashes. I have to investigate this further.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/master/#C-Pointers">https://ziglang.org/documentation/master/#C-Pointers</a></li>
<li><a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a></li>
<li><a href="https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8">https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8</a></li>
<li><a href="https://mtlynch.io/notes/zig-call-c-simple/">https://mtlynch.io/notes/zig-call-c-simple/</a></li>
<li><a href="https://ziglang.org/documentation/master/#cImport-vs-translate-c">https://ziglang.org/documentation/master/#cImport-vs-translate-c</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org3deac6b" class="outline-2">
<h2 id="org3deac6b"><span class="section-number-2">9.</span> Concurrency</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgd186a41" class="outline-3">
<h3 id="orgd186a41"><span class="section-number-3">9.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-9-1">
<p>
The objectives of this chapter is to go in depth about the different ways to do concurrency in ZIG.
</p>

<p>
We are going to explore the different ways to do concurrency in general (not Zig related) and then we could use a few of those solutions in ZIG.
</p>

<p>
By the end you should be able to see the pros and cons of each solution and choose the one that fits you in Zig.
</p>
</div>
</div>

<div id="outline-container-org2449088" class="outline-3">
<h3 id="org2449088"><span class="section-number-3">9.2.</span> Definitions</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Before diving into the different ways to do concurrency in ZIG, let's first define some terms that are useful to understand the basics of concurrency (not related to Zig).
</p>
</div>

<div id="outline-container-orgb1d2bbd" class="outline-4">
<h4 id="orgb1d2bbd"><span class="section-number-4">9.2.1.</span> Coroutine</h4>
<div class="outline-text-4" id="text-9-2-1">
<p>
Courtines enable the management of concurrent tasks like callbacks do (which make them not concurrent by nature but they are a tool to achieve concurrency). Their great power lies in their ability to write concurent task like you would write sequential code. They achieve this by yielding control between them. They are used for cooperative multitasking, since the control flow is managed by themselves and not the OS. You might see them in a lot of languages like Python, Lua, Kotlin, &#x2026; with keywords like <b><b>yield</b></b>, <b><b>resume</b></b>, <b><b>suspend</b></b>, &#x2026;
</p>

<p>
Coroutines can be either stackful or stackless, we are not gonna dive deep into this concept since most of the time you are going to use stackful coroutines since they allow you to suspend from within a nested stackframe (the only strength of stackless coroutines: efficiency)
</p>

<p>
Coroutines can also be symmetric or asymmetric:
</p>
</div>

<ol class="org-ol">
<li><a id="org2c8893e"></a>Symmetric coroutines<br />
<div class="outline-text-5" id="text-9-2-1-1">
<p>
The only way to transfer the control flow is by explicitly passing control <b><b>to another coroutine</b></b>.
</p>
</div>
</li>

<li><a id="org48eadff"></a>Asymmetric coroutines (called asymmetric because the control-transfer can go both ways)<br />
<div class="outline-text-5" id="text-9-2-1-2">
<ul class="org-ul">
<li>They have two control-transfer mechanisms:</li>
<li>invoking another coroutine which is going to be the subcoroutine of the calling coroutine</li>
<li>suspending itself and giving control back to the caller</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgfa2139c" class="outline-4">
<h4 id="orgfa2139c"><span class="section-number-4">9.2.2.</span> Green threads (userland threads)</h4>
<div class="outline-text-4" id="text-9-2-2">
<p>
Green threads, also known as userland threads are managed by a runtime or VM instead of the OS with standard kernel threads. They are lightweight compared to OS threads as they have a lower overhead (since it is managed in userspace instead of kernel). Even though they are not real OS threads, there are still OS threads that manage them under the hood. Paritculary useful for short-lived tasks.
</p>
<ul class="org-ul">
<li>preemptive multitasking ou cooperative (TODO JE NE SAIS TOUJOURS PAS psq le runtime peut toujours les preempter)</li>
</ul>
</div>
</div>

<div id="outline-container-org15c2c20" class="outline-4">
<h4 id="org15c2c20"><span class="section-number-4">9.2.3.</span> Fibers</h4>
<div class="outline-text-4" id="text-9-2-3">
<p>
Same as green threads but cooperative multitasking instead of preemptive multitasking
</p>
</div>
</div>

<div id="outline-container-orgfa2060d" class="outline-4">
<h4 id="orgfa2060d"><span class="section-number-4">9.2.4.</span> Preemptive multitasking</h4>
<div class="outline-text-4" id="text-9-2-4">
<p>
In preemptive multitasking it is the underlying architecture (not us, but the OS or the runtime for exemple) that is in charge of choosing which threads to execute and when. This implies that our threads can be stopped (preempted) at any time, even if in the middle of a task. This method gives the advantage of not having to worr about a thread being starved, since the underlying architecture is going to make sure that everyone gets enough CPU time.
</p>
</div>
</div>

<div id="outline-container-org877bdce" class="outline-4">
<h4 id="org877bdce"><span class="section-number-4">9.2.5.</span> Cooperative multitasking</h4>
<div class="outline-text-4" id="text-9-2-5">
<p>
Contrary to preemptive multitasking, it is the progammer job to choose which and when the differents threads are executed. Threads are going to run until they are explicitly yielding control back. This method gives the advantage to have the progammer to have a fine grained control over his ressources, but also implies that the programmer has to think about not starving threads.
</p>
</div>
</div>

<div id="outline-container-org405fd1d" class="outline-4">
<h4 id="org405fd1d"><span class="section-number-4">9.2.6.</span> Thread (ChatGPT)</h4>
<div class="outline-text-4" id="text-9-2-6">
<p>
Multithreading, a cornerstone of concurrency, operates by dividing tasks into multiple threads, each executing independently. Unlike asynchronous event-driven programming, threads typically block until their assigned task completes. This approach has long been the primary method for handling concurrency in software development.
</p>

<p>
Parallelism becomes achievable through multithreading (even though its not 100% guaranteed), particularly on multi-core CPUs, facilitating genuine simultaneous execution and maximizing hardware utilization. Threads also offer robust isolation, with each thread possessing its own execution context, stack, and local variables, ensuring task independence and preventing interference.
</p>

<p>
However, scalability can become a concern when managing numerous threads. The overhead of resource allocation by the operating system kernel for each thread may lead to scalability issues, particularly in high-demand environments. To mitigate this, thread pools are often employed to minimize the overhead of thread creation and destruction, thus optimizing performance and resource utilization.
To avoid this overhead, thread pools are often used, which manage a set of threads that can be reused for multiple tasks. This approach reduces the overhead of creating and destroying threads for each task, making it more efficient and scalable.
</p>
</div>
</div>

<div id="outline-container-org1d434ca" class="outline-4">
<h4 id="org1d434ca"><span class="section-number-4">9.2.7.</span> Event-driven programming (ChatGPT)</h4>
<div class="outline-text-4" id="text-9-2-7">
<p>
Event-driven programming, exemplified by platforms like NodeJS, operates through an event loop that continuously monitors for triggered "events". This architecture boasts scalability, adeptly managing numerous concurrent connections while keeping memory and CPU usage minimal. The engine powering NodeJS lies in the codebase hosted on GitHub at <a href="https://github.com/libuv/libuv">https://github.com/libuv/libuv</a>. Under the hood libuv is basically a single threaded <a href="https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop">event-loop</a> which is going to perform all IOs on non-blocking sockets that are polled by pollers like epoll, kqueue, &#x2026;
</p>
</div>
</div>
</div>
<div id="outline-container-org5b23eea" class="outline-3">
<h3 id="org5b23eea"><span class="section-number-3">9.3.</span> Zig solutions</h3>
<div class="outline-text-3" id="text-9-3">
<p>
There are multiple ways you currently can do concurent code in ZIG, we are going to explore a few here:
</p>
</div>

<div id="outline-container-org5e85aaa" class="outline-4">
<h4 id="org5e85aaa"><span class="section-number-4">9.3.1.</span> OS threads (std)</h4>
<div class="outline-text-4" id="text-9-3-1">
</div>
<ol class="org-ol">
<li><a id="orgd4e020c"></a>Basics<br />
<div class="outline-text-5" id="text-9-3-1-1">
<p>
Spawning OS thread in Zig is quite simple, since it is built-in in the standard library. Here is an example of how to spawn 2 threads that are going to print numbers from 0 to x in parallel:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">//</span><span style="color: #73d216;">std.debug.print("Total CPU cores = {!}\n", .{std.Thread.getCpuCount()});</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">thread1</span> = <span style="color: #b4fa70;">try</span> std.Thread.spawn(.{}, goTo, .{ 1, 5 });
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">thread2</span> = <span style="color: #b4fa70;">try</span> std.Thread.spawn(.{}, goTo, .{ 2, 3 });

    thread1.join();
    thread2.join();
}
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>(<span style="color: #fcaf3e;">thread_id</span>: <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">max</span>: <span style="color: #8cc4ff;">usize</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">u32</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt;= max) {
        std.debug.print(<span style="color: #e9b96e;">"{} = {}\n"</span>, .{ thread_id, i });
        i += 1;
    }
}
</pre>
</div>
<p>
Note that the std.Thread also offer few other useful functions like `std.Thread.getCpuCount()` to get the number of CPU cores available on the machine.
</p>
<div class="org-src-container">
<pre class="src src-zig">std.debug.print(<span style="color: #e9b96e;">"Total CPU cores = {!}\n"</span>, .{std.Thread.getCpuCount()});
</pre>
</div>
</div>
</li>

<li><a id="org0c5b9cb"></a>Thread pool<br />
<div class="outline-text-5" id="text-9-3-1-2">
<p>
You could also use a thread pool in order to have a few threads to multiple jobs and not 1 thread = 1 job
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};
    <span style="color: #b4fa70;">defer</span> _ = gpa.deinit();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pool</span>: <span style="color: #8cc4ff;">std</span>.Thread.Pool = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">try</span> pool.init(.{ .allocator = allocator, .n_jobs = 2 }); <span style="color: #73d216;">// </span><span style="color: #73d216;">if you dont set n_jobs it is simply going to use the total number of cores in your system, but alloactor is obligatory.</span>
    <span style="color: #b4fa70;">defer</span> pool.deinit();

    <span style="color: #b4fa70;">for</span> (0..8) |i| {
        <span style="color: #b4fa70;">try</span> pool.spawn(goTo, .{ <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">u8</span>, <span style="color: #e090d7;">@intCast</span>(i)), 3 });
    }
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>(<span style="color: #fcaf3e;">thread_id</span>: <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">max</span>: <span style="color: #8cc4ff;">usize</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">u32</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt;= max) {
        std.debug.print(<span style="color: #e9b96e;">"{} = {}\n"</span>, .{ thread_id, i });
        i += 1;
    }
}
</pre>
</div>
</div>
</li>

<li><a id="org2de92d4"></a>Under the hood<br />
<div class="outline-text-5" id="text-9-3-1-3">
<p>
Under the hood the threads are either pthread (<a href="https://ziglang.org/documentation/master/std/#std.Thread.use_pthreads">if we are under linux AND linking libc</a>) or it is simpy going to use native OS threads.
</p>

<p>
The advantage of doing multi-threading in Zig is that you don't have to worry about what is the target system going to be, since <b><b>std.Thread</b></b> implementation automatically chooses the native OS threads for the system your are compiling for (except if you want to enforce the use of pthreads). 
</p>

<p>
In C if you are using Windows for exemple, since <b><b>pthreads</b></b> it is not natively supported you would have to use a third-party implementation by adding a compilation tag like so:
</p>
<div class="org-src-container">
<pre class="src src-c">gcc program.c -o program -pthread
</pre>
</div>

<p>
Or worse, you would have to use a completly different library ending up with a lot of pre-processor directives to check if you are using Windows or not which is going to lead to messy code:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdio.h&gt;</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;windows.h&gt;</span>
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;pthread.h&gt;</span>
<span style="color: #e090d7;">#endif</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
DWORD <span style="color: #8cc4ff;">WINAPI</span> <span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">LPVOID</span> <span style="color: #fcaf3e;">lpParam</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> 0;
}
<span style="color: #e090d7;">#else</span>
<span style="color: #8cc4ff;">void</span> *<span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">arg</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> <span style="color: #e9b2e3;">NULL</span>;
}
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #8cc4ff;">HANDLE</span> <span style="color: #fcaf3e;">hThread</span>;
  <span style="color: #8cc4ff;">DWORD</span> <span style="color: #fcaf3e;">dwThreadId</span>;

  hThread = CreateThread(<span style="color: #e9b2e3;">NULL</span>, 0, ThreadFunc, <span style="color: #e9b2e3;">NULL</span>, 0, &amp;dwThreadId);
  <span style="color: #b4fa70;">if</span> (hThread == <span style="color: #e9b2e3;">NULL</span>) {
    printf(<span style="color: #e9b96e;">"Failed to create thread.\n"</span>);
    <span style="color: #b4fa70;">return</span> 1;
  }

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Wait for the thread to finish</span>
  WaitForSingleObject(hThread, INFINITE);

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Close the thread handle</span>
  CloseHandle(hThread);
<span style="color: #e090d7;">#else</span>
  <span style="color: #8cc4ff;">pthread_t</span> <span style="color: #fcaf3e;">thread</span>;
  <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">rc</span>;

  rc = pthread_create(&amp;thread, <span style="color: #e9b2e3;">NULL</span>, ThreadFunc, <span style="color: #e9b2e3;">NULL</span>);
  <span style="color: #b4fa70;">if</span> (rc) {
    printf(<span style="color: #e9b96e;">"Failed to create thread. Return code: %d\n"</span>, rc);
    <span style="color: #b4fa70;">return</span> 1;
  }

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Wait for the thread to finish</span>
  pthread_join(thread, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>

  printf(<span style="color: #e9b96e;">"Everything is done.\n"</span>);

  <span style="color: #b4fa70;">return</span> 0;
}
</pre>
</div>

<p>
Or you could write your own wrapper kind of like the way Zig does (this is not going to work on Windows, but you get the idea):
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdio.h&gt;</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;windows.h&gt;</span>
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;pthread.h&gt;</span>
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">myCreate</span>(<span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">long</span> *<span style="color: #fcaf3e;">thread</span>, <span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">func</span>) {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #b4fa70;">return</span> hThread = CreateThread(<span style="color: #e9b2e3;">NULL</span>, 0, func, <span style="color: #e9b2e3;">NULL</span>, 0, thread);
<span style="color: #e090d7;">#else</span>
  <span style="color: #b4fa70;">return</span> pthread_create(thread, <span style="color: #e9b2e3;">NULL</span>, func, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>
}

<span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">myJoin</span>(<span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">long</span> <span style="color: #fcaf3e;">thread</span>) {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #b4fa70;">return</span> WaitForSingleObject(thread, INFINITE);
<span style="color: #e090d7;">#else</span>
  pthread_join(thread, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>
}

<span style="color: #8cc4ff;">void</span> *<span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">arg</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> <span style="color: #e9b2e3;">NULL</span>;
}

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  <span style="color: #8cc4ff;">pthread_t</span> <span style="color: #fcaf3e;">thread</span>; <span style="color: #73d216;">// </span><span style="color: #73d216;">TODO I should also wrap that which is pthread specific</span>

  <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">rc</span> = myCreate(&amp;thread, ThreadFunc);
  <span style="color: #b4fa70;">if</span> (rc) {
    printf(<span style="color: #e9b96e;">"Failed to create thread. Return code: %d\n"</span>, rc);
    <span style="color: #b4fa70;">return</span> 1;
  }

  myJoin(thread);

  printf(<span style="color: #e9b96e;">"Everything is done.\n"</span>);

  <span style="color: #b4fa70;">return</span> 0;
}
</pre>
</div>
</div>
</li>

<li><a id="orgda5683b"></a>Thread synchronization<br /></li>


<li><a id="orga12bc03"></a>Leaky abstraction<br />
<div class="outline-text-5" id="text-9-3-1-5">
<p>
TODO: est ce que je peux fine tuned threads en Zig ? (priority, stack size, &#x2026;)
</p>
</div>
</li>

<li><a id="orgc1f1249"></a>Conclusion<br />
<div class="outline-text-5" id="text-9-3-1-6">
<p>
Zig threads are really useful since they have a very user-friendly abstraction with not a lot of functionalites that are almost never used anyway. This abstraction is also very useful for what we saw earlier, you don't have to worry about the target system, Zig is going to choose the right implementation for you.
</p>

<p>
But this leaky abstraction comes at a cost, you can not fine-tune your threads as much as you would like to.
</p>

<p>
If you need specific thread functionalities, like the ones we talked about, you can still do that in Zig by wrapping the C pthread library for exemple or directly use the OS native threads you want.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org00ae371" class="outline-4">
<h4 id="org00ae371"><span class="section-number-4">9.3.2.</span> async/await</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
This method uses suspensible stackless coroutines, this solution does not necessarly mean that you are going to have multiple threads or parallelism.
</p>

<p>
We are not going to dive deeper into this solution because it has been deprecated since 0.11 and is not coming back soon.
</p>

<p>
However it is still a good reading and way to understand concurency to read this <a href="https://zig.guide/async/introduction/">very good guide</a> that was made for this solution.
By reading this you might notice that <b><b>async/await</b></b> might <b><b>never</b></b> come out.
</p>

<p>
Note that if this solution is to be brought again it might come with breaking changes, so the syntax might change.
</p>

<p>
You can find a <a href="https://github.com/ziglang/zig/issues/6025">Github discussion</a> about the progress of this feature and why it is not implemented in the current version.
</p>

<p>
You can see <a href="https://ziglang.org/download/0.12.0/release-notes.html#AsyncAwait-Feature-Status">here</a> the main reasons why this solution is not implemented yet.
</p>
</div>

<ol class="org-ol">
<li><a id="orgebe2ac7"></a>Function coloring<br />
<div class="outline-text-5" id="text-9-3-2-1">
<p>
Green threads make function colors disapear ???? (dependences entre threads)
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-orgdbc74ec" class="outline-4">
<h4 id="orgdbc74ec"><span class="section-number-4">9.3.3.</span> libxev</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
Using an event loop (by wrapping libuv or using libxev which is the equivalent buz in ZIG)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-org87ff0fb" class="outline-4">
<h4 id="org87ff0fb"><span class="section-number-4">9.3.4.</span> Fibers</h4>
<div class="outline-text-4" id="text-9-3-4">
<p>
Using fibers (<a href="https://github.com/kprotty/zefi">https://github.com/kprotty/zefi</a>, <a href="https://github.com/kassane/fiber">https://github.com/kassane/fiber</a>)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-org1874f14" class="outline-4">
<h4 id="org1874f14"><span class="section-number-4">9.3.5.</span> zigcoro</h4>
<div class="outline-text-4" id="text-9-3-5">
<p>
This solution uses stackful asymmetric coroutines.
stackful asymmetric coroutines
This library is made to provide similar functionalities to async/await "old" model, so that if/when the official async/await solution is coming back, it will be easy to switch your project from using zigcoro to the official async/await.
async/await built on top of libxev (<a href="https://github.com/rsepassi/zigcoro">https://github.com/rsepassi/zigcoro</a>)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-orgf95f0b5" class="outline-4">
<h4 id="orgf95f0b5"><span class="section-number-4">9.3.6.</span> Using C libraries</h4>
<div class="outline-text-4" id="text-9-3-6">
<p>
&#x2026; obviously you can still use C libraries that do async stuff :)
TODO exemple
</p>
</div>
</div>
</div>

<div id="outline-container-org79ef113" class="outline-3">
<h3 id="org79ef113"><span class="section-number-3">9.4.</span> Conclusion</h3>
<div class="outline-text-3" id="text-9-4">
<p>
TODO: qu est ce que je pourrais bien dire de + que dans le contenu, parler du potentiel ?
</p>

<p>
TODO MES NOTES ---&#x2013;&#x2014; pas besoin de lire ca, cest juste pour moi pour approfondir certains sujets plus tard
</p>

<ul class="org-ul">
<li>"libuv and OSes will usually run background/worker threads and/or polling to perform tasks in a non-blocking manner." est ce que cest comment ca under the hood les non blocking async ?</li>

<li>"The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on"</li>

<li>tokio equivalent in zig ?</li>
</ul>
</div>
</div>

<div id="outline-container-org9edddf2" class="outline-3">
<h3 id="org9edddf2"><span class="section-number-3">9.5.</span> Sources:</h3>
<div class="outline-text-3" id="text-9-5">
<ul class="org-ul">
<li><a href="https://dl.acm.org/doi/pdf/10.1145/1462166.1462167">https://dl.acm.org/doi/pdf/10.1145/1462166.1462167</a></li>
<li><a href="https://www.lua.org/pil/9.1.html">https://www.lua.org/pil/9.1.html</a></li>
<li><a href="https://blog.orhun.dev/zig-bits-04/">https://blog.orhun.dev/zig-bits-04/</a> (regarder regul pour voir si il m a rep)</li>
<li><a href="https://github.com/mitchellh/libxev/issues/92">https://github.com/mitchellh/libxev/issues/92</a> (regul &#x2026;)</li>
<li>ChatGPT et GH Copilot</li>
<li><a href="https://github.com/lewissbaker/cppcoro">https://github.com/lewissbaker/cppcoro</a></li>
<li><a href="https://ericniebler.com/2020/11/08/structured-concurrency/">https://ericniebler.com/2020/11/08/structured-concurrency/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">https://en.wikipedia.org/wiki/Fiber_(computer_science)</a></li>
<li><a href="https://github.com/rsepassi/zigcoro">https://github.com/rsepassi/zigcoro</a></li>
<li><a href="https://github.com/mitchellh/libxev">https://github.com/mitchellh/libxev</a></li>
<li><a href="https://github.com/libuv/libuv">https://github.com/libuv/libuv</a></li>
<li><a href="https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst">https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/guide/basics.html">https://docs.libuv.org/en/v1.x/guide/basics.html</a> (ptetre le meme que celui au dessus)</li>
<li><a href="https://github.com/dotnet/runtimelab/issues/2398">https://github.com/dotnet/runtimelab/issues/2398</a></li>
<li><a href="https://kristoff.it/blog/zig-colorblind-async-await/">https://kristoff.it/blog/zig-colorblind-async-await/</a></li>
<li><a href="https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/">https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop">https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/guide/threads.html">https://docs.libuv.org/en/v1.x/guide/threads.html</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i">https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i</a></li>
<li><a href="https://github.com/ziglang/zig/issues/6025">https://github.com/ziglang/zig/issues/6025</a></li>
<li><a href="https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/">https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/</a></li>
<li><a href="https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network">https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network</a></li>
<li><a href="https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines">https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines</a></li>
<li><a href="https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time">https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time</a>.</li>
<li><a href="https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines">https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org8288288" class="outline-2">
<h2 id="org8288288"><span class="section-number-2">10.</span> Web frameworks</h2>
<div class="outline-text-2" id="text-10">
<p>
In this section we are going to explore the different ways of doing WEB servers in Zig.
</p>
</div>

<div id="outline-container-orgafc8260" class="outline-3">
<h3 id="orgafc8260"><span class="section-number-3">10.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-10-1">
<p>
TODO talk about WEB in general 
</p>
</div>
</div>

<div id="outline-container-org2075a5d" class="outline-3">
<h3 id="org2075a5d"><span class="section-number-3">10.2.</span> Zig solutions</h3>
</div>

<div id="outline-container-org7f8d6c8" class="outline-3">
<h3 id="org7f8d6c8"><span class="section-number-3">10.3.</span> Zap</h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-org2c361c4" class="outline-4">
<h4 id="org2c361c4"><span class="section-number-4">10.3.1.</span> Description</h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
Zap is a micro web framework that is mainly uses to write REST APIs.
</p>

<p>
Zap isn't really a fully Zig project, it just wraps and leverages the power of <a href="https://facil.io">facil.io</a>. By that I want to emphasize 2 things:
</p>
<ul class="org-ul">
<li>All the heavy lifting is done in C, so we can't give much of the performances merits to Zig on this</li>
<li>From the programmer POV it seems to you like your project is 100% Zig, so you have no C overhead (except linking libc)</li>
</ul>
</div>
</div>

<div id="outline-container-org45a5c85" class="outline-4">
<h4 id="org45a5c85"><span class="section-number-4">10.3.2.</span> Exemples</h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
The <a href="https://github.com/zigzap/zap">repo</a> gives you a lot of <a href="https://github.com/zigzap/zap/tree/master/examples">exemples</a> in order to get started.
TODO jaimerais bien faire les exemples ici mais comment faire pour utiliser une librairie dans org babel ? je ne pense pas que se soit possible, du moins facilement
</p>
</div>
</div>

<div id="outline-container-org7fa72d2" class="outline-4">
<h4 id="org7fa72d2"><span class="section-number-4">10.3.3.</span> Alternatives and performance comparaison</h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
TODO mettre le resultat de wrk bizzare
</p>
</div>
</div>

<div id="outline-container-org5b4df12" class="outline-4">
<h4 id="org5b4df12"><span class="section-number-4">10.3.4.</span> Conclusion</h4>
<div class="outline-text-4" id="text-10-3-4">
<p>
Zap is a very intersting project that is uses in production by some people (TODO).
</p>

<p>
Even though it should be working for almost all your use cases, it still is a microframework which means that there are not a lot of batteries included and if you need advanced features, you might have to those yourself (TODO exemple)
</p>

<p>
Since Zig is a low level language you are going to have a lot of boilerplate and small things like memory to manage manually. Those are things than can easily be avoided by using other languages (Java, Go, Node, &#x2026;)
</p>

<p>
It is also important to note that this is a young project with not a lot of contributors and a very small community. So if you are going to use Zap you might have to figure out things on your own or write on the <a href="https://discord.gg/gcZm8f8K">project discord</a>. You might aswell find codes or documentations that are oudated.
</p>

<p>
To conclude if you don't need <b><b>high</b></b> performances (C like), I wouldn't recommend this framework to build your REST APIs.
</p>
</div>
</div>

<div id="outline-container-org9b01a45" class="outline-4">
<h4 id="org9b01a45"><span class="section-number-4">10.3.5.</span> Mes notes</h4>
<div class="outline-text-4" id="text-10-3-5">
<p>
Callback based, we define certain callbacks, we configure from there
often not updated, hard to find yourself
je devrai aussi analyer facilio qui est ce qui est derriere la scene
</p>
</div>
</div>
</div>

<div id="outline-container-org9ab3d03" class="outline-3">
<h3 id="org9ab3d03"><span class="section-number-3">10.4.</span> HTTP from the std</h3>
<div class="outline-text-3" id="text-10-4">
</div>
<div id="outline-container-orgd8207d3" class="outline-4">
<h4 id="orgd8207d3"><span class="section-number-4">10.4.1.</span> Description</h4>
<div class="outline-text-4" id="text-10-4-1">
<p>
Http.zig: Dispatcher based, you create the dispatch chai (As far as I understand it)
</p>

<p>
just a server
</p>

<p>
from discord creator of zap: To put it simply: std.http has no concept of multiple concurrent connections. So you have to write your own "framework" handling that, e.g. using a thread-pool for handling requests and implementing some sort of polling to know when there's activity on the connections, and combine the two (poll &amp; pool).
</p>

<p>
std.http is very useful for what it was designed for. The Client was added to fetch packages, the Server to test the client. It's not designed to be a 100% out-of-the-box integratable implementation of everything HTTP/web, nor is it meant to be used in production in a massively multithreaded setup. 
</p>
</div>
</div>
<div id="outline-container-org7cc084b" class="outline-4">
<h4 id="org7cc084b"><span class="section-number-4">10.4.2.</span> Exemples</h4>
<div class="outline-text-4" id="text-10-4-2">
<p>
TODO
</p>
</div>
</div>

<div id="outline-container-orgcd92717" class="outline-4">
<h4 id="orgcd92717"><span class="section-number-4">10.4.3.</span> Tokamak</h4>
<div class="outline-text-4" id="text-10-4-3">
<p>
Middleware (scoped) and DI Based
</p>
</div>
</div>

<div id="outline-container-orgcd19c41" class="outline-4">
<h4 id="orgcd19c41"><span class="section-number-4">10.4.4.</span> Jetzig</h4>
<div class="outline-text-4" id="text-10-4-4">
<p>
Middleware (as part of a request chain) and Convention based
built on top of std.http for the moment
</p>

<p>
TODO: faire un benchmark avec plein de techo (rust, go, node, bun, &#x2026;) ET toutes les methodes vues au dessus
points forts/points faibles de chacun
</p>
</div>
</div>
</div>

<div id="outline-container-orge6ad9cc" class="outline-3">
<h3 id="orge6ad9cc"><span class="section-number-3">10.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-10-5">
<p>
Sources:
<a href="https://www.reddit.com/r/reactjs/comments/16blsh3/how_do_i_use_react_with_an_express_application/">https://www.reddit.com/r/reactjs/comments/16blsh3/how_do_i_use_react_with_an_express_application/</a>
<a href="https://lemire.me/blog/2023/10/07/web-server-hello-world-benchmark-go-vs-node-js-vs-nim-vs-bun/">https://lemire.me/blog/2023/10/07/web-server-hello-world-benchmark-go-vs-node-js-vs-nim-vs-bun/</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orga0c13ce" class="outline-2">
<h2 id="orga0c13ce"><span class="section-number-2">11.</span> Case studies</h2>
<div class="outline-text-2" id="text-11">
</div>
<div id="outline-container-org2ceca91" class="outline-3">
<h3 id="org2ceca91"><span class="section-number-3">11.1.</span> Interacting with processuses</h3>
<div class="outline-text-3" id="text-11-1">
<p>
TODO
<a href="https://github.com/Pismice/rename-i3-workspace">https://github.com/Pismice/rename-i3-workspace</a>
Was zig the good choice ?
Was it easy ?
What were the problems ?
What libraries did i use ?
</p>
</div>
</div>
</div>

<div id="outline-container-org047dfa0" class="outline-2">
<h2 id="org047dfa0"><span class="section-number-2">12.</span> Bibliography</h2>
<div class="outline-text-2" id="text-12">
<style>.csl-left-margin{float: left; padding-right: 0em;}
 .csl-right-inline{margin: 0 0 0 1em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">[1]</div><div class="csl-right-inline">“Documentation - The Zig Programming Language.” Accessed: Mar. 02, 2024. [Online]. Available: <a href="https://ziglang.org/documentation/0.11.0/#Introduction">https://ziglang.org/documentation/0.11.0/#Introduction</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>
    <div class="csl-left-margin">[2]</div><div class="csl-right-inline">“Comptime | zig.guide.” Accessed: Mar. 17, 2024. [Online]. Available: <a href="https://zig.guide/language-basics/comptime">https://zig.guide/language-basics/comptime</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_3"></a>
    <div class="csl-left-margin">[3]</div><div class="csl-right-inline">“Cross compilation | zig.guide.” Accessed: Mar. 05, 2024. [Online]. Available: <a href="https://zig.guide/build-system/cross-compilation">https://zig.guide/build-system/cross-compilation</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_4"></a>
    <div class="csl-left-margin">[4]</div><div class="csl-right-inline">“Learning Zig - Heap Memory &#38; Allocators.” Accessed: Mar. 03, 2024. [Online]. Available: <a href="https://www.openmymind.net/learning_zig/heap_memory/">https://www.openmymind.net/learning_zig/heap_memory/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_5"></a>
    <div class="csl-left-margin">[5]</div><div class="csl-right-inline">“Ziglang/zig.” Zig Programming Language, Mar. 02, 2024. Accessed: Mar. 02, 2024. [Online]. Available: <a href="https://github.com/ziglang/zig">https://github.com/ziglang/zig</a></div>
  </div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: tetratrux</p>
<p class="date">Created: 2024-05-20 lun 19:08</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
