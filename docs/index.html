<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-23 gio 14:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zig documentation</title>
<meta name="author" content="tetratrux" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'left',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Zig documentation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb6d2277">1. Introduction</a>
<ul>
<li><a href="#orgcab53c3">1.1. What this documentation IS</a></li>
<li><a href="#org76c4753">1.2. What this documentation IS NOT</a></li>
<li><a href="#orga8c506f">1.3. How to use this documentation</a></li>
<li><a href="#org878f4ae">1.4. Build Emacs configuration</a>
<ul>
<li><a href="#org6d9e684">1.4.1. Install Zig emacs org babel plugin</a></li>
<li><a href="#orgeea8d40">1.4.2. Create an emacs configuration file</a></li>
<li><a href="#orgfd9b479">1.4.3. Execute the configuration file from the configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb735ae9">2. Basics of the language</a>
<ul>
<li><a href="#orge300c2b">2.1. Reading external files</a>
<ul>
<li><a href="#orgc38ff6f">2.1.1. @embedFile</a></li>
<li><a href="#orgfeadd8e">2.1.2. Use an allocator to dynamically store the content of the file</a></li>
<li><a href="#org4ae0336">2.1.3. Read the file and put it in a buffer</a></li>
</ul>
</li>
<li><a href="#orgf3727be">2.2. Errors</a>
<ul>
<li><a href="#org4a27aa5">2.2.1. Handling errors in the application flow</a></li>
<li><a href="#orga39c60b">2.2.2. Errdefer</a></li>
<li><a href="#orge9f91c0">2.2.3. Coercing</a></li>
</ul>
</li>
<li><a href="#orgdd50923">2.3. Code styles</a>
<ul>
<li><a href="#org0b15c26">2.3.1. Style guide</a></li>
<li><a href="#org5f571ae">2.3.2. undefined and null values</a></li>
<li><a href="#org280f132">2.3.3. Zen</a></li>
</ul>
</li>
<li><a href="#org7295f98">2.4. Zig version manager</a>
<ul>
<li><a href="#org11ef159">2.4.1. Basic usage</a></li>
</ul>
</li>
<li><a href="#org02fa5bc">2.5. defer</a>
<ul>
<li><a href="#org2ae8ccb">2.5.1. Exemple</a></li>
<li><a href="#org47b5ce1">2.5.2. Freeing memory</a></li>
</ul>
</li>
<li><a href="#org327d2a5">2.6. Testing code</a></li>
<li><a href="#org5d33927">2.7. Compiler messages</a>
<ul>
<li><a href="#orgd2528cb">2.7.1. Trying to print without the correct struct syntax</a></li>
</ul>
</li>
<li><a href="#orgd8309e9">2.8. TCP stream</a>
<ul>
<li><a href="#orgde9ee5a">2.8.1. <span class="todo TODO">TODO</span> How Zig manages stream</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgafc8638">3. Comptime</a>
<ul>
<li><a href="#orgd3dcd9e">3.1. When to use and when NOT to use it</a>
<ul>
<li><a href="#orgb1003b2">3.1.1. When to use it</a></li>
<li><a href="#org72ac8bb">3.1.2. When NOT to use it (source: ziglings)</a></li>
</ul>
</li>
<li><a href="#org57bace2">3.2. Compile-time evaluation</a>
<ul>
<li><a href="#org2f5b366">3.2.1. Compile-time variable</a></li>
<li><a href="#orge330892">3.2.2. Compile-time expression</a></li>
<li><a href="#org1cc9f36">3.2.3. Compile-time parameter</a></li>
</ul>
</li>
<li><a href="#orgf68d155">3.3. Metaprogramming</a>
<ul>
<li><a href="#org9a4dc60">3.3.1. <code>@TypeOf</code></a></li>
<li><a href="#org475f20f">3.3.2. <code>@typeInfo</code></a></li>
</ul>
</li>
<li><a href="#orga464edc">3.4. <span class="todo TODO">TODO</span> Optimization</a>
<ul>
<li><a href="#org17c1d3a">3.4.1. How log works in Zig</a></li>
</ul>
</li>
<li><a href="#org2632b24">3.5. Generic data structures</a></li>
<li><a href="#org593c55a">3.6. Example with a custom CSV writer based on type</a></li>
<li><a href="#orgdd0bb46">3.7. Bonus</a></li>
</ul>
</li>
<li><a href="#orgd875481">4. Zig and C</a>
<ul>
<li><a href="#org5c3054a">4.1. Introduction</a></li>
<li><a href="#orga84afd9">4.2. Main differences between Zig and C in the syntax</a>
<ul>
<li><a href="#orgd91e9ca">4.2.1. Types</a></li>
<li><a href="#orgf7538db">4.2.2. Loops</a></li>
<li><a href="#org6de5871">4.2.3. Pointers</a></li>
<li><a href="#orgee8d0ba">4.2.4. Type conversions</a></li>
</ul>
</li>
<li><a href="#org313dd7a">4.3. How to call a C function from Zig</a></li>
<li><a href="#org10acc4e">4.4. How to call a Zig function from C / Continuing a C project with Zig</a>
<ul>
<li><a href="#org1801357">4.4.1. export and extern keywords</a></li>
</ul>
</li>
<li><a href="#org59f33c2">4.5. How is it done under the hood</a></li>
<li><a href="#orgc588ad0">4.6. Util to translate C code to Zig</a>
<ul>
<li><a href="#org832bd4c">4.6.1. Comparison with other langauges that use C code</a></li>
</ul>
</li>
<li><a href="#org84461ee">4.7. Notes</a></li>
</ul>
</li>
<li><a href="#orgc71a4fc">5. Compilation - build system</a>
<ul>
<li><a href="#orgb539f4e">5.1. <span class="todo TODO">TODO</span> Comptime</a></li>
<li><a href="#orgbca9eae">5.2. <span class="todo TODO">TODO</span> How to use the build system</a></li>
<li><a href="#org83a9f9c">5.3. Build modes</a>
<ul>
<li><a href="#org1f4e940">5.3.1. <span class="todo TODO">TODO</span> Build steps</a></li>
<li><a href="#orge54a2a6">5.3.2. <span class="todo TODO">TODO</span> Generate automatically documentation</a></li>
<li><a href="#orgdbeb8e8">5.3.3. Strip output binary in Zig in Linux</a></li>
<li><a href="#org87da537">5.3.4. Separate debug symbols from ELF executable</a></li>
</ul>
</li>
<li><a href="#org55de8ce">5.4. Cross-compilation</a>
<ul>
<li><a href="#org696418c">5.4.1. Cross-compile with an embedded linux</a></li>
</ul>
</li>
<li><a href="#org73a4503">5.5. Performance comparaison &amp; SMID</a>
<ul>
<li><a href="#org1292fde">5.5.1. Vectors</a></li>
<li><a href="#orgbb9ce00">5.5.2. Leibniz algorithm</a></li>
<li><a href="#org3ddd5fb">5.5.3. Benchmark your x86\<sub>64</sub> CPU</a></li>
<li><a href="#org14ac03a">5.5.4. ARM benchmark example</a></li>
<li><a href="#org8165cbe">5.5.5. <span class="todo TODO">TODO</span> Differents code examples benchmark</a></li>
</ul>
</li>
<li><a href="#orga831a20">5.6. Programming language Benchmarks</a>
<ul>
<li><a href="#org3e55be7">5.6.1. Results</a></li>
</ul>
</li>
<li><a href="#org68e022c">5.7. 1BRC</a></li>
<li><a href="#orgcbd8c03">5.8. Zig package manager</a>
<ul>
<li><a href="#org84c2d7a">5.8.1. Add a package in your project</a></li>
<li><a href="#orgbb8e542">5.8.2. Sources</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7498d7c">6. Allocator</a>
<ul>
<li><a href="#org2a1f58f">6.1. General pattern</a></li>
<li><a href="#org8c5d449">6.2. Page allocator (<code>page_allocator</code>)</a></li>
<li><a href="#org20a9762">6.3. Fixed buffer allocator</a></li>
<li><a href="#org23c4529">6.4. Arena allocator</a>
<ul>
<li><a href="#orgc550ae1">6.4.1. Internal working of arena allocator</a></li>
</ul>
</li>
<li><a href="#orgf1f9200">6.5. General purpose allocator</a></li>
<li><a href="#org0bb22dd">6.6. Testing allocator</a></li>
<li><a href="#org7e206ef">6.7. <span class="todo TODO">TODO</span> Failing allocator</a></li>
<li><a href="#orgc905786">6.8. <span class="todo TODO">TODO</span> C allocator</a></li>
<li><a href="#org3ad55f7">6.9. <span class="todo TODO">TODO</span> How to use Zig to detect memory leaks</a>
<ul>
<li><a href="#org0087efa">6.9.1. <span class="todo TODO">TODO</span> Comparison between gcc-utils sanitizer, Valgrind, and Zig memory leak detection</a></li>
</ul>
</li>
<li><a href="#org9ea7a16">6.10. <span class="todo TODO">TODO</span> ?</a></li>
<li><a href="#orgf9d0871">6.11. Conclusion</a></li>
</ul>
</li>
<li><a href="#org1800208">7. Comptime</a>
<ul>
<li><a href="#org259969e">7.1. When to use and when NOT to use it</a>
<ul>
<li><a href="#org3328333">7.1.1. When to use it</a></li>
<li><a href="#org7acf05e">7.1.2. When NOT to use it (source: ziglings)</a></li>
</ul>
</li>
<li><a href="#orgd6c9315">7.2. Compile-time evaluation</a>
<ul>
<li><a href="#org5f105a5">7.2.1. Compile-time variable</a></li>
<li><a href="#orgcc40ba3">7.2.2. Compile-time expression</a></li>
<li><a href="#orgcc16a21">7.2.3. Compile-time parameter</a></li>
</ul>
</li>
<li><a href="#org9249602">7.3. Metaprogramming</a>
<ul>
<li><a href="#org8a72bd7">7.3.1. <code>@TypeOf</code></a></li>
<li><a href="#org5e0e519">7.3.2. <code>@typeInfo</code></a></li>
</ul>
</li>
<li><a href="#org55b2b10">7.4. <span class="todo TODO">TODO</span> Optimization</a>
<ul>
<li><a href="#org0695815">7.4.1. How log works in Zig</a></li>
</ul>
</li>
<li><a href="#orgafc5258">7.5. Generic data structures</a></li>
<li><a href="#orgb3cd3a7">7.6. Example with a custom CSV writer based on type</a></li>
<li><a href="#org8a844cf">7.7. Bonus</a></li>
</ul>
</li>
<li><a href="#org19926e2">8. Concurrency</a>
<ul>
<li><a href="#orgc39c64c">8.1. Introduction</a></li>
<li><a href="#org67065c0">8.2. Definitions</a>
<ul>
<li><a href="#org30cb714">8.2.1. Coroutine</a></li>
<li><a href="#org6dd9df8">8.2.2. Green threads (userland threads)</a></li>
<li><a href="#orgeac70b6">8.2.3. Fibers</a></li>
<li><a href="#orgcf169a3">8.2.4. Preemptive multitasking</a></li>
<li><a href="#org6a0139a">8.2.5. Cooperative multitasking</a></li>
<li><a href="#org65f2296">8.2.6. Kernel threads</a></li>
<li><a href="#orgc2fbc76">8.2.7. Event-driven programming</a></li>
<li><a href="#org5e35baf">8.2.8. Asynchronous programming (non-blocking IO)</a></li>
</ul>
</li>
<li><a href="#org6fbfff0">8.3. Zig solutions</a>
<ul>
<li><a href="#org9afeebf">8.3.1. OS threads (std)</a></li>
<li><a href="#org702e7c7">8.3.2. async/await</a></li>
<li><a href="#org30ba5c9">8.3.3. libxev</a></li>
<li><a href="#org571dff4">8.3.4. Fibers</a></li>
<li><a href="#org2440aea">8.3.5. zigcoro</a></li>
<li><a href="#org9836cd2">8.3.6. Using C libraries</a></li>
</ul>
</li>
<li><a href="#org234870a">8.4. Conclusion</a></li>
<li><a href="#org9d9a2b9">8.5. Sources:</a></li>
</ul>
</li>
<li><a href="#orgf95db38">9. Web frameworks</a>
<ul>
<li><a href="#org7901eff">9.1. Introduction</a></li>
<li><a href="#orge04c6d9">9.2. Zig solutions</a></li>
<li><a href="#orgbc3ed27">9.3. Zap</a>
<ul>
<li><a href="#org8b160f8">9.3.1. Description</a></li>
<li><a href="#orgde54771">9.3.2. Exemples</a></li>
<li><a href="#org36d49a4">9.3.3. Alternatives and performance comparaison</a></li>
<li><a href="#orgcd2d344">9.3.4. Conclusion</a></li>
<li><a href="#orgd59fa09">9.3.5. Mes notes</a></li>
</ul>
</li>
<li><a href="#orgb8faf58">9.4. HTTP from the std</a>
<ul>
<li><a href="#org737481a">9.4.1. Description</a></li>
<li><a href="#orgea2726d">9.4.2. Exemples</a></li>
<li><a href="#org11ff70e">9.4.3. Tokamak</a></li>
<li><a href="#orged912be">9.4.4. Jetzig</a></li>
</ul>
</li>
<li><a href="#orge0fd39b">9.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#orgbb603f3">10. Case studies</a>
<ul>
<li><a href="#org2891e31">10.1. Interacting with processuses</a></li>
</ul>
</li>
<li><a href="#org33dc4c1">11. Bibliography</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgb6d2277" class="outline-2">
<h2 id="orgb6d2277"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Nowadays, <a href="https://www.reddit.com/r/C_Programming/comments/nqkn93/what_do_people_think_of_the_c_replacements_are/">multiple languages</a> have emerged to compete with the well-established C language.
In fact, C is widely used in many places, learned by a lot of engineers, and used for many purposes.
C is a powerful tool, <i>but with great power comes great responsibility</i>, in fact, memory leaks can easily occur by mistake.
</p>

<p>
That's why new languages come to find a better way to handle errors and memory.
The Rust language relies strongly on its borrow checker to ensure safe memory but it comes at a cost: increased code complexity, that can slow down it's adoption.
</p>

<p>
In another case, the Zig language has a purpose to replace the C language.
Zig wants to simplify the programming development experience with no hidden control flow and no macro to avoid complex mistakes.
In contrary to rust, in Zig the memory is managed explicitly, you have to manually allocate and deallocate memory, just as in C.
Zig offers different allocators that have different purposes, but some can detect memory leaks (<a href="./allocators.html#General purpose allocator">General purpose allocator</a>).
</p>

<p>
In the sections below, certain aspects of this programming language will be explored in greater depth.
</p>

<p>
Note that this documentation is generated from emacs with org-mode and that you can find the Github repository <a href="https://pismice.github.io/HEIG_ZIG/">here</a>.
</p>
</div>

<div id="outline-container-orgcab53c3" class="outline-3">
<h3 id="orgcab53c3"><span class="section-number-3">1.1.</span> What this documentation IS</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This documentation is being worked on by 2 students from the HEIG-VD, in the context of a course for one and a Bachelor Thesis for the other.
The goal of this documentation is to explore the Zig language in-depth, by first learning a few basics of the language we judge interesting/useful, and then by exploring more advanced topics.
</p>

<p>
This work is mainly aimed at engineers who already have experiences in C but might consider using Zig as a replacement/alternative. If you are a complete beginner, you might still learn a lot by reading this, but we highly encourage you to look at other ressources aimed at beginners aswell.
</p>

<p>
The big + this project offers compare to other guides/documentations is that here we are going to learn the language with <a href="https://en.wikipedia.org/wiki/Literate_programming">literate programming</a> (learning via interactive code exemples) because <b>one snippet of code is worth 1000 words</b>.
</p>

<p>
The advanced topics covered are mostly structured like so:
</p>
<ol class="org-ol">
<li>Explain the concept and see what is done in other languages (mostly C)</li>
<li>Show how to do it in Zig</li>
<li>Conclusion about the current state of Zig on this topic</li>
</ol>

<p>
Note that we wrote this documentation with the help of AI assistants like ChatGPT and GH Copilot.
</p>
</div>
</div>

<div id="outline-container-org76c4753" class="outline-3">
<h3 id="org76c4753"><span class="section-number-3">1.2.</span> What this documentation IS NOT</h3>
<div class="outline-text-3" id="text-1-2">
<p>
This is <b>not</b> a guide to learn Zig as first-language, this documentation wants to go in-depth in certain parts of the language.
</p>

<p>
To understand what is described in this documentation, you should first read up on the basics of the Zig language, in particular, its guide, which contains a wealth of information.
</p>
<ul class="org-ul">
<li><a href="https://zig.guide">Zig guide</a></li>
<li><a href="https://ziglang.org/documentation/0.11.0">Zig documentation</a></li>
</ul>
</div>
</div>

<div id="outline-container-orga8c506f" class="outline-3">
<h3 id="orga8c506f"><span class="section-number-3">1.3.</span> How to use this documentation</h3>
<div class="outline-text-3" id="text-1-3">
<p>
This documentation is built to guide to user through different examples.
Those examples have been created to use literate programming, in fact, the documentation is built on Emacs with the org mode.
You can follow the examples and execute them directly in Emacs.
</p>

<p>
For that, you need to:
</p>
<ol class="org-ol">
<li>Install the configuration created for that (see the section below)</li>
<li>When all is configured, in Emacs you can select the example that you want to execute and use the command <code>C-c C-c</code>.
The output will be created or updated below the source block. If you want more documentation, you can check the <a href="https://orgmode.org/worg/org-contrib/babel/intro.html">Org babel documentation</a></li>
</ol>

<p>
You can follow the examples with the Zig version 0.12.
But Zig is in constant evolution we <b>may</b> have to use other versions at some point in this guide, but if that is the case we will precise it.
</p>
</div>
</div>

<div id="outline-container-org878f4ae" class="outline-3">
<h3 id="org878f4ae"><span class="section-number-3">1.4.</span> Build Emacs configuration</h3>
<div class="outline-text-3" id="text-1-4">
<p>
TODO RAJOUTER les etapes EN PARTANT DE 0, IL FAUT IMAGINER QUE L UTILISATEUR N AIT PAS EMACS, RIEN DU TOUT
</p>
</div>

<div id="outline-container-org6d9e684" class="outline-4">
<h4 id="org6d9e684"><span class="section-number-4">1.4.1.</span> Install Zig emacs org babel plugin</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
Use <code>C-c C-c</code> (<code>ctrl-c ctrl-c</code>) to evaluate the code below.
It will add a shell interpreter inside org-babel configuration, it will be used when shell commands are evaluated.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'org-babel-load-languages '(shell . t))
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
</pre>
</div>

<p>
The shell command will clone an org babel <a href="https://github.com/samuel-schlaeppy/ob-zig.el.git">zig plugin</a> necessary to execute some Zig example directly in Emacs with Org babel.
</p>

<p>
The <code>HEADER</code> parameter below configures the directory path by default.
You can change the directory where the plugin will be installed (change the argument after the <code>:dir</code>).
</p>
<div class="org-src-container">
<pre class="src src-shell">git clone https://github.com/samuel-schlaeppy/ob-zig.el.git
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeea8d40" class="outline-4">
<h4 id="orgeea8d40"><span class="section-number-4">1.4.2.</span> Create an emacs configuration file</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
TODO le prof n a pas compris cette phrase entre guillemets et moi non plus apres relecture :-)
</p>

<p>
"To use the plugin installed before, you need to modify the first path to give the path where the plugin is installed (see section upper),"
and a path to the Zig executable need also to be referenced.
</p>

<p>
After that, the following command <code>C-c C-v t</code> (<code>ctrl-c ctrl-v t</code>) will produce a <code>zigIterativeProgramming.el</code> file.
This file can be loaded from your emacs configuration (see section below).
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">setq</span> base_dir <span style="color: #e9b96e;">"~/PATH-WHERE-THE-ZIG-PLUGIN-IS-INSTALLED/ob-zig.el"</span>)
(<span style="color: #b4fa70;">setq</span> org-babel-zig-compiler <span style="color: #e9b96e;">"PATH-TO-THE-ZIG-EXECUTABLE"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">require</span> '<span style="color: #e9b2e3;">package</span>)
(add-to-list 'package-archives
             '(<span style="color: #e9b96e;">"melpa"</span> . <span style="color: #e9b96e;">"https://melpa.org/packages/"</span>))
(package-initialize)
(package-refresh-contents)

(<span style="color: #b4fa70;">defun</span> <span style="color: #fce94f;">install-custom-pkg</span> (pck)
  (<span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">featurep</span> <span style="color: #e9b2e3;">pck</span>)
      (message <span style="color: #e9b96e;">"The package %s is already installed !"</span> pck)
    (package-install pck)
    ))

(install-custom-pkg 'zig-mode)
(install-custom-pkg 'lsp-mode)
(<span style="color: #b4fa70;">require</span> '<span style="color: #e9b2e3;">lsp-mode</span>)
(add-hook 'zig-mode-hook #'lsp)

(<span style="color: #b4fa70;">let</span> ((local-file-path (expand-file-name <span style="color: #e9b96e;">"ob-zig.el"</span> base_dir)))
  (<span style="color: #b4fa70;">setq</span> org-babel-zig-compiler local-file-path)
  (load-file local-file-path)
  )

(custom-set-variables
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">custom-set-variables was added by Custom.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">If you edit it by hand, you could mess it up, so be careful.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">Your init file should contain only one such instance.</span>
 <span style="color: #73d216;">;; </span><span style="color: #73d216;">If there is more than one, they won't work right.</span>
 '(org-babel-load-languages '((C . t) (emacs-lisp . t) (shell . t))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd9b479" class="outline-4">
<h4 id="orgfd9b479"><span class="section-number-4">1.4.3.</span> Execute the configuration file from the configuration</h4>
<div class="outline-text-4" id="text-1-4-3">
<p>
You can put the code below in your <code>init.el</code> it will load the file produced before and load the necessary package to learn Zig with literate programming.
But you need the specify the directory path of the <code>zigIterativeProgramming.el</code> file (first line below).
(the <code>init.el</code> can be found in <code>~/.emacs.d/</code> or can be created in <code>~/.config/emacs/</code>
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #b4fa70;">let</span> ((file_dir <span style="color: #e9b96e;">"~/PATH-TO-THE-zigIterativeProgramming-file"</span>))
(load-file (expand-file-name <span style="color: #e9b96e;">"zigIterativeProgramming.el"</span> file_dir)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb735ae9" class="outline-2">
<h2 id="orgb735ae9"><span class="section-number-2">2.</span> Basics of the language</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orge300c2b" class="outline-3">
<h3 id="orge300c2b"><span class="section-number-3">2.1.</span> Reading external files</h3>
<div class="outline-text-3" id="text-2-1">
<p>
There are multiple ways to do it in ZIG:
</p>
</div>
<div id="outline-container-orgc38ff6f" class="outline-4">
<h4 id="orgc38ff6f"><span class="section-number-4">2.1.1.</span> @embedFile</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
This method is simply going to embed the file in the binary at compile time.
</p>

<p>
Beware that by using this method the path to the file is going to be relative to the file you are calling it from and that the file must be in the same package.
</p>

<p>
By using the other methods below you can use a file from anywhere but relative to your root folder and not main.zig.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">input</span> = <span style="color: #e090d7;">@embedFile</span>(<span style="color: #e9b96e;">"input.txt"</span>);
std.debug.print(<span style="color: #e9b96e;">"{s}"</span>, .{input});
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfeadd8e" class="outline-4">
<h4 id="orgfeadd8e"><span class="section-number-4">2.1.2.</span> Use an allocator to dynamically store the content of the file</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
By using the method: readToEndAlloc 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #73d216;">// </span><span style="color: #73d216;">Alocator</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gp</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> gp.deinit();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gp.allocator();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Path</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">path_buffer</span>: [std.fs.MAX_PATH_BYTES]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">path</span> = <span style="color: #b4fa70;">try</span> std.fs.realpath(<span style="color: #e9b96e;">"./input.txt"</span>, &amp;path_buffer);

<span style="color: #73d216;">// </span><span style="color: #73d216;">Open file</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file</span> = <span style="color: #b4fa70;">try</span> std.fs.openFileAbsolute(path, .{});
<span style="color: #b4fa70;">defer</span> file.close();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Read</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file_content</span> = <span style="color: #b4fa70;">try</span> file.readToEndAlloc(allocator, std.math.maxInt(<span style="color: #8cc4ff;">usize</span>));
<span style="color: #b4fa70;">defer</span> allocator.free(file_content);
</pre>
</div>
</div>
</div>

<div id="outline-container-org4ae0336" class="outline-4">
<h4 id="org4ae0336"><span class="section-number-4">2.1.3.</span> Read the file and put it in a buffer</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
By using the method readAll 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #73d216;">// </span><span style="color: #73d216;">Path</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">path_buffer</span>: [std.fs.MAX_PATH_BYTES]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">path</span> = <span style="color: #b4fa70;">try</span> std.fs.realpath(<span style="color: #e9b96e;">"./input.txt"</span>, &amp;path_buffer);

<span style="color: #73d216;">// </span><span style="color: #73d216;">Open file</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">file</span> = <span style="color: #b4fa70;">try</span> std.fs.openFileAbsolute(path, .{});
<span style="color: #b4fa70;">defer</span> file.close();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Read</span>
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">content_buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">size</span> = <span style="color: #b4fa70;">try</span> file.readAll(&amp;content_buffer);

std.debug.print(<span style="color: #e9b96e;">"{s}"</span>, .{content_buffer[0..size]});
</pre>
</div>

<p>
TODO reading files with org babel doesnt work yet idk why
</p>

<p>
Sources: 
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/master/std/#std.fs.File.readToEndAlloc">https://ziglang.org/documentation/master/std/#std.fs.File.readToEndAlloc</a></li>
<li><a href="https://ziglang.org/documentation/master/std/#std.fs.File.readAll">https://ziglang.org/documentation/master/std/#std.fs.File.readAll</a></li>
<li><a href="https://ziglang.org/documentation/master/#embedFile">https://ziglang.org/documentation/master/#embedFile</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf3727be" class="outline-3">
<h3 id="orgf3727be"><span class="section-number-3">2.2.</span> Errors</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<a href="https://ziglang.org/documentation/0.11.1/#Errors">https://ziglang.org/documentation/0.11.1/#Errors</a>
</p>

<p>
In ZIG errors are juste values.
</p>

<p>
Those values are those of an special type of enum "error".
</p>

<p>
When you declare your enum using this keyword instead of "enum", the compiler is going to know that those values are going to be errors, therefore they can be catched, tried, &#x2026;
</p>
</div>


<div id="outline-container-org4a27aa5" class="outline-4">
<h4 id="org4a27aa5"><span class="section-number-4">2.2.1.</span> Handling errors in the application flow</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Functions can return either a value or an error, this is done by adding the "!" to the return type of a function
With the "!" the return type of the function below is the coerced "anyerror!u8"
</p>

<p>
Note 1: "anyerror" is just a u16 under the hood.
Note 2: It is important that the syntax is ErrorSet!Payload if you write it by hand and NOT Payload!ErrorSet
</p>

<p>
When a function can return an error we have to either "try" or "catch" it.
</p>

<div class="org-src-container">
<pre class="src src-zig" id="org2a53f8d"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">maybeErrorMaybeValue</span>(<span style="color: #fcaf3e;">isError</span>: <span style="color: #8cc4ff;">bool</span>) !<span style="color: #8cc4ff;">u8</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">... might return an u8 or an error</span>
    <span style="color: #b4fa70;">if</span> (isError) {
        <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.Bar;
    } <span style="color: #b4fa70;">else</span> {
        <span style="color: #b4fa70;">return</span> 2;
    }
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"return value or error"</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">"try" version</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">res</span> = <span style="color: #b4fa70;">try</span> maybeErrorMaybeValue(<span style="color: #e9b2e3;">false</span>); <span style="color: #73d216;">// </span><span style="color: #73d216;">if error, return the error</span>
    <span style="color: #b4fa70;">try</span> std.testing.expect(res == 2);

    <span style="color: #73d216;">// </span><span style="color: #73d216;">"catch" version</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">err</span> = maybeErrorMaybeValue(<span style="color: #e9b2e3;">true</span>) <span style="color: #b4fa70;">catch</span> 3;
    <span style="color: #b4fa70;">try</span> std.testing.expect(err == 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should panic"</span> {
    _ = maybeErrorMaybeValue(<span style="color: #e9b2e3;">true</span>) <span style="color: #b4fa70;">catch</span> <span style="color: #b4fa70;">unreachable</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orga39c60b" class="outline-4">
<h4 id="orga39c60b"><span class="section-number-4">2.2.2.</span> Errdefer</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
This exemple is taken from the <a href="https://ziglang.org/documentation/master/#errdefer">official documentation</a>
Errdefer is a particularity of ZIG, it allows the user to execute some code when the function returns an error, it is useful exemple for deallocating variables you would have normally returned from the function, but since the function failed you deallocate that memory to avoid a memory leak.
</p>
<div class="org-src-container">
<pre class="src src-zig" id="org1ff264b"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">createFoo</span>(<span style="color: #fcaf3e;">param</span>: <span style="color: #8cc4ff;">i32</span>) !Foo {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">foo</span> = <span style="color: #b4fa70;">try</span> tryToAllocateFoo();
    <span style="color: #73d216;">// </span><span style="color: #73d216;">now we have allocated foo. we need to free it if the function fails.</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">but we want to return it if the function succeeds.</span>
    <span style="color: #b4fa70;">errdefer</span> deallocateFoo(foo);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">tmp_buf</span> = allocateTmpBuffer() <span style="color: #b4fa70;">orelse</span> <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.OutOfMemory;
    <span style="color: #73d216;">// </span><span style="color: #73d216;">tmp_buf is truly a temporary resource, and we for sure want to clean it up</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">before this block leaves scope</span>
    <span style="color: #b4fa70;">defer</span> deallocateTmpBuffer(tmp_buf);

    <span style="color: #b4fa70;">if</span> (param &gt; 1337) <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">error</span>.InvalidParam;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">here the errdefer will not run since we're returning success from the function.</span>
    <span style="color: #73d216;">// </span><span style="color: #73d216;">but the defer will run!</span>
    <span style="color: #b4fa70;">return</span> foo;
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orge9f91c0" class="outline-4">
<h4 id="orge9f91c0"><span class="section-number-4">2.2.3.</span> Coercing</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
The rule is simple: you can coerce an error from a subset to a superset but you cannot coerce an error from a superset to a subset
</p>

<div class="org-src-container">
<pre class="src src-zig" id="org4031eea"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">SuperErrors</span> = <span style="color: #b4fa70;">error</span>{
    Foo,
    Bar,
    Baz,
};
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">SubErrors</span> = <span style="color: #b4fa70;">error</span>{
    Foo,
    Bar,
};

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"coerce subset to superset"</span> {
    tac(SubErrors.Foo) <span style="color: #b4fa70;">catch</span> {}; <span style="color: #73d216;">// </span><span style="color: #73d216;">PASSED</span>
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"coerce superset to subset"</span> {
    tic(SuperErrors.Foo) <span style="color: #b4fa70;">catch</span> {}; <span style="color: #73d216;">// </span><span style="color: #73d216;">FAILED</span>
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">tic</span>(<span style="color: #fcaf3e;">err</span>: <span style="color: #8cc4ff;">SuperErrors</span>) SubErrors {
    <span style="color: #b4fa70;">return</span> err;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">tac</span>(<span style="color: #fcaf3e;">err</span>: <span style="color: #8cc4ff;">SubErrors</span>) SuperErrors {
    <span style="color: #b4fa70;">return</span> err;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdd50923" class="outline-3">
<h3 id="orgdd50923"><span class="section-number-3">2.3.</span> Code styles</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org0b15c26" class="outline-4">
<h4 id="org0b15c26"><span class="section-number-4">2.3.1.</span> Style guide</h4>
<div class="outline-text-4" id="text-2-3-1">
</div>
<ol class="org-ol">
<li><a id="org63de596"></a>fmt<br />
<div class="outline-text-5" id="text-2-3-1-1">
<p>
First it is important to know that Zig comes with a formatter that you can use using:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig fmt file.zig
</pre>
</div>
<p>
This util is going to enforce basic things for you like:
</p>
<ul class="org-ul">
<li>Indentation</li>
<li>Braces alignment</li>
<li>Line length</li>
<li>&#x2026;.</li>
</ul>
</div>
</li>
<li><a id="org798c645"></a>Naming conventions<br />
<div class="outline-text-5" id="text-2-3-1-2">
<ol class="org-ol">
<li><code>TitleCaseTypeName</code>: for types and structs that are callable (for "classes" in other languages basically)</li>
<li><code>camelCaseFunctionName</code>: for functions</li>
<li><code>snake\_case\_variable_name</code>: for variables and everything else</li>
</ol>
</div>
</li>
</ol>
</div>

<div id="outline-container-org5f571ae" class="outline-4">
<h4 id="org5f571ae"><span class="section-number-4">2.3.2.</span> undefined and null values</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
TODO for some reason the 2 org block code are not working, maybe i should "testsuite"
TODO how can i make the second one print the error ?
</p>

<p>
In Zig you can leave variables uninitialized, but you have to do that explicitly contrary to C where you can leave variables uninitialized and never truly notice it. Note that leaving the value undefined is going to leave the memory of this variable to some complete nonsense value (except in Debug mode where it will be <a href="https://github.com/ziglang/zig/issues/15603%20">set to 0xaa</a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">my_var</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
std.debug.print(<span style="color: #e9b96e;">"my_var: {}\n"</span>, .{my_var});
</pre>
</div>

<p>
This is to be avoided as much as possible, if you have some in your code it might makes sense to use an Optional type instead so that compiler can scream at you :)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">my_var</span>: ?<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">null</span>;

<span style="color: #73d216;">// </span><span style="color: #73d216;">.? is syntaxic sugar for "orelse unreachable" which is going</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">unreachable is going to emit a panic (unable to unwrapp null) !</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">THIS CODE WILL PANIC IF UNCOMMENTED</span>
<span style="color: #73d216;">// </span><span style="color: #73d216;">_ = my_var.?;</span>

<span style="color: #73d216;">// </span><span style="color: #73d216;">if value is "null" then "42" will be assigned</span>
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">u8</span> = my_var <span style="color: #b4fa70;">orelse</span> 42;

<span style="color: #73d216;">// </span><span style="color: #73d216;">print 42 because value was null before</span>
std.debug.print(<span style="color: #e9b96e;">"my_var = {}\n"</span>, .{value});
</pre>
</div>
</div>
</div>

<div id="outline-container-org280f132" class="outline-4">
<h4 id="org280f132"><span class="section-number-4">2.3.3.</span> Zen</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
Zig encourages you to use the <a href="https://ziglang.org/documentation/0.12.0/#Zen">Zen philosophy</a>, they reflect well the spirit behind Zig, here they are:
</p>
<ul class="org-ul">
<li>Communicate intent precisely.</li>
<li>Edge cases matter.</li>
<li>Favor reading code over writing code.</li>
<li>Only one obvious way to do things.</li>
<li>Runtime crashes are better than bugs.</li>
<li>Compile errors are better than runtime crashes.</li>
<li>Incremental improvements.</li>
<li>Avoid local maximums.</li>
<li>Reduce the amount one must remember.</li>
<li>Focus on code rather than style.</li>
<li>Resource allocation may fail; resource deallocation must succeed.</li>
<li>Memory is a resource.</li>
<li>Together we serve the users.</li>
</ul>

<p>
Sources:
<a href="https://ziglang.org/documentation/master/#Type-Coercion-undefined">https://ziglang.org/documentation/master/#Type-Coercion-undefined</a>
<a href="https://nathancraddock.com/blog/zig-naming-conventions/o">https://nathancraddock.com/blog/zig-naming-conventions/o</a>
<a href="https://ziglang.org/documentation/master/#undefined">https://ziglang.org/documentation/master/#undefined</a>
<a href="https://ziglang.org/documentation/master/#Style-Guide">https://ziglang.org/documentation/master/#Style-Guide</a>
<a href="https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig">https://github.com/ziglang/zig/blob/master/lib/std/fmt.zig</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org7295f98" class="outline-3">
<h3 id="org7295f98"><span class="section-number-3">2.4.</span> Zig version manager</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Using ZIG before 1.0 might require you to often switch between master and the last official release.
</p>

<p>
One solution would be to install both (or more) versions of ZIG and switch the PATH environment variable to the version you want to use.
</p>

<p>
But the best solution is to use the ZIG version manager, which is a tool that allows you to install and switch between different versions of ZIG.
</p>

<p>
We recommend using ZVM (Zig Version Manager ^^) which is a simple and easy to use tool. (<a href="https://github.com/tristanisham/zvm">https://github.com/tristanisham/zvm</a>)
</p>
</div>

<div id="outline-container-org11ef159" class="outline-4">
<h4 id="org11ef159"><span class="section-number-4">2.4.1.</span> Basic usage</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
Installing the tool:
</p>
<div class="org-src-container">
<pre class="src src-bash">curl https://raw.githubusercontent.com/tristanisham/zvm/master/install.sh | bash
<span style="color: #e090d7;">echo</span> <span style="color: #e9b96e;">"# ZVM"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">ZVM_INSTALL</span>=<span style="color: #e9b96e;">"$HOME/.zvm/self"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">PATH</span>=<span style="color: #e9b96e;">"$PATH:$HOME/.zvm/bin"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
<span style="color: #e090d7;">echo</span> export <span style="color: #fcaf3e;">PATH</span>=<span style="color: #e9b96e;">"$PATH:$ZVM_INSTALL/"</span> &gt;&gt; $<span style="color: #fcaf3e;">HOME</span>/.profile
</pre>
</div>

<p>
Listing all the versions available to download:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm ls --all
</pre>
</div>

<p>
Downloading a specific version:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm i master
</pre>
</div>

<p>
Display all your downloaded versions:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm ls
</pre>
</div>

<p>
Use one of those versions:
</p>
<div class="org-src-container">
<pre class="src src-bash">zvm use master
</pre>
</div>

<p>
There are other commands available, you can check them by running: 'zvm help' or checking the repository: <a href="https://github.com/tristanisham/zvm">https://github.com/tristanisham/zvm</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org02fa5bc" class="outline-3">
<h3 id="org02fa5bc"><span class="section-number-3">2.5.</span> defer</h3>
<div class="outline-text-3" id="text-2-5">
<p>
If you are coming from the C world, this keyword might surprise you and greatly impact your life, if you already know it from other languages like Go, bear with us to see how it is particulary useful in a language that has to manage its own memory.
</p>

<p>
`defer` is a really simple keyword all it does is: <b>execute code at the end of the current scope</b>.
</p>

<p>
Might not sound like much, because you might think "I could just put it at the of my scope", you are not entirely wrong but:
</p>
<ul class="org-ul">
<li>Doing so makes your code less readable/understandable, because you have to scroll to the end of the function to find the code you might need that is related something hundred of lines above.</li>
<li>Humans are error proned and sometimes forget, by instantly adding a defer after the related code you can be sure not to forget it later.</li>
</ul>

<p>
TODO mettre un lien vers errors/errdefer
</p>
</div>

<div id="outline-container-org2ae8ccb" class="outline-4">
<h4 id="org2ae8ccb"><span class="section-number-4">2.5.1.</span> Exemple</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Here is an exemple where `defer` really shines:
</p>
</div>
</div>

<div id="outline-container-org47b5ce1" class="outline-4">
<h4 id="org47b5ce1"><span class="section-number-4">2.5.2.</span> Freeing memory</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
In the following code, the programmer forgot to free the memory assigned to ptr<sub>cool</sub><sub>number</sub> by calling <b>destroy</b>. Memeory leaks like that could be hard to find in a large codebase because you would have to check every single allocation and find its corresponding free somewhere in the code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"we sometime forget to free memory"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.testing.allocator; <span style="color: #73d216;">// </span><span style="color: #73d216;">Allocator that detect memory leaks</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">bytes</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u64</span>, 10);

    <span style="color: #b4fa70;">for</span> (0..9) |i| {
        bytes[i] = i;
    }

    <span style="color: #73d216;">// </span><span style="color: #73d216;">BLA BLA BLA lot of code normally here :)</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ptr_cool_number</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u64</span>);
    ptr_cool_number.* = bytes[2];

    <span style="color: #73d216;">//</span><span style="color: #73d216;">allocator.destroy(ptr_cool_number);</span>
    allocator.free(bytes);
}
</pre>
</div>

<p>
But this could be better by using the <b>defer</b> keyword and writing the dealloaction code right after the allocation one. This way if you have a memory leak, you just have to see everywhere you allocated and be sure there is a deallocation next to it.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"and sometimes we just use defer and life is better"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.testing.allocator; <span style="color: #73d216;">// </span><span style="color: #73d216;">Allocator that detect memory leaks</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">bytes</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u64</span>, 10);
    <span style="color: #b4fa70;">defer</span> allocator.free(bytes);

    <span style="color: #b4fa70;">for</span> (0..9) |i| {
        bytes[i] = i;
    }

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ptr_cool_number</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u64</span>);
    <span style="color: #b4fa70;">defer</span> allocator.destroy(ptr_cool_number);

    ptr_cool_number.* = bytes[2];
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org327d2a5" class="outline-3">
<h3 id="org327d2a5"><span class="section-number-3">2.6.</span> Testing code</h3>
<div class="outline-text-3" id="text-2-6">
<p>
## Tracking
### Race conditions
</p>

<p>
### Memory leak
#### C allocations
For high performances and very few safety checks, you might want to use the <a href="https://ziglang.org/documentation/master/std/#std.heap.c_allocator">std.heap.c<sub>allocator</sub></a>.
</p>

<p>
Those allocations are not tracked by the Zig runtime, so you will have to use a tool like Valgrind to track memory leaks which can be done via the <a href="https://ziglang.org/documentation/master/std/#std.valgrind">std</a>.
</p>

<p>
TODO exemple, j attends d avoir eu le cours de HPC sur valgrind
</p>

<p>
#### Zig allocations
The General Purpose Allocator (GPA) is a general-purpose memory allocator that is used by the Zig standard library. Its advantages over the other implementations in the std it that it is designed for safety over performance.
</p>

<p>
Note that all those problems are given to us a runtime and not compile time.
</p>

<p>
It can in fact detect memory problems like:
</p>
<ul class="org-ul">
<li>memory leaks</li>
<li>use-after-free</li>
<li>double-free</li>
</ul>

<p>
But it cannot yet detect things like data races (which you could think it could with the <b>.thread<sub>safe</sub></b> option).
</p>

<p>
What <b>.thread<sub>safe</sub></b> does is that it makes the allocator thread-safe, meaning that it can be used in a multi-threaded environment without any problem. If you don't and use the same allocator for multiples threads, the allocator might not behave correctly.
</p>

<p>
You can have more informations on the topic following a discussion I had on the Zig discord server <a href="https://discord.com/channels/605571803288698900/1237126868927512718">here</a>.
</p>

<p>
#### Memory leaks
In the exemple below, the memory allocated to <b>a</b> is freed (with <b>destroy</b> here), if you were to comment the <b>destroy</b> line, the GPA would detect a memory leak and tell you what memory leaked giving a stacktrace and the memory address of the leaked memory.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">status</span> = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

    <span style="color: #b4fa70;">if</span> (status == .leak) {
        std.debug.print(<span style="color: #e9b96e;">"Memory leak detected\n"</span>, .{});
    } <span style="color: #b4fa70;">else</span> {
        std.debug.print(<span style="color: #e9b96e;">"No memory leak detected\n"</span>, .{});
    }
}
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>
</pre>
</div>

<p>
#### Use after free
Following the previous exemple we are going to try to access the memory after it has been freed, this will result in a use-after-free error.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> _ = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>

a.* = 4; <span style="color: #73d216;">// </span><span style="color: #73d216;">USE AFTER FREE</span>
</pre>
</div>

<p>
#### Invalid free
By still keeping the previous exemples, we are going to double free and get an error.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{ .safety = <span style="color: #e9b2e3;">true</span> }){};
<span style="color: #b4fa70;">defer</span> _ = gpa.deinit(); <span style="color: #73d216;">// </span><span style="color: #73d216;">deinit is going to detect memory leaks, calls gpa.detectLeaks() under the hood</span>

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span> = <span style="color: #b4fa70;">try</span> allocator.create(<span style="color: #8cc4ff;">u8</span>);
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">Memory freed</span>
allocator.destroy(a); <span style="color: #73d216;">// </span><span style="color: #73d216;">DOUBLE FREE</span>
</pre>
</div>

<p>
### Sources 
</p>
<ul class="org-ul">
<li><a href="https://discord.com/channels/605571803288698900/1235733415886721064">https://discord.com/channels/605571803288698900/1235733415886721064</a></li>
<li><a href="https://zig.guide/standard-library/allocators">https://zig.guide/standard-library/allocators</a></li>
</ul>
</div>
</div>

<div id="outline-container-org5d33927" class="outline-3">
<h3 id="org5d33927"><span class="section-number-3">2.7.</span> Compiler messages</h3>
<div class="outline-text-3" id="text-2-7">
<p>
In a language that aims to report most of its issues at compilation time, it is important to have clear and concise error messages. However at the time we are writing this it is sadly not the case. Here are a few compiler messages that you might encounter that are very hard to understand:
</p>
</div>

<div id="outline-container-orgd2528cb" class="outline-4">
<h4 id="orgd2528cb"><span class="section-number-4">2.7.1.</span> Trying to print without the correct struct syntax</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
We are going to start with the most basic one, everyone doing Zig did at least one time
</p>
<div class="org-src-container">
<pre class="src src-zig">std.debug.print(<span style="color: #e9b96e;">"Hello I am {} years old"</span>, 12);
</pre>
</div>

<pre class="example" id="org26aa998">
/home/tetratrux/.zvm/0.11.0/lib/std/fmt.zig:87:9: error: expected tuple or struct argument, found comptime_int
        @compileError("expected tuple or struct argument, found " ++ @typeName(ArgsType));
</pre>

<p>
Is the type of error you should get, from reading that we cant even know from where the problem is in our code, no line number, no stacktrace, nothing.
</p>

<p>
But if you read the message carefully and you know that <a href="https://ziglang.org/documentation/master/std/#std.debug.print">print</a> second argument except a struct with the <b>.{}</b> syntax, you realize that you passed a value with the wrong type.
</p>

<p>
So when you get that type of error message make sure that you are printing your message correctly with the second argument that should be a struct with the <b>.{}</b> syntax.
</p>

<div class="org-src-container">
<pre class="src src-zig">std.debug.print(<span style="color: #e9b96e;">"Hello I am {} years old"</span>, .{12});
</pre>
</div>

<p>
This is an <a href="https://github.com/ziglang/zig/issues/19158">ongoing issue</a> by the time I am writing this in 0.12.0
</p>
</div>
</div>
</div>

<div id="outline-container-orgd8309e9" class="outline-3">
<h3 id="orgd8309e9"><span class="section-number-3">2.8.</span> TCP stream</h3>
<div class="outline-text-3" id="text-2-8">
</div>
<div id="outline-container-orgde9ee5a" class="outline-4">
<h4 id="orgde9ee5a"><span class="section-number-4">2.8.1.</span> <span class="todo TODO">TODO</span> How Zig manages stream</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
Does Zig manage tcp stream with the OS stream or has it created its own implementation ?
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgafc8638" class="outline-2">
<h2 id="orgafc8638"><span class="section-number-2">3.</span> Comptime</h2>
<div class="outline-text-2" id="text-3">
<p>
Zig has a concept called <code>comptime</code>, it's stands for "compile-time".
Comptime is used to evaluate an expression at compile time and not at runtime.
In comparison with C, Zig comptime has the purpose of replacing marco with a more explicit syntax.
In fact, C's macro tends to be error-prone when using it.
The advantage of using comptime over macro is the type safety of Zig when writing comptime.
</p>
</div>

<div id="outline-container-orgd3dcd9e" class="outline-3">
<h3 id="orgd3dcd9e"><span class="section-number-3">3.1.</span> When to use and when NOT to use it</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgb1003b2" class="outline-4">
<h4 id="orgb1003b2"><span class="section-number-4">3.1.1.</span> When to use it</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Because the compiler can now do things at compilation time, leaving less work to be done at runtime. (if the compiler gives you the power to do things at compile time so easily, you should use it ^^)
</p>

<p>
So you should basically try to use it as much as you can.
</p>
</div>
</div>

<div id="outline-container-org72ac8bb" class="outline-4">
<h4 id="org72ac8bb"><span class="section-number-4">3.1.2.</span> When NOT to use it (source: ziglings)</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
The following contexts are already IMPLICITLY evaluated at
compile time, and adding the 'comptime' keyword would be
superfluous, redundant, and smelly:
</p>

<ul class="org-ul">
<li>The container-level scope (outside of any function in a source file)</li>
<li>Type declarations of:
<ul class="org-ul">
<li>Variables</li>
<li>Functions (types of parameters and return values)</li>
<li>Structs</li>
<li>Unions</li>
<li>Enums</li>
</ul></li>
<li>The test expressions in inline for and while loops</li>
<li>An expression passed to the @cImport() builtin</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org57bace2" class="outline-3">
<h3 id="org57bace2"><span class="section-number-3">3.2.</span> Compile-time evaluation</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org2f5b366" class="outline-4">
<h4 id="org2f5b366"><span class="section-number-4">3.2.1.</span> Compile-time variable</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
In Zig, there are variables that can be evaluated at compile-time, in fact, Zig allows computing mutating variables at compile-time but all the inputs need to be known also at compile-time.
If not, the compiler will throw a compile error. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
For a mutating variable at compile-time, Zig requires naming the variables with a <code>comptime var</code>.
But if the variable is a constant, the compiler requires to use a <code>const</code>. 
</p>

<p>
Like in the example below, the variable named <code>variableAtCompileTime</code> is evaluated at compile-time because all the inputs are known.
On the other hand, the variable named <code>constantAtRuntime</code> cannot be a comptime variable because its dependency is based on unknown before runtime.
</p>

<p>
Moreover, in the example, the <code>inline for</code> is used to unroll the for loop.
This allows to use for loops in comptime indeed, if a standard for loop is used, it will cause an error because the capture value will be evaluated at runtime.<a href="#citeproc_bib_item_1">[1]</a> 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">randVariable</span> = std.crypto.random.float(<span style="color: #8cc4ff;">f32</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">selectedConstant</span> = 6;

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">constantAtRuntime</span> = randVariable * selectedConstant;

<span style="color: #b4fa70;">comptime</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">variableAtCompileTime</span> = selectedConstant * selectedConstant;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">array</span> = [_]<span style="color: #8cc4ff;">comptime_int</span> { 3, 2, 1};

<span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (array) |item| {
    variableAtCompileTime += item;
}

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"constant-at-runtime {d:.2}\n"</span>, .{constantAtRuntime});
<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"variable-at-compile-time  {d}"</span>, .{variableAtCompileTime});

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">constant-at-runtime</td>
<td class="org-right">4.33</td>
</tr>

<tr>
<td class="org-left">variable-at-compile-time</td>
<td class="org-right">42</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge330892" class="outline-4">
<h4 id="orge330892"><span class="section-number-4">3.2.2.</span> Compile-time expression</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
In Zig, an expression can have a <code>comptime</code> to tell the compiler to evaluate the expression at compile-time.
Like a compile-time variable, if an expression cannot be evaluated at compile-time, a compile-time error will be thrown.
</p>

<p>
With a prefixed <code>comptime</code> keyword Zig can interpret a function at compile-time instead of runtime. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
A good example of demonstrating comptime expression is in the standard documentation <a href="#citeproc_bib_item_1">[1]</a>.
The results show that the comptime expression is faster than the runtime one when the code is executed (runtime) because the work has already been done.
But this will work only with code that hasn't runtime dependency code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Timer</span> = std.time.Timer;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">fib</span>(<span style="color: #fcaf3e;">iteration</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">if</span> (iteration &lt; 2) <span style="color: #b4fa70;">return</span> iteration;

    <span style="color: #b4fa70;">return</span> fib(iteration - 1) + fib(iteration - 2);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"comptime fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">comptime</span> fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-comptime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(610, result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">result</span> = fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-runtime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expect(610 == result);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-org1cc9f36" class="outline-4">
<h4 id="org1cc9f36"><span class="section-number-4">3.2.3.</span> Compile-time parameter</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
Zig implements generic by using duck typing at compile-time.
To use generic, Zig needs to know the type at compile-time.
</p>
<div class="org-src-container">
<pre class="src src-zig">
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">greater</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">array</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">T</span>) !?T {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">max</span>: ?<span style="color: #8cc4ff;">T</span> = <span style="color: #e9b2e3;">null</span>;
    <span style="color: #b4fa70;">for</span> (array) |item| {
        <span style="color: #b4fa70;">if</span> (max) |m| {
            <span style="color: #b4fa70;">if</span> (m &lt; item) {
                max = item;
            }
        } <span style="color: #b4fa70;">else</span> {
            max = item;
        }
    }
    <span style="color: #b4fa70;">return</span> max;
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an i32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intArray</span> = [_]<span style="color: #8cc4ff;">i32</span>{ 2, 9, 4, 6, 7, 1};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">i32</span>, &amp;intArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 9);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an f32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">floatArray</span> = [_]<span style="color: #8cc4ff;">f32</span>{ 2.34, 14.55, 4.12, 6.876, 7.111 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">f32</span>, &amp;floatArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 14.55);
}


</pre>
</div>

<p>
But with duck typing, if the same method is used, an error will be thrown at compile time:
</p>
<div class="org-src-container">
<pre class="src src-Zig">test "should fail with bool" {
    const boolArray = [_]bool{ true, false, true, true };
    const result = greater(bool, &amp;boolArray);
}
</pre>
</div>

<p>
The error will be:
</p>
<pre class="example" id="org678f05c">
error: operator &lt; not allowed for type 'bool'
</pre>

<p>
Moreover, comptime can also be used as a type definition.
For this, the function needs to return a <code>type</code>.
The example below is based on <a href="https://zig.guide/language-basics/comptime">the zig guide</a> <a href="#citeproc_bib_item_2">[2]</a>, it's shows that it can define a new type with a function.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">width</span>: <span style="color: #8cc4ff;">comptime_int</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">height</span>: <span style="color: #8cc4ff;">comptime_int</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> [height][width]T;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix3x3</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> Matrix(T, 3, 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a type"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix(<span style="color: #8cc4ff;">f32</span>, 4, 4) == [4][4]<span style="color: #8cc4ff;">f32</span>);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a 3x3 matrix"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix3x3(<span style="color: #8cc4ff;">f32</span>) == [3][3]<span style="color: #8cc4ff;">f32</span>);
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf68d155" class="outline-3">
<h3 id="orgf68d155"><span class="section-number-3">3.3.</span> Metaprogramming</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-org9a4dc60" class="outline-4">
<h4 id="org9a4dc60"><span class="section-number-4">3.3.1.</span> <code>@TypeOf</code></h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
The <code>@TypeOf</code> builtin function can be used to take as a parameter an expression and return a type.
</p>
</div>
</div>

<div id="outline-container-org475f20f" class="outline-4">
<h4 id="org475f20f"><span class="section-number-4">3.3.2.</span> <code>@typeInfo</code></h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
This built-in function provides type reflection, it returns information on type.
</p>

<p>
See the example <code>Example with a custom CSV writer based on type</code> to have a view of the usability.
</p>
</div>
</div>
</div>

<div id="outline-container-orga464edc" class="outline-3">
<h3 id="orga464edc"><span class="section-number-3">3.4.</span> <span class="todo TODO">TODO</span> Optimization</h3>
<div class="outline-text-3" id="text-3-4">
<p>
inline for / while
</p>
</div>

<div id="outline-container-org17c1d3a" class="outline-4">
<h4 id="org17c1d3a"><span class="section-number-4">3.4.1.</span> How log works in Zig</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
In the C language, a common use to use debug print is with Marco.
Like in this example, if the <code>DEBUG</code> is defined to <code>1</code> the code will print the debug info.
If the <code>DEBUG</code> is not set, at the compilation, all the print information will be removed.
</p>
<div class="org-src-container">
<pre class="src src-C">
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">DEBUG</span> 1

<span style="color: #e090d7;">#if</span> DEBUG 
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>) <span style="color: #8cc4ff;">printf</span> <span style="color: #fcaf3e;">x</span>;
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>)
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  TRACE((<span style="color: #e9b96e;">"Hello World! : %d\n"</span>, 12));
}
</pre>
</div>

<p>
In Zig, logging uses this same principle, a message level is set at the start of the program (at compile-time) and if the log is not enabled, all the code about the print is removed.
However, if the log level is greater than the limit, the message will be printed.
</p>

<p>
The code below shows an extract of the standard library for logging.
</p>
<div class="org-src-container">
<pre class="src src-zig"> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">log</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">message_level</span>: <span style="color: #8cc4ff;">Level</span>,
    <span style="color: #b4fa70;">comptime</span> scope: <span style="color: #e090d7;">@Type</span>(.EnumLiteral),
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">format</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">args</span>: <span style="color: #8cc4ff;">anytype</span>,
) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">comptime</span> !logEnabled(message_level, scope)) <span style="color: #b4fa70;">return</span>;

    std.options.logFn(message_level, scope, format, args);
}
</pre>
</div>

<p>
In addition, Zig provides some helper functions for logging, such as :
</p>
<ul class="org-ul">
<li><code>std.log.debug</code></li>
<li><code>std.log.info</code></li>
<li><code>std.log.warn</code></li>
<li><code>std.log.err</code></li>
</ul>

<p>
And if the release mode is set to <code>Debug</code>, the debug log will be printed.
But if the release mode is set to <code>Release*</code>, the debug log will not print, there is no need to configure the logging to have this behavior.
</p>
</div>
</div>
</div>

<div id="outline-container-org2632b24" class="outline-3">
<h3 id="org2632b24"><span class="section-number-3">3.5.</span> Generic data structures</h3>
<div class="outline-text-3" id="text-3-5">
<p>
To create a generic data structure, the same pattern is used as a comptime parameter.
A function needs to return an anonymous struct as a type <code>type</code>.
</p>

<p>
In a generic data structure, the <code>@This()</code> is used to get the type of the data structure because it is anonymous.
</p>

<p>
Moreover, a generic data structure can have two type of function:
</p>
<ol class="org-ol">
<li>a function that can be called on the structure type</li>
<li>a function that can be called on the instance of the structure.</li>
</ol>

<p>
To have an instance function, the first argument needs to be a parameter of the type of the struct.
That's why a constant <code>Self</code> is used with <code>@This()</code>.
And after that, the parameter <code>self</code> can be used to get the members of the struct.
</p>

<p>
The example shows the difference between a function that can be called on a struct and a function that can be called on an instance of a struct.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">structFunction</span>(<span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structFunction\n"</span>, .{});
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">instanceFunction</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structInstance: {d}\n"</span>, .{self.myNumber});
        }
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

    <span style="color: #b4fa70;">try</span> MyStruct(<span style="color: #8cc4ff;">f32</span>).structFunction(stdout);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = MyStruct(<span style="color: #8cc4ff;">f32</span>){
        .myNumber = 42,
    };

    <span style="color: #b4fa70;">try</span> myStruct.instanceFunction(stdout);
}

</pre>
</div>

<p>
In Zig, a structure name can be explicitly given or Zig can infer the name of a struct when there are created:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure name is infered</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct1</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>) {
        .myNumber = 42,
    };
    _ = myStruct1;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure has a explicit name</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intStruct</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct2</span> =  intStruct {
        .myNumber = 42,
    };
    _ = myStruct2;
}
</pre>
</div>

<p>
Here's an compete example of an generic linked list :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">LinkedList</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Node</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">data</span>: <span style="color: #8cc4ff;">T</span>,
            <span style="color: #fcaf3e;">prev</span>: ?*<span style="color: #8cc4ff;">Node</span>,
            <span style="color: #fcaf3e;">next</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        };

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">LinkedListError</span> = <span style="color: #b4fa70;">error</span>{headNull};
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();
        <span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator,
        <span style="color: #fcaf3e;">head</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        <span style="color: #fcaf3e;">len</span>: <span style="color: #8cc4ff;">u32</span> = 0,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .head = <span style="color: #e9b2e3;">null</span>,
                .allocator = allocator,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>) <span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">curr</span> = self.head;

            <span style="color: #b4fa70;">while</span> (curr) |currNotNull| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">node</span> = currNotNull;
                curr = currNotNull.next;
                self.allocator.destroy(node);
            }
            self.len = 0;
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">push</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">node</span> = <span style="color: #b4fa70;">try</span> self.allocator.create(Node);
            node.*.data = value;
            self.len += 1;

            <span style="color: #b4fa70;">if</span> (self.head) |head| {
                node.next = head;
                head.prev = node;
                self.head = node;
            } <span style="color: #b4fa70;">else</span> {
                self.head = node;
                node.*.next = <span style="color: #e9b2e3;">null</span>;
                node.*.prev = <span style="color: #e9b2e3;">null</span>;
            }
        }
    };
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a i32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 42;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a f32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">f32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 3.1415;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org593c55a" class="outline-3">
<h3 id="org593c55a"><span class="section-number-3">3.6.</span> Example with a custom CSV writer based on type</h3>
<div class="outline-text-3" id="text-3-6">
<p>
This example shows that Zig has a type reflection with the keyword <code>@typeInfo</code>.
The goal of this example is to create CSV output with a generic struct as input.
Only with the <code>try csv.stringify(&amp;arrayList, stream.writer());</code> function the <code>CsvWriter</code> can infer at comptime the struct pass as argument.
For this example, a basic struct named <code>Person</code> will be transformed to CSV.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">CsvWriter</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">separator</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b96e;">','</span>,
        };
        <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .config = config,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">stringify</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">arrayList</span>: *<span style="color: #8cc4ff;">std</span>.ArrayList(T), <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writeHeader(self, &amp;writer);
            <span style="color: #b4fa70;">for</span> (arrayList.items) |item| {
                <span style="color: #b4fa70;">try</span> writeType(self, item, &amp;writer);
            }
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeHeader</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{field.name});
                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeType</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">item</span>: <span style="color: #8cc4ff;">T</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">if</span> (<span style="color: #e090d7;">@TypeOf</span>(fields) != []<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span>.builtin.Type.StructField)
                <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"The type is not the a struct"</span>);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span> = <span style="color: #e090d7;">@field</span>(item, field.name);

                <span style="color: #b4fa70;">switch</span> (<span style="color: #e090d7;">@typeInfo</span>(<span style="color: #e090d7;">@TypeOf</span>(f))) {
                    .Int =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Float =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Pointer =&gt; |pointer| {
                        <span style="color: #b4fa70;">if</span> (pointer.size == std.builtin.Type.Pointer.Size.Slice <span style="color: #b4fa70;">and</span> pointer.child == <span style="color: #8cc4ff;">u8</span>) {
                            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{f});
                        } <span style="color: #b4fa70;">else</span> {
                            <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>);
                        }
                    },
                    <span style="color: #b4fa70;">else</span> =&gt; <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>),
                }

                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }
    };
}

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Person</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">sexe</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">date</span>: <span style="color: #8cc4ff;">u32</span>,
};


<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person1</span> = .{ .sexe = <span style="color: #e9b96e;">"M"</span>, .name = <span style="color: #e9b96e;">"Lucas"</span>, .date = 2000 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person2</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Ava"</span>, .date = 2020 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person3</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Sophia"</span>, .date = 1989 };

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arrayList</span> = std.ArrayList(Person).init(gpa.allocator());
    <span style="color: #b4fa70;">defer</span> arrayList.deinit();

    <span style="color: #b4fa70;">try</span> arrayList.append(person1);
    <span style="color: #b4fa70;">try</span> arrayList.append(person2);
    <span style="color: #b4fa70;">try</span> arrayList.append(person3);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">stream</span> = std.io.fixedBufferStream(buffer[0..]);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">personCsvWriter</span> = CsvWriter(Person);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">csv</span> = personCsvWriter.init(.{ .separator = <span style="color: #e9b96e;">' '</span> });
    <span style="color: #b4fa70;">try</span> csv.stringify(&amp;arrayList, stream.writer());

    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"{s}"</span>, .{stream.getWritten()});

}

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sexe</td>
<td class="org-left">name</td>
<td class="org-right">date</td>
</tr>

<tr>
<td class="org-left">M</td>
<td class="org-left">Lucas</td>
<td class="org-right">2000</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Ava</td>
<td class="org-right">2020</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Sophia</td>
<td class="org-right">1989</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdd0bb46" class="outline-3">
<h3 id="orgdd0bb46"><span class="section-number-3">3.7.</span> Bonus</h3>
<div class="outline-text-3" id="text-3-7">
<p>
Here is a very nice blog written by a core member of the ZIG community if you want to dig further: <a href="https://kristoff.it/blog/what-is-zig-comptime/">https://kristoff.it/blog/what-is-zig-comptime/</a>
</p>

<p>
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</p>
</div>
</div>
</div>
<div id="outline-container-orgd875481" class="outline-2">
<h2 id="orgd875481"><span class="section-number-2">4.</span> Zig and C</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org5c3054a" class="outline-3">
<h3 id="org5c3054a"><span class="section-number-3">4.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The interoperability between Zig and C is one of the most important feature of Zig. But why ?
</p>

<p>
It is one of the main goal of Zig to <a href="https://ziglang.org/">incrementally improve your C/C++/Zig codebase</a>, so you could use C code almost as much as easy as you could use Zig code.
</p>

<p>
It allows to have both of a <b>modern</b> language and a <b>mature</b> ecosystem.
</p>
</div>
</div>

<div id="outline-container-orga84afd9" class="outline-3">
<h3 id="orga84afd9"><span class="section-number-3">4.2.</span> Main differences between Zig and C in the syntax</h3>
<div class="outline-text-3" id="text-4-2">
<p>
There are a few main differences between the 2 languages that you have high chance of encountering but obviously not all of them are listed here.
</p>
</div>

<div id="outline-container-orgd91e9ca" class="outline-4">
<h4 id="orgd91e9ca"><span class="section-number-4">4.2.1.</span> Types</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Here you can find all the primitive types in Zig and their C equivalent:
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Primitive-Types">https://ziglang.org/documentation/master/#Primitive-Types</a>
</p>

<p>
<a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a>
</p>

<p>
TODO would it be better if i do the array in the doc rather than having a link to it ?
</p>
</div>
</div>

<div id="outline-container-orgf7538db" class="outline-4">
<h4 id="orgf7538db"><span class="section-number-4">4.2.2.</span> Loops</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
In Zig, the for loop is not used as much as in C. 
Instead, the while loop is used more often. The for loop is used when iterating over multiples elements of a container (typically slices or arrays), so it basically is a kind of foreach loop. In all the other cases the while loop is used.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">items</span> = [_]<span style="color: #8cc4ff;">u16</span> { 1, 4, 0, 1 };
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">sum</span>: <span style="color: #8cc4ff;">u16</span> = 0;
<span style="color: #b4fa70;">for</span> (items) |value| {
    sum += value;
}
std.debug.print(<span style="color: #e9b96e;">"Sum: {}\n"</span>, .{sum});
</pre>
</div>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">for</span> (0..3) |i| {
    i += 1;
    std.debug.print(<span style="color: #e9b96e;">"i: {}\n"</span>, .{i});
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6de5871" class="outline-4">
<h4 id="org6de5871"><span class="section-number-4">4.2.3.</span> Pointers</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
Zig has 2 different pointers:
</p>
<ul class="org-ul">
<li>Single-item pointers: *T</li>
<li>Many-item pointers: [*]T</li>
</ul>
<p>
Which can both be optional by adding a "?".
</p>

<p>
But actually&#x2026;. there is a third pointer type:
</p>
<ul class="org-ul">
<li>The C pointer: [*c]T</li>
</ul>
<p>
This one is to be avoided as much as possible. The only reasons for its existence is for the translation from C code to Zig code, when the translater is not able to know what to convert it to in Zig (eg. sometimes it does not know if it can convert it to a non-optional pointer or not which could cause UBs).
</p>
</div>
</div>

<div id="outline-container-orgee8d0ba" class="outline-4">
<h4 id="orgee8d0ba"><span class="section-number-4">4.2.4.</span> Type conversions</h4>
<div class="outline-text-4" id="text-4-2-4">
<p>
Since in Zig there is no implicit conversions, depending on the project you might end up having "ugly" code with a lot of explicit type conversions. The code is more verbose but it is also less error-prone.
Exemple:
ZIG:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">rgb_to_grayscale_1d</span>(<span style="color: #fcaf3e;">img</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t, <span style="color: #fcaf3e;">result</span>: *<span style="color: #8cc4ff;">imageh</span>.img_1D_t) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.height * img.width))) : (i += 1) {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">index</span> = i * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@intCast</span>(img.components));
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">grayscale_value</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e090d7;">@intFromFloat</span>(imageh.FACTOR_R * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.R_OFFSET + index])) +
            imageh.FACTOR_G * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.G_OFFSET + index])) +
            imageh.FACTOR_B * <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">f64</span>, <span style="color: #e090d7;">@floatFromInt</span>(img.data[imageh.B_OFFSET + index])));
        result.data[i] = grayscale_value;
    }
}
</pre>
</div>
<p>
C:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">rgb_to_grayscale_1D</span>(<span style="color: #b4fa70;">const</span> <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">img</span>, <span style="color: #b4fa70;">struct</span> <span style="color: #8cc4ff;">img_1D_t</span> *<span style="color: #fcaf3e;">result</span>) {
  printf(<span style="color: #e9b96e;">"height: %d"</span>, img-&gt;height);
  <span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">size_t</span> <span style="color: #fcaf3e;">i</span> = 0; i &lt; img-&gt;height * img-&gt;width; i++) {
    <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">index</span> = i * img-&gt;components;
    <span style="color: #8cc4ff;">uint8_t</span> <span style="color: #fcaf3e;">grayscale_value</span> = (<span style="color: #8cc4ff;">uint8_t</span>)(FACTOR_R * img-&gt;data[R_OFFSET] +
                                        FACTOR_G * img-&gt;data[G_OFFSET] +
                                        FACTOR_B * img-&gt;data[B_OFFSET]);
    result-&gt;data[i] = grayscale_value;
  }
}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org313dd7a" class="outline-3">
<h3 id="org313dd7a"><span class="section-number-3">4.3.</span> How to call a C function from Zig</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Add those lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addIncludePath(.{ .path = <span style="color: #e9b96e;">"c-src"</span> }); <span style="color: #73d216;">// </span><span style="color: #73d216;">Folder containing the C files</span>
exe.linkLibC(); <span style="color: #73d216;">// </span><span style="color: #73d216;">Link the C standard library (which is zig own libc btw)</span>
</pre>
</div>

<p>
Then you can call the C functions like this from your Zig code:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c_hello</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"hello.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    c_hello.hello();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">res</span> = c_hello.add(1, 2);
    std.debug.print(<span style="color: #e9b96e;">"1 + 2 = {d}\n"</span>, .{res});
}
</pre>
</div>
<p>
Note that you can only do 1 @cImport per project. So what i recommend you to do is create a file containing all the c libraries you need in a file like so:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdio.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"stdlib.h"</span>);
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"image.h"</span>);
});
</pre>
</div>
<p>
Then call this zig file in your other zig files.
</p>
</div>
</div>

<div id="outline-container-org10acc4e" class="outline-3">
<h3 id="org10acc4e"><span class="section-number-3">4.4.</span> How to call a Zig function from C / Continuing a C project with Zig</h3>
<div class="outline-text-3" id="text-4-4">
<p>
You can continue your C project without using Clang or GCC but by using Zig with all its toolchain it comes with.
</p>

<p>
In order to have a c file (main.c) as the entry point of your project using the zig build tool you have to add/comment the following lines to your build.zig file:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">exe</span> = b.addExecutable(.{
    .name = <span style="color: #e9b96e;">"c_project"</span>,
    <span style="color: #73d216;">// </span><span style="color: #73d216;">.root_source_file = b.path("src/main.zig"),</span>
    .target = target,
    .optimize = optimize,
});
exe.root_module.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"src/main.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
exe.linkLibC();
</pre>
</div>

<p>
If you want to have more C files than just main.c you can add them like so:
</p>
<div class="org-src-container">
<pre class="src src-zig">exe.addCSourceFile(.{ .file = .{ .path = <span style="color: #e9b96e;">"c-src/image.c"</span> }, .flags = &amp;.{<span style="color: #e9b96e;">"-std=c99"</span>} });
</pre>
</div>

<p>
TODO utiliser code zig dans project C <a href="https://zig.guide/working-with-c/calling-conventions">https://zig.guide/working-with-c/calling-conventions</a>
</p>
</div>

<div id="outline-container-org1801357" class="outline-4">
<h4 id="org1801357"><span class="section-number-4">4.4.1.</span> export and extern keywords</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
<b>export</b> make the the function visible from outside so that the C ABI can see it.
</p>

<p>
<b>extern</b> is used to link against an exported variable from an other object.
</p>

<p>
<a href="https://ziglang.org/documentation/master/#Variables">Zig documentation for those 2 keywords.</a>
</p>

<p>
TODO jai oublie d ajouter du code zig, ne pas oublier export/extern
</p>

<p>
TODO pros and cons of using zig toolchain instead of clang or gcc
</p>
</div>
</div>
</div>

<div id="outline-container-org59f33c2" class="outline-3">
<h3 id="org59f33c2"><span class="section-number-3">4.5.</span> How is it done under the hood</h3>
<div class="outline-text-3" id="text-4-5">
<p>
When you do @cImport(@cInclude("foo.h")) in your zig code it runs translate-c and exposes the function and type definitions.
</p>

<p>
TODO talk about C ABI
</p>
</div>
</div>

<div id="outline-container-orgc588ad0" class="outline-3">
<h3 id="orgc588ad0"><span class="section-number-3">4.6.</span> Util to translate C code to Zig</h3>
<div class="outline-text-3" id="text-4-6">
<p>
zig translate-c is an util built in the zig toolchains that allows you to translate C code to Zig code.
You can translate any code but the code is going to be UNREADABLE, so I would not recommend this tool if you plan on modifying the code afterwards.
You have better time importing the C code in your Zig code.
Note that if you want to translate a C file that uses the libc you have to add the -lc flag like so:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig translate-c main.c -lc
</pre>
</div>
</div>

<div id="outline-container-org832bd4c" class="outline-4">
<h4 id="org832bd4c"><span class="section-number-4">4.6.1.</span> Comparison with other langauges that use C code</h4>
<div class="outline-text-4" id="text-4-6-1">
<p>
To test if integrating C code in Zig projects is really as seemless as some claims, I have decided to compare the C integration with Python aswell.
</p>

<p>
In order to do that I wrote a small C library:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">add</span>(<span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">a</span>, <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">b</span>) { <span style="color: #b4fa70;">return</span> a + b; }
</pre>
</div>

<p>
What I am going to do is test how much time it takes each program to run this function x times. (in this case x = 100'000'000)
</p>

<p>
Note: I didnt use any optimization in flag in python (because it did not change anything) and neither in Zig because I didnt want the compiler to try to optimize the code and be lazy.
</p>

<p>
Then in order to compare the 2 languages I wrote 4 programs:
</p>
<ul class="org-ul">
<li>Zig code that has and add function implementation in Zig</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">add</span>(<span style="color: #fcaf3e;">a</span>: <span style="color: #8cc4ff;">u32</span>, <span style="color: #fcaf3e;">b</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">return</span> a + b;
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.38sec
</p>

<ul class="org-ul">
<li>Vanilla Python code that has and add function implementation in Python</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">def</span> <span style="color: #fce94f;">add</span>(a, b):
    <span style="color: #b4fa70;">return</span> a + b


<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    add(3, 7)
<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"done!"</span>)
</pre>
</div>
<p>
Result: ~10sec
</p>

<ul class="org-ul">
<li>Zig code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = <span style="color: #e090d7;">@cImport</span>({
    <span style="color: #e090d7;">@cInclude</span>(<span style="color: #e9b96e;">"mylib.c"</span>);
});

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt; 100000000) : (i += 1) {
        _ = c.add(3, 7);
    }
    std.debug.print(<span style="color: #e9b96e;">"done!\n"</span>, .{});
}
</pre>
</div>
<p>
Result: ~0.41sec
</p>

<ul class="org-ul">
<li>Python code that imports the C library</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #b4fa70;">import</span> ctypes

<span style="color: #fcaf3e;">mylib</span> = ctypes.CDLL(<span style="color: #e9b96e;">'./mylib.so'</span>)

mylib.add.<span style="color: #fcaf3e;">argtypes</span> = (ctypes.c_int, ctypes.c_int)
mylib.add.<span style="color: #fcaf3e;">restype</span> = ctypes.c_int

<span style="color: #b4fa70;">for</span> i <span style="color: #b4fa70;">in</span> <span style="color: #e090d7;">range</span>(100000000):
    <span style="color: #fcaf3e;">result</span> = mylib.add(3, 4)

<span style="color: #e090d7;">print</span>(<span style="color: #e9b96e;">"Result of last addition:"</span>, result)
</pre>
</div>
<p>
Result: ~50sec
</p>

<p>
TODO faire un joli graphique quand jaurai d autres languages
TODO idk if it would be possible to compile my c library and then use it in my python code, and all of that all in emacs, that would be cool :)
TODO do with other languages aswell
</p>
</div>

<ol class="org-ol">
<li><a id="org4b869c9"></a>Conclusion<br />
<div class="outline-text-5" id="text-4-6-1-1">
<p>
First thing that we notice immediately is how much faster the Zig code is compared to the Python code. This is not surprising since Zig is a compiled language and Python is an interpreted language.
</p>

<p>
TODO why is python so slow ?
</p>

<p>
The second interesting thing is that the 2 Zig codes dont vary that much (if they even do) compared to the 2 python codes which have a 5x ratio. This is interesting because it shows that the overhead of calling a C function from Zig is not that big (in fact it is even not existent since all the compiler does is translating the C code to Zig code at compilation time).
</p>

<p>
We can conclude that calling C code from Zig is really seemless, because at runtime &#x2026; everything is Zig code.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org84461ee" class="outline-3">
<h3 id="org84461ee"><span class="section-number-3">4.7.</span> Notes</h3>
<div class="outline-text-3" id="text-4-7">
<p>
TODO For some unkown reason yet my LSP becomes very slow when working in a Zig project with C files and sometimes crashes. I have to investigate this further.
</p>

<p>
Sources:
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/master/#C-Pointers">https://ziglang.org/documentation/master/#C-Pointers</a></li>
<li><a href="https://ziglang.org/documentation/master/#C-Type-Primitives">https://ziglang.org/documentation/master/#C-Type-Primitives</a></li>
<li><a href="https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8">https://zig.news/sobeston/using-zig-and-translate-c-to-understand-weird-c-code-4f8</a></li>
<li><a href="https://mtlynch.io/notes/zig-call-c-simple/">https://mtlynch.io/notes/zig-call-c-simple/</a></li>
<li><a href="https://ziglang.org/documentation/master/#cImport-vs-translate-c">https://ziglang.org/documentation/master/#cImport-vs-translate-c</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc71a4fc" class="outline-2">
<h2 id="orgc71a4fc"><span class="section-number-2">5.</span> Compilation - build system</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgb539f4e" class="outline-3">
<h3 id="orgb539f4e"><span class="section-number-3">5.1.</span> <span class="todo TODO">TODO</span> Comptime</h3>
</div>

<div id="outline-container-orgbca9eae" class="outline-3">
<h3 id="orgbca9eae"><span class="section-number-3">5.2.</span> <span class="todo TODO">TODO</span> How to use the build system</h3>
</div>

<div id="outline-container-org83a9f9c" class="outline-3">
<h3 id="org83a9f9c"><span class="section-number-3">5.3.</span> Build modes</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Zig build modes are way easier for beginners to graps compared to <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">C</a>
</p>

<p>
There are only 4 different build modes:
</p>
<ul class="org-ul">
<li>Debug (default)</li>
<li>ReleaseFast</li>
<li>ReleaseSafe</li>
<li>ReleaseSmall</li>
</ul>

<p>
You can check them in more details <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a>
</p>

<p>
There are also a few other options you can tweak like avx <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a>
</p>
</div>

<div id="outline-container-org1f4e940" class="outline-4">
<h4 id="org1f4e940"><span class="section-number-4">5.3.1.</span> <span class="todo TODO">TODO</span> Build steps</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
<a href="https://zig.guide/build-system/build-steps">https://zig.guide/build-system/build-steps</a>
</p>
</div>
</div>

<div id="outline-container-orge54a2a6" class="outline-4">
<h4 id="orge54a2a6"><span class="section-number-4">5.3.2.</span> <span class="todo TODO">TODO</span> Generate automatically documentation</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
In Zig there is an experimental feature, it's automatically generated documentation.
It will scan all the public structures and functions and will create documentation.
Moreover, the comments like <code>///</code> are used to give more information to types.
</p>

<p>
This example is created with the help of the <code>build.zig</code> of the Zig language GitHub repository.
This is used the same way as the Zig teams auto-generate the standard library documentation. See: <a href="https://github.com/ziglang/zig/blob/master/build.zig">build.zig</a>
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">build</span>(<span style="color: #fcaf3e;">b</span>: *<span style="color: #8cc4ff;">std</span>.Build) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">autodoc_test</span> = b.addTest(.{
         .root_source_file = .{ .path = <span style="color: #e9b96e;">"src/main.zig"</span> },
     });
     <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">install_std_docs</span> = b.addInstallDirectory(.{
         .source_dir = autodoc_test.getEmittedDocs(),
         .install_dir = .prefix,
         .install_subdir = <span style="color: #e9b96e;">"doc"</span>,
     });

     <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">doc_step</span> = b.step(<span style="color: #e9b96e;">"docs"</span>, <span style="color: #e9b96e;">"Generate documentation"</span>);
     doc_step.dependOn(&amp;install_std_docs.step);
     doc_step.makeFn = generateDocumentation;
 }

 <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">generateDocumentation</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">std</span>.build.Step, <span style="color: #fcaf3e;">progress</span>: *<span style="color: #8cc4ff;">std</span>.Progress.Node) !<span style="color: #8cc4ff;">void</span> {
     _ = self;
     _ = progress;
     std.log.info(<span style="color: #e9b96e;">"The documentation has been generated"</span>, .{});
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdbeb8e8" class="outline-4">
<h4 id="orgdbeb8e8"><span class="section-number-4">5.3.3.</span> Strip output binary in Zig in Linux</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
<a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">ELF format</a>
In an <code>ELF</code> executable there are various sections that hold program and control information.
For example:
</p>
<ul class="org-ul">
<li><code>.bss</code>: it holds uninitialized variables and data.</li>
<li><code>.text</code>: it holds the instruction of the program</li>
<li><code>.debug</code>: it holds unspecified information for debugging</li>
</ul>

<p>
Removing the debug symbols will reduce his size, make it harder to reverse engineering, and improve speed performance.
</p>

<p>
By default, Zig will produce an executable that has all the debug symbols.
However, Zig has reproduced a drop-in replacement for the program GNU <code>objcopy</code>.
</p>

<p>
To strip an output in the zig command line :
</p>
<div class="org-src-container">
<pre class="src src-sh">zig build-exe -fstrip src/main.zig
</pre>
</div>

<p>
To be sure that the output executable is stripped, the command <code>file</code> can be useful :
</p>
<div class="org-src-container">
<pre class="src src-sh">file main
</pre>
</div>
<p>
And the output : 
</p>
<pre class="example">
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
</pre>

<p>
With the Zig build system (<code>build.zig</code>) there is an option to strip an executable :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">target</span> = b.standardTargetOptions(.{});
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">optimize</span> = b.standardOptimizeOption(.{});

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">exe</span> = b.addExecutable(.{
    .name = <span style="color: #e9b96e;">"linkedlist"</span>,
    .root_source_file = .{ .path = <span style="color: #e9b96e;">"src/main.zig"</span> },
    .target = target,
    .optimize = optimize,
});

exe.strip = <span style="color: #e9b2e3;">true</span>;
</pre>
</div>

<p>
If the option strip is set to false, we have :
</p>
<pre class="example">
$file linkedlist
linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</pre>

<p>
And with the option to <code>true</code> :
</p>
<pre class="example">
$file linkedlist
linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
</pre>
</div>
</div>

<div id="outline-container-org87da537" class="outline-4">
<h4 id="org87da537"><span class="section-number-4">5.3.4.</span> Separate debug symbols from ELF executable</h4>
<div class="outline-text-4" id="text-5-3-4">
<p>
The chapter above shows how to remove all the symbols for the executable directly in the Zig build system.
In this section, the interest is more about the Zig objcopy command.
In fact, Zig has implemented his own <code>objcopy</code> utils to strip, and remove symbols like the objcopy from the bin utils (GNU utils).
(<i>Note: for now, the Zig objcopy has fewer features</i>)
</p>

<p>
The interest in having objcopy directly in Zig is there is no need to have multiple objcopy executables.
Indeed, in a cross-compilation world, each binutil needs to be compatible with the CPU architecture target.
So, it avoids using different toolchains and scripts to build on various targets.
</p>

<p>
Here's how to invoke the help of the Zig build objcopy:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --help
</pre>
</div>

<p>
The following example illustrates several applications of the objcopy command.
First, remove the debug symbols of the executable.
After that, keep only the debug symbols in a separate file.
And finally, how to link the debug symbols file to an executable (that has no debug file).
</p>

<p>
For this example, the output executable of the Zig build toolchain is named <code>main</code>.
</p>
<div class="org-src-container">
<pre class="src src-sh">$<span style="color: #fcaf3e;">file</span> main
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
</pre>
</div>

<p>
The first step is to strip the debug file from the executable:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --strip-debug main mainStripped
</pre>
</div>

<p>
The small flag alternative can also be used:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy -g main mainNoDebugInfo
</pre>
</div>

<p>
After this command, the new executable has no longer the debug info.
</p>
<div class="org-src-container">
<pre class="src src-sh">$<span style="color: #fcaf3e;">file</span> mainNoDebugInfo
mainNoDebugInfo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
</pre>
</div>

<p>
The second step shows how to keep only the debug symbols in the <code>main.dbg</code> file:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --only-keep-debug main main.dbg
</pre>
</div>

<p>
Finally, to recreate an executable with a link to a debug symbols file, the following command can be used:
</p>
<div class="org-src-container">
<pre class="src src-sh">zig objcopy --add-gnu-debuglink=main.dbg mainNoDebugInfo mainWithDbgSymbols
</pre>
</div>

<p>
Now, the executable named <code>mainWithDbgSymbols</code> can be used, for example in GDB to debug it (GDB will know where its debug symbols file is located).
</p>

<p>
Removing the debug symbol will create a smaller executable.
Bellow shows the process with a mini-example:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">executable name</th>
<th scope="col" class="org-left">size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">main</td>
<td class="org-left">1.9M</td>
</tr>

<tr>
<td class="org-left">main.dbg</td>
<td class="org-left">1.2M</td>
</tr>

<tr>
<td class="org-left">mainNoDebugInfo</td>
<td class="org-left">690K</td>
</tr>

<tr>
<td class="org-left">mainWithDbgSymbols</td>
<td class="org-left">690K</td>
</tr>
</tbody>
</table>

<p>
The advantage of this method is that the executable can be sent to production without debug symbols (it's more difficult to reverse engineering the exe, and it has a smaller size).
But when a bug is reported, it is always possible to debug it because all you have to do is link the debug symbol to the executable.
</p>
</div>
</div>
</div>

<div id="outline-container-org55de8ce" class="outline-3">
<h3 id="org55de8ce"><span class="section-number-3">5.4.</span> Cross-compilation</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org696418c" class="outline-4">
<h4 id="org696418c"><span class="section-number-4">5.4.1.</span> Cross-compile with an embedded linux</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
TODO: Add iterate programming to cross compile automaticlly the app
</p>

<p>
The <code>-target</code> flag of <code>zig build-exe</code> can select the target architecture for the cross-compilation.
There are multiple target selections, see <a href="#citeproc_bib_item_3">[3]</a> to have the entire list of targets.
</p>

<p>
Here's an example of a test that was performed, the aim being to run an executable produced by Zig (from a <code>x86_64</code>) for a -nanopi neo plus 2- which has an arm64 architecture and runs a Linux kernel.
The information of the embedded target :
</p>
<div class="org-src-container">
<pre class="src src-sh">uname -a
Linux csel 5.15.148 <span style="color: #73d216;">#</span><span style="color: #73d216;">2 SMP PREEMPT Mon Mar 4 21:21:00 UTC 2024 aarch64 GNU/Linux</span>
</pre>
</div>

<p>
Here's the command to cross-compile the executable (the executable is also stripped to have a smaller size):
</p>
<div class="org-src-container">
<pre class="src src-sh">zig build-exe src/main.zig -target aarch64-linux -fstrip
</pre>
</div>

<p>
The executable on the embedded target runs flawlessly, below is shown the output of the target:
</p>
<pre class="example" id="orgb6c307e">
# ./main
All your codebase are belong to us.
Run `zig build test` to run the tests.
</pre>
</div>
</div>
</div>


<div id="outline-container-org73a4503" class="outline-3">
<h3 id="org73a4503"><span class="section-number-3">5.5.</span> Performance comparaison &amp; SMID</h3>
<div class="outline-text-3" id="text-5-5">
<p>
The following chapters will explain different benchmark and code.
</p>
</div>

<div id="outline-container-org1292fde" class="outline-4">
<h4 id="org1292fde"><span class="section-number-4">5.5.1.</span> Vectors</h4>
<div class="outline-text-4" id="text-5-5-1">
<p>
A Zig vector is an array of child type: booleans, integers, floats or pointers. 
It provides SIMD instructions for parallelizing operations where possible.
</p>

<p>
As described in the standard documentation, the vectors smaller than the target machine's SIMD instruction will be compiled to a single SIMD instruction.
In other hands, the vectors longer than the the target machine's SIMD will be compile to multiple SIMD instructions. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
The Zig vector does not work in the same way as the C++ vector. <a href="#citeproc_bib_item_4">[4]</a>
</p>

<p>
We can use multiple opteration on Zig vectors: 
</p>
<ul class="org-ul">
<li>Arithmetics</li>
<li>Bitwise operation</li>
<li>Comparaison operator</li>
</ul>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">size</span> = 4;
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">print</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">vector</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"{s}: "</span>, .{name});
    <span style="color: #b4fa70;">for</span> (0..size) |index| {
        <span style="color: #b4fa70;">try</span> <span style="color: #b4fa70;">switch</span> (T) {
            <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">bool</span>) =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{}, "</span>, .{vector[index]}),
            <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{c}, "</span>, .{vector[index]}),
            <span style="color: #b4fa70;">else</span> =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{d}, "</span>, .{vector[index]}),
        };
    }
    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"\n"</span>, .{});
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">i32</span>) = .{ 1, 2, 3, 4 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">b</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">i32</span>) = .{ 5, 6, 7, 8 };

    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"Access to an item: {d}\n"</span>, .{a[2]});

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span> = a + b;
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(c), <span style="color: #e9b96e;">"c"</span>, c);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">d</span> = a * b;
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(d), <span style="color: #e9b96e;">"d"</span>, d);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">e</span> = a &lt;&lt; b;
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(e), <span style="color: #e9b96e;">"e"</span>, e);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span> = a == b;
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(f), <span style="color: #e9b96e;">"f"</span>, f);
}
</pre>
</div>

<p>
Zig support a vector size of:
</p>
\begin{equation}
2^{32} - 1
\end{equation}
<p>
But currently on the last Zig version, a long size (2<sup>20</sup>) can crash at compile-time. <a href="https://ziglang.org/documentation/0.12.0/#toc-Vectors">see documentation</a> <a href="#citeproc_bib_item_5">[5]</a>
</p>

<p>
There are utility functions to simplify the use of vectors:
</p>
<ol class="org-ol">
<li><code>@splat</code>, this function will create a vector of a given size with the same value. <a href="https://ziglang.org/documentation/0.12.0/#splat"><code>@splat</code></a></li>
<li><code>@Reduce</code>, this function will reduce the vector into a scalar. We can specify the operation.
For intergers, every operation is available, for booleans plus there's <code>.And</code>, <code>.Or</code>, <code>.Xor</code>.
And finally, for floating points they have also <code>.Min</code>, <code>.Max</code>, <code>.Add</code>, <code>.Mul</code>. <a href="#citeproc_bib_item_1">[1]</a> <a href="https://ziglang.org/documentation/0.12.0/#reduce"><code>@reduce</code></a></li>
<li><code>@shuffle</code>, this function will construct a new vector by selecting the elements of two vectors (a and b) with a mask array.
The function will iterate on each element, and select the value of the mask. With the mask value, it will select the element of the array a or b.
If the number of the mask value is 0 or higher, it will select the index of the first vector (a).
If the number of the mask value is -1 or less, it will select the index starting at -1 and decrementing. (read the example to be more clear) <a href="https://ziglang.org/documentation/0.12.0/#shuffle"><code>@shuffle</code></a></li>
<li><code>@select</code>, this function will select from two vectors (a and b) based on a <code>pred</code> vector.
If <code>pred[i]</code> is positif, the element will be <code>a[i]</code> otherwise <code>b[i]</code> <a href="https://ziglang.org/documentation/0.12.0/#select"><code>@select</code></a></li>
</ol>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">size</span> = 4;
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">print</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">vector</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"{s}: "</span>, .{name});
    <span style="color: #b4fa70;">for</span> (0..size) |index| {
        <span style="color: #b4fa70;">try</span> <span style="color: #b4fa70;">switch</span> (T) {
            <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">bool</span>) =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{}, "</span>, .{vector[index]}),
            <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{c}, "</span>, .{vector[index]}),
            <span style="color: #b4fa70;">else</span> =&gt; stdout.writer().print(<span style="color: #e9b96e;">"{d}, "</span>, .{vector[index]}),
        };
    }
    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"\n"</span>, .{});
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">a</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">i32</span>) = <span style="color: #e090d7;">@splat</span>(3);
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(a), <span style="color: #e9b96e;">"a"</span>, a);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">b</span> = <span style="color: #e090d7;">@reduce</span>(.Add, a);
    <span style="color: #b4fa70;">try</span> stdout.writer().print(<span style="color: #e9b96e;">"b: {d}\n"</span>, .{b});

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">mask</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">i32</span>) = .{ 1, -2, -1, 0};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">c</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) = .{ <span style="color: #e9b96e;">'t'</span>, <span style="color: #e9b96e;">'t'</span>, <span style="color: #e9b96e;">'q'</span>, <span style="color: #e9b96e;">'q'</span>};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">d</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) = .{ <span style="color: #e9b96e;">'s'</span>, <span style="color: #e9b96e;">'e'</span>, <span style="color: #e9b96e;">'t'</span>, <span style="color: #e9b96e;">'a'</span>};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">e</span> = <span style="color: #e090d7;">@shuffle</span>(<span style="color: #8cc4ff;">u8</span>, c, d, mask);
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(e), <span style="color: #e9b96e;">"e"</span>, e);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">pred</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">bool</span>) = .{ <span style="color: #e9b2e3;">true</span>, <span style="color: #e9b2e3;">false</span>, <span style="color: #e9b2e3;">false</span>, <span style="color: #e9b2e3;">true</span>};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) = .{ <span style="color: #e9b96e;">'a'</span>, <span style="color: #e9b96e;">'a'</span>, <span style="color: #e9b96e;">'a'</span>, <span style="color: #e9b96e;">'a'</span>};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">g</span>: <span style="color: #e090d7;">@Vector</span>(size, <span style="color: #8cc4ff;">u8</span>) = .{ <span style="color: #e9b96e;">'b'</span>, <span style="color: #e9b96e;">'b'</span>, <span style="color: #e9b96e;">'b'</span>, <span style="color: #e9b96e;">'b'</span>};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">h</span> = <span style="color: #e090d7;">@select</span>(<span style="color: #8cc4ff;">u8</span>, pred, f, g);
    <span style="color: #b4fa70;">try</span> print(<span style="color: #e090d7;">@TypeOf</span>(h), <span style="color: #e9b96e;">"h"</span>, h);
}
</pre>
</div>
</div>
</div>


<div id="outline-container-orgbb9ce00" class="outline-4">
<h4 id="orgbb9ce00"><span class="section-number-4">5.5.2.</span> Leibniz algorithm</h4>
<div class="outline-text-4" id="text-5-5-2">
<p>
This chapter shows the performance of Zig compared to other language, in particular with C.
</p>

<p>
The <a href="https://github.com/niklas-heer/speed-comparison/tree/master">speed-comparaison</a> github repository <a href="#citeproc_bib_item_6">[6]</a> has differents examples code that shows the <a href="https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80">Leibniz algorithm</a> <a href="#citeproc_bib_item_7">[7]</a> in action.
This algorithm has puspose to compute the PI number with the following formula:
</p>

\begin{equation}
\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \ldots = \sum_{k = 0}^{\infty} \frac{(-1)^k}{2k + 1}
\end{equation}

<p>
Below, we can find example from the  <a href="https://github.com/niklas-heer/speed-comparison/tree/master">speed-comparaison</a> github repository.
They have been modified so that they can be run in org mode.
</p>

<p>
The C code shows the standard way to compute the Leibniz algorithm, at each iteration, PI will improve.
The C compiler will optimize the C code to use SIMD instructions under the hood.
The line: <code>x = -1.0 + 2.0 * (i &amp; 0x1);</code> is written in this way to enable the compiler to be optimised.
The compiler can then use the <code>fmadd</code> instruction, which performs a multiplication and an addition in a single operation. <a href="#citeproc_bib_item_8">[8]</a> <a href="#citeproc_bib_item_9">[9]</a>
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #8cc4ff;">unsigned</span> <span style="color: #fcaf3e;">rounds</span> = 1000000000;
<span style="color: #8cc4ff;">double</span> <span style="color: #fcaf3e;">pi</span> = 1.0;

rounds += 2u; <span style="color: #73d216;">// </span><span style="color: #73d216;">do this outside the loop</span>

<span style="color: #b4fa70;">for</span> (<span style="color: #8cc4ff;">unsigned</span> <span style="color: #fcaf3e;">i</span>=2u; i &lt; rounds; ++i)
{
    <span style="color: #8cc4ff;">double</span> <span style="color: #fcaf3e;">x</span> = -1.0 + 2.0 * (i &amp; 0x1); <span style="color: #73d216;">// </span><span style="color: #73d216;">allows vectorization</span>
    pi += (x / (2u * i - 1u)); <span style="color: #73d216;">// </span><span style="color: #73d216;">double / unsigned = double</span>
}

<span style="color: #8cc4ff;">pi</span> *= 4;
printf(<span style="color: #e9b96e;">"%.16f\n"</span>, pi); <span style="color: #73d216;">// </span><span style="color: #73d216;">print 16 decimal digits of pi</span>
</pre>
</div>


<p>
The code below shows the adaptation of the C code but for the Zig language.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">rounds</span>: <span style="color: #8cc4ff;">u64</span> = 1000000000;
rounds += 2;

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pi</span>: <span style="color: #8cc4ff;">f64</span> = 1.0;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">usize</span> = 2;
<span style="color: #b4fa70;">while</span> (i &lt; rounds) : (i += 1) {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">isOdd</span>: <span style="color: #8cc4ff;">f64</span> = <span style="color: #e090d7;">@floatFromInt</span>(i &amp; 0x1);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">x</span>: <span style="color: #8cc4ff;">f64</span> = -1.0 + 2.0 * isOdd;
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">den</span>: <span style="color: #8cc4ff;">f64</span> = <span style="color: #e090d7;">@floatFromInt</span>(2 * i - 1);
    pi += (x / den);
}
pi *= 4;
<span style="color: #b4fa70;">try</span> std.io.getStdOut().writer().print(<span style="color: #e9b96e;">"{}"</span>, .{pi});
</pre>
</div>

<p>
The Zig optimize code below will produce a similar output to the two other codes but it uses SIMD instruction to try to manually optimize the code.
Now the number of iterations is divided by 4 because the calculations are parallelized by 4.
Note: you can see that the length of the <code>vector</code> is 4. 
At the end of the example, the code doesn't use vectors, it will only use for the last iterations.
Indeed, the vectorization will only work for a number of rounds divisible by 4 (%4).
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">rounds</span>: <span style="color: #8cc4ff;">u64</span> = 1000000000;
rounds += 2;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">unroll</span> = 4;

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">x</span> = <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>){ -1.0, 1.0, -1.0, 1.0 };
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">den</span>: <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>) = <span style="color: #e090d7;">@splat</span>(0.0);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">inc</span>: <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>) = <span style="color: #e090d7;">@splat</span>(4.0);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">two</span>: <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>) = <span style="color: #e090d7;">@splat</span>(2.0);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">mone</span>: <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>) = <span style="color: #e090d7;">@splat</span>(-1.0);
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">ivec</span> = <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>){ 2.0, 3.0, 4.0, 5.0 };
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pivec</span>: <span style="color: #e090d7;">@Vector</span>(4, <span style="color: #8cc4ff;">f64</span>) = <span style="color: #e090d7;">@splat</span>(0.0);

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">vec_end</span>: <span style="color: #8cc4ff;">u64</span> = rounds - rounds % unroll;

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">u64</span> = 2;
<span style="color: #b4fa70;">while</span> (i &lt; vec_end) : (i += unroll) {
    den = mone + (two * ivec);
    ivec = ivec + inc;
    pivec = pivec + (x / den);
}

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">_x</span>: <span style="color: #8cc4ff;">f64</span> = 1.0;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pi</span>: <span style="color: #8cc4ff;">f64</span> = 1.0;
pi += <span style="color: #e090d7;">@reduce</span>(.Add, pivec);
<span style="color: #b4fa70;">while</span> (i &lt; vec_end) : (i += 1) {
    _x = -_x;
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">i_2</span>: <span style="color: #8cc4ff;">f64</span> = <span style="color: #e090d7;">@floatFromInt</span>(i);
    pi += (_x / 2 * i_2 - 1);
}
pi *= 4;

<span style="color: #b4fa70;">try</span> std.io.getStdOut().writer().print(<span style="color: #e9b96e;">"{d:.16}\n"</span>, .{pi});
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ddd5fb" class="outline-4">
<h4 id="org3ddd5fb"><span class="section-number-4">5.5.3.</span> Benchmark your x86\<sub>64</sub> CPU</h4>
<div class="outline-text-4" id="text-5-5-3">
<p>
The code below shows the comamnds to compile the three examples explains upper.
Moreover before to execute the code block, you need to tangle the examples with the shortcut <code>C-c C-v t</code>.
</p>

<p>
The command to compile the C code (with gcc) is specific to an x86<sub>64</sub> architecture, if you want to follow the examples make sure to have a compatible CPU.
Note: If emacs is unable to find the path to Zig during execution, the environment variable must be exported to the <code>.zshenv</code> file for a <code>zsh</code> shell.
</p>
<div class="org-src-container">
<pre class="src src-shell">gcc leibniz.c -o leibniz_c -O3 -s -flto -march=native -mtune=native -fomit-frame-pointer -fno-signed-zeros -fno-trapping-math -fassociative-math
zig build-exe leibniz.zig -OReleaseFast -femit-bin=leibniz_zig -fstrip
zig build-exe leibniz_simd.zig -OReleaseFast -femit-bin=leibniz_simd_zig -fstrip
</pre>
</div>

<p>
You will find the three executables in your directory.
</p>

<p>
Now to benchmark your code you need a tool to run the analysis, it's called <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> <a href="#citeproc_bib_item_10">[10]</a>.
Il faut installer hyperfine pour faire le benchmark : <a href="https://github.com/sharkdp/hyperfine">https://github.com/sharkdp/hyperfine</a>
</p>

<p>
To code bellow will run a benchmark with the <code>hyperfine</code> tool.
To use this tool, you need to install it and have in your path.
</p>
<div class="org-src-container">
<pre class="src src-shell">hyperfine --warmup=3 <span style="color: #e9b96e;">'./leibniz_c'</span> <span style="color: #e9b96e;">'./leibniz_zig'</span> <span style="color: #e9b96e;">'./leibniz_simd_zig'</span> -i -N
</pre>
</div>

<p>
If you run the benchmark in your computer, you can see the result in the block upper.
</p>
</div>
</div>

<div id="outline-container-org14ac03a" class="outline-4">
<h4 id="org14ac03a"><span class="section-number-4">5.5.4.</span> ARM benchmark example</h4>
<div class="outline-text-4" id="text-5-5-4">
<p>
We made the same benchmark but for an arm CPU, here are the compilers's options used.
The target is a nanopi neo plus 2.
</p>
<div class="org-src-container">
<pre class="src src-shell">aarch64-buildroot-linux-gnu-gcc leibniz.c -o leibniz_c -O3 -march=armv8-a -mtune=cortex-a53 -s -fno-signed-zeros -fno-trapping-math -fassociative-math
zig build-exe leibniz_smid.zig -OReleaseFast -femit-bin=leibniz_zig_simd_aarch -target aarch64-native -mcpu cortex_a53 -fstrip
zig build-exe leibniz.zig -OReleaseFast -femit-bin=leibniz_zig_aarch -target aarch64-native -mcpu cortex_a53 -fstrip
</pre>
</div>

<p>
On our arm target we cannot execute <code>hyperfine</code>, we measure 8 times the each program and we made statistics.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Program</th>
<th scope="col" class="org-right">Mean [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-right">Min [s]</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>./leibniz_c</code></td>
<td class="org-right">20.57</td>
<td class="org-right">20.58</td>
<td class="org-right">20.57</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_zig_aarch</code></td>
<td class="org-right">19.95</td>
<td class="org-right">19.96</td>
<td class="org-right">19.95</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_zig_simd_aarch</code></td>
<td class="org-right">14.43</td>
<td class="org-right">14.44</td>
<td class="org-right">14.43</td>
</tr>
</tbody>
</table>

<p>
We can find a difference in performance between the ARM and the x86 benchmarks.
We can note that the set of instructions used between the two benchmarks is different, the optimisations may then differ.
Moreover, the version of the compilator used is not the same for the C example:
</p>
<ul class="org-ul">
<li>For x86: <code>gcc (GCC) 13.2.1 20240316 (Red Hat 13.2.1-7)</code></li>
<li>For ARM: <code>aarch64-buildroot-linux-gnu-gcc.br_real (Buildroot 2022.08.3-dirty) 11.3.0</code></li>
</ul>
</div>
</div>


<div id="outline-container-org8165cbe" class="outline-4">
<h4 id="org8165cbe"><span class="section-number-4">5.5.5.</span> <span class="todo TODO">TODO</span> Differents code examples benchmark</h4>
<div class="outline-text-4" id="text-5-5-5">
<p>
TODO: update the benchmarks with the compiler commands
</p>

<p>
Mes benchmarks sur mon ordi :
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [ms]</th>
<th scope="col" class="org-right">Min [ms]</th>
<th scope="col" class="org-right">Max [ms]</th>
<th scope="col" class="org-left">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>./leibniz_zig</code></td>
<td class="org-left">85.9  0.4</td>
<td class="org-right">85.0</td>
<td class="org-right">87.0</td>
<td class="org-left">2.02  0.03</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_zig_simd</code></td>
<td class="org-left">42.5  0.5</td>
<td class="org-right">41.6</td>
<td class="org-right">43.7</td>
<td class="org-left">1.00</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_c</code></td>
<td class="org-left">43.3  0.8</td>
<td class="org-right">42.2</td>
<td class="org-right">45.4</td>
<td class="org-left">1.02  0.02</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_rs</code></td>
<td class="org-left">86.4  1.5</td>
<td class="org-right">85.2</td>
<td class="org-right">94.3</td>
<td class="org-left">2.03  0.04</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_avx2</code></td>
<td class="org-left">43.3  0.5</td>
<td class="org-right">42.1</td>
<td class="org-right">44.3</td>
<td class="org-left">1.02  0.02</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [ms]</th>
<th scope="col" class="org-right">Min [ms]</th>
<th scope="col" class="org-right">Max [ms]</th>
<th scope="col" class="org-left">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>./leibniz_zig</code></td>
<td class="org-left">883.9  9.5</td>
<td class="org-right">864.1</td>
<td class="org-right">896.0</td>
<td class="org-left">1.99  0.03</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_zig_simd</code></td>
<td class="org-left">443.8  5.2</td>
<td class="org-right">437.2</td>
<td class="org-right">452.0</td>
<td class="org-left">1.00</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_c</code></td>
<td class="org-left">481.5  4.4</td>
<td class="org-right">476.8</td>
<td class="org-right">489.2</td>
<td class="org-left">1.08  0.02</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_rs</code></td>
<td class="org-left">912.7  9.7</td>
<td class="org-right">897.1</td>
<td class="org-right">925.1</td>
<td class="org-left">2.06  0.03</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_avx2</code></td>
<td class="org-left">451.2  6.3</td>
<td class="org-right">443.8</td>
<td class="org-right">465.7</td>
<td class="org-left">1.02  0.02</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-left">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>./leibniz_zig</code></td>
<td class="org-left">8.889  0.095</td>
<td class="org-right">8.722</td>
<td class="org-right">9.058</td>
<td class="org-left">13.91  0.33</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_zig_simd</code></td>
<td class="org-left">4.386  0.028</td>
<td class="org-right">4.357</td>
<td class="org-right">4.420</td>
<td class="org-left">6.86  0.15</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_c</code></td>
<td class="org-left">0.665  0.003</td>
<td class="org-right">0.658</td>
<td class="org-right">0.669</td>
<td class="org-left">1.04  0.02</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_rs</code></td>
<td class="org-left">8.903  0.053</td>
<td class="org-right">8.855</td>
<td class="org-right">8.973</td>
<td class="org-left">13.93  0.31</td>
</tr>

<tr>
<td class="org-left"><code>./leibniz_avx2</code></td>
<td class="org-left">0.639  0.013</td>
<td class="org-right">0.618</td>
<td class="org-right">0.657</td>
<td class="org-left">1.00</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>


<div id="outline-container-orga831a20" class="outline-3">
<h3 id="orga831a20"><span class="section-number-3">5.6.</span> Programming language Benchmarks</h3>
<div class="outline-text-3" id="text-5-6">
<p>
Another way of seeing the difference in performance between C and Zig is to use slightly more complex code.
The <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks">Programming Language Benchmark</a> <a href="#citeproc_bib_item_11">[11]</a> git repository shows differents codes writing in different languages.
Their website shows benchmarks made with their hardware <a href="https://programming-language-benchmarks.vercel.app/zig-vs-c">zig-vs-c</a>. <a href="#citeproc_bib_item_12">[12]</a>
We then reproduced the benchmarks between the C and the Zig to see if there were any differences with our hardware.
</p>

<p>
Here's our results:
CPU INFO:[x86\<sub>64</sub>][8 cores] Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz (Model 142)
</p>

<p>
Here's what you need to know about file naming <a href="#citeproc_bib_item_11">[11]</a>:
</p>
<blockquote>
<ul class="org-ul">
<li>*-m in a file name stands for multi-threading or multi-processing</li>
<li>*-i in a file name stands for direct intrinsics usage. (Usage of SIMD intrinsics via libraries is not counted). It means that the SIMD instruction is directly use in the code. The instructions can be found in the <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=2102">Intel Intrinsics Guide</a>.</li>
<li>*(You may find time &lt; time(user) + time(sys) for some non-parallelized programs, the overhead is from GC or JIT compiler, which are allowed to take advantage of multi-cores as that's more close to real-world scenarios.)</li>
</ul>
</blockquote>

<p>
You can find in the repo how the examples are compiled <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/tree/main/bench">here</a>.
</p>

<p>
<b>knucleotide</b>
</p>

<p>
Input: 2500000:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.c">1-m.c</a></td>
<td class="org-left">185ms</td>
<td class="org-left">8.3ms</td>
<td class="org-left">23.6MB</td>
<td class="org-left">623ms</td>
<td class="org-left">13ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.c">1-m.c</a></td>
<td class="org-left">308ms</td>
<td class="org-left">19ms</td>
<td class="org-left">27.5MB</td>
<td class="org-left">2143ms</td>
<td class="org-left">80ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.zig">1.zig</a></td>
<td class="org-left">856ms</td>
<td class="org-left">6.0ms</td>
<td class="org-left">19.9MB</td>
<td class="org-left">907ms</td>
<td class="org-left">10ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>

<p>
Input: 250000:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.c">1-m.c</a></td>
<td class="org-left">33ms</td>
<td class="org-left">1.8ms</td>
<td class="org-left">11.9MB</td>
<td class="org-left">153ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.c">1-m.c</a></td>
<td class="org-left">47ms</td>
<td class="org-left">7.8ms</td>
<td class="org-left">16.8MB</td>
<td class="org-left">310ms</td>
<td class="org-left">15ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/knucleotide/1.zig">1.zig</a></td>
<td class="org-left">90ms</td>
<td class="org-left">2.1ms</td>
<td class="org-left">7.6MB</td>
<td class="org-left">90ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>


<p>
<b>nbody</b>
Input: 5000000
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.zig">2.zig</a></td>
<td class="org-left">179ms</td>
<td class="org-left">2.1ms</td>
<td class="org-left">1.3MB</td>
<td class="org-left">187ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">193ms</td>
<td class="org-left">1.7ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">200ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">211ms</td>
<td class="org-left">7.9ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">220ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">215ms</td>
<td class="org-left">2.9ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">223ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">222ms</td>
<td class="org-left">2.9ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">233ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">225ms</td>
<td class="org-left">3.5ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">233ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">225ms</td>
<td class="org-left">1.4ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">233ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">240ms</td>
<td class="org-left">5.2ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">253ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">242ms</td>
<td class="org-left">11ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">250ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">254ms</td>
<td class="org-left">2.5ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">267ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/1.zig">1.zig</a></td>
<td class="org-left">265ms</td>
<td class="org-left">7.1ms</td>
<td class="org-left">1.3MB</td>
<td class="org-left">280ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>

<p>
Input: 500000
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.zig">2.zig</a></td>
<td class="org-left">18ms</td>
<td class="org-left">0.2ms</td>
<td class="org-left">1.3MB</td>
<td class="org-left">10ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">21ms</td>
<td class="org-left">0.3ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">13ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">21ms</td>
<td class="org-left">0.3ms</td>
<td class="org-left">1.5MB</td>
<td class="org-left">17ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">21ms</td>
<td class="org-left">0.9ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">13ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">22ms</td>
<td class="org-left">1.4ms</td>
<td class="org-left">2.3MB</td>
<td class="org-left">17ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/8-i.c">8-i.c</a></td>
<td class="org-left">25ms</td>
<td class="org-left">0.2ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/5.c">5.c</a></td>
<td class="org-left">25ms</td>
<td class="org-left">1.2ms</td>
<td class="org-left">2.3MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">25ms</td>
<td class="org-left">0.4ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">25ms</td>
<td class="org-left">1.0ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/1.zig">1.zig</a></td>
<td class="org-left">27ms</td>
<td class="org-left">0.4ms</td>
<td class="org-left">1.1MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/nbody/2.c">2.c</a></td>
<td class="org-left">28ms</td>
<td class="org-left">1.7ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">20ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zigcc 0.12.0</td>
</tr>
</tbody>
</table>

<p>
<b>spectral-norm</b>
Input: 8000
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2-m.zig">2-m.zig</a></td>
<td class="org-left">340ms</td>
<td class="org-left">1.5ms</td>
<td class="org-left">1.6MB</td>
<td class="org-left">2550ms</td>
<td class="org-left">3ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">547ms</td>
<td class="org-left">11ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">4593ms</td>
<td class="org-left">17ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">566ms</td>
<td class="org-left">7.7ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">4780ms</td>
<td class="org-left">13ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">568ms</td>
<td class="org-left">14ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">4820ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">586ms</td>
<td class="org-left">11ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">4980ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">727ms</td>
<td class="org-left">4.5ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">6203ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">749ms</td>
<td class="org-left">13ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">6327ms</td>
<td class="org-left">7ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">799ms</td>
<td class="org-left">11ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">6770ms</td>
<td class="org-left">23ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">833ms</td>
<td class="org-left">23ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">7070ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2.zig">2.zig</a></td>
<td class="org-left">1168ms</td>
<td class="org-left">3.1ms</td>
<td class="org-left">1.5MB</td>
<td class="org-left">1257ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/1.zig">1.zig</a></td>
<td class="org-left">2774ms</td>
<td class="org-left">59ms</td>
<td class="org-left">1.5MB</td>
<td class="org-left">3010ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>

<p>
Input: 4000
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2-m.zig">2-m.zig</a></td>
<td class="org-left">89ms</td>
<td class="org-left">1.6ms</td>
<td class="org-left">1.6MB</td>
<td class="org-left">493ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">157ms</td>
<td class="org-left">11ms</td>
<td class="org-left">4.9MB</td>
<td class="org-left">1237ms</td>
<td class="org-left">3ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">163ms</td>
<td class="org-left">8.7ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">1327ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">164ms</td>
<td class="org-left">4.2ms</td>
<td class="org-left">4.8MB</td>
<td class="org-left">1300ms</td>
<td class="org-left">3ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">176ms</td>
<td class="org-left">5.4ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">1420ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">205ms</td>
<td class="org-left">17ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">1683ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">224ms</td>
<td class="org-left">26ms</td>
<td class="org-left">4.8MB</td>
<td class="org-left">1797ms</td>
<td class="org-left">10ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">226ms</td>
<td class="org-left">2.9ms</td>
<td class="org-left">4.9MB</td>
<td class="org-left">1820ms</td>
<td class="org-left">10ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2.zig">2.zig</a></td>
<td class="org-left">292ms</td>
<td class="org-left">1.1ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">310ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">488ms</td>
<td class="org-left">33ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">3600ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/1.zig">1.zig</a></td>
<td class="org-left">720ms</td>
<td class="org-left">11ms</td>
<td class="org-left">1.3MB</td>
<td class="org-left">773ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>

<p>
Input: 2000
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">lang</th>
<th scope="col" class="org-left">code</th>
<th scope="col" class="org-left">time</th>
<th scope="col" class="org-left">stddev</th>
<th scope="col" class="org-left">peak-mem mem</th>
<th scope="col" class="org-left">time(user)</th>
<th scope="col" class="org-left">time(sys)</th>
<th scope="col" class="org-left">compiler compiler/runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2-m.zig">2-m.zig</a></td>
<td class="org-left">28ms</td>
<td class="org-left">0.6ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">47ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">54ms</td>
<td class="org-left">12ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">363ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">61ms</td>
<td class="org-left">4.1ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">427ms</td>
<td class="org-left">0ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">65ms</td>
<td class="org-left">3.5ms</td>
<td class="org-left">4.9MB</td>
<td class="org-left">433ms</td>
<td class="org-left">7ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/2.zig">2.zig</a></td>
<td class="org-left">72ms</td>
<td class="org-left">1.0ms</td>
<td class="org-left">1.4MB</td>
<td class="org-left">70ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">73ms</td>
<td class="org-left">11ms</td>
<td class="org-left">4.6MB</td>
<td class="org-left">520ms</td>
<td class="org-left">3ms</td>
<td class="org-left">clang 17.0.6</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/6-im.c">6-im.c</a></td>
<td class="org-left">78ms</td>
<td class="org-left">9.4ms</td>
<td class="org-left">2.0MB</td>
<td class="org-left">577ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/3.c">3-m.c</a></td>
<td class="org-left">78ms</td>
<td class="org-left">10ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">600ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/4.c">4-m.c</a></td>
<td class="org-left">80ms</td>
<td class="org-left">12ms</td>
<td class="org-left">2.1MB</td>
<td class="org-left">590ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/5-im.c">5-im.c</a></td>
<td class="org-left">81ms</td>
<td class="org-left">13ms</td>
<td class="org-left">2.3MB</td>
<td class="org-left">620ms</td>
<td class="org-left">0ms</td>
<td class="org-left">gcc 13.2.0</td>
</tr>

<tr>
<td class="org-left">zig</td>
<td class="org-left"><a href="https://github.com/hanabi1224/Programming-Language-Benchmarks/blob/main/bench/algorithm/spectral-norm/1.zig">1.zig</a></td>
<td class="org-left">192ms</td>
<td class="org-left">3.6ms</td>
<td class="org-left">1.3MB</td>
<td class="org-left">203ms</td>
<td class="org-left">0ms</td>
<td class="org-left">zig 0.12.0</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-org3e55be7" class="outline-4">
<h4 id="org3e55be7"><span class="section-number-4">5.6.1.</span> Results</h4>
<div class="outline-text-4" id="text-5-6-1">
<p>
We can see that execution times vary greatly depending on the programming language, the implementation, the target, and finally, the compiler used.
In addition, we found that Zig codes that use vectors perform better than those that do not.
On the other hand, Zig codes that are not optimised tend to perform less well than C codes.
</p>

<p>
On the other hand, we can see that Zig codes consume less memory than C codes. 
For the comparison, to be fair, the allocator used in Zig is the libC allocator.
And finally, we can see that the performances depend also on the input.
</p>

<p>
We can't say that one language is faster than the other, as this will depend enormously on the context, the optimisations used, and the complexity of the code.
On the other hand, we can make a hypothesis based on the measurements taken: if dynamic memory allocation is performed correctly, we can expect Zig code to generally consume less memory than C code.
</p>

<p>
As a reminder, the results obtained are specific to the machine and operating system used.
In addition, we can compare the differences in performance between the benchmarks obtained on a local machine and the machine used by the <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks">Programming Language Benchmark</a> site.
For their part, the  <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks">Programming Language Benchmark</a> site uses a machine with the following information:
</p>
<ul class="org-ul">
<li>CPU INFO:[x86<sub>64</sub>][4 cores] AMD EPYC 7763 64-Core Processor (Model 1)</li>
<li>We should also note that compiler versions have changed, which can also add variability to the results
<ol class="org-ol">
<li>gcc 13.2.0</li>
<li>clang 14.0.0-1ubuntu1.1</li>
<li>zig 0.12.0-dev.2341+92211135f</li>
<li>zigcc 0.12.0-dev.2341+92211135f</li>
</ol></li>
</ul>

<p>
For the knucleotide example, we obtain a comparable ranking in the two results.
However, we notice that my x86 target is 85 ms slower for the version of Zig with an input of 2500000, but it consumes less memory (around 500KB).
</p>

<p>
For the nbody example, we can note that on average, the performance obtained is better on my x86 target, but the memory used remains in the same order of magnitude.
We also see that the <code>8-i.c</code> implementation is faster under AMD Epics for the <code>zigcc</code> compiler and for <code>gcc</code>.
And that the <code>5.c</code> implementation with the <code>Clang</code> compiler is among the first in the x86 test, but is among the last for AMD.
We note that the difference between version 14 and version 17 of clang can also affect the results.
This is the only example where the zigcc compiler is used for benchmarking.
We can see that the performance results obtained are similar to those we can get with gcc or clang.
We can also observe that the same code compiled with zigcc uses less memory than the other compilers.
Further tests would be needed to confirm this, as the nbody example does not allocate memory dynamically.
</p>

<p>
In the last example, we notice a big difference between the result of the <code>2.zig</code> code for an input of 8000: it is second to last for performance on x86, while it is second best on AMD.
Furthermore, we can see that the standard deviation may be higher for certain codes, but the results are different depending on the target.
Finally, the <code>1.zig</code> code is the worst-performing code for both benchmarks.
It runs 2x slower than the second-worst code
</p>
</div>
</div>
</div>

<div id="outline-container-org68e022c" class="outline-3">
<h3 id="org68e022c"><span class="section-number-3">5.7.</span> 1BRC</h3>
<div class="outline-text-3" id="text-5-7">
<p>
The <i>one billion row challenge</i> is a challenge that involves calculating the min, max, and average of 1 billion rows of measurements (a 12 Gio file). <a href="#citeproc_bib_item_13">[13]</a>
Everyone can submit a code to try to have a better implementation.
Originally the challenge was for Java, but now we can find multiple solutions in many languages.
</p>

<p>
In this documentation, we tried to see the differences between three implementations: one in C and two in Zig:
</p>
<ul class="org-ul">
<li><a href="https://github.com/almmiko/1brc-zig">1brc C</a> <a href="#citeproc_bib_item_14">[14]</a> <a href="#citeproc_bib_item_15">[15]</a></li>
<li><a href="https://github.com/candrewlee14/1brc-zig">1brc-zig</a> <a href="#citeproc_bib_item_16">[16]</a></li>
<li><a href="https://github.com/almmiko/1brc-zig">1brc-zig - second implementation</a> <a href="#citeproc_bib_item_17">[17]</a></li>
</ul>

<p>
In each repository, we can find how to compile their binary, we followed their instructions.
</p>

<p>
After each implementation build, we benchmark with hyperfine to have the results:
</p>

<ol class="org-ol">
<li>First, we used <code>hyperfine</code> to benchmark the three implementations one after the other:</li>
</ol>
<div class="org-src-container">
<pre class="src src-shell">hyperfine --warmup=3 <span style="color: #e9b96e;">'./1brc/bin/analyze ~/Documents/1brc/measurements.txt'</span> <span style="color: #e9b96e;">'./1brc-zig/zig-out/bin/1brc-zig ~/Documents/1brc/measurements.txt'</span> <span style="color: #e9b96e;">'./1brc-zig2/zig-out/bin/1brc-zig ~/Documents/1brc/measurements.txt'</span> --export-orgmode <span style="color: #e9b96e;">"benchmark-1brc.org"</span> --output null -i
</pre>
</div>

<p>
And we have the results:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-left">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>C implementation</code></td>
<td class="org-left">11.774  2.051</td>
<td class="org-right">7.582</td>
<td class="org-right">13.034</td>
<td class="org-left">1.00</td>
</tr>

<tr>
<td class="org-left"><code>1th Zig implementation</code></td>
<td class="org-left">21.283  0.051</td>
<td class="org-right">21.228</td>
<td class="org-right">21.390</td>
<td class="org-left">1.81  0.31</td>
</tr>

<tr>
<td class="org-left"><code>2th Zig implementation</code></td>
<td class="org-left">24.788  0.187</td>
<td class="org-right">24.332</td>
<td class="org-right">24.931</td>
<td class="org-left">2.11  0.37</td>
</tr>
</tbody>
</table>

<p>
We can see the differences in performances between C and Zig.
We note that the differences between the best C result and the worst C result have a difference of 6 seconds.
</p>

<p>
To see if we get different performances, we benchmark each implementation on its own:
</p>

<p>
The first Zig implementation <a href="https://github.com/candrewlee14/1brc-zig">1brc-zig</a>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-right">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>1th Zig implementation</code></td>
<td class="org-left">15.647  2.206</td>
<td class="org-right">13.301</td>
<td class="org-right">21.649</td>
<td class="org-right">1.00</td>
</tr>
</tbody>
</table>

<p>
Sometimes when we redo the benchmark we don't get this huge difference.
We use the Linux kernel to map the memory of the measurements file.
Depending on the computer load, some differences can be found.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-right">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>1th Zig implementation</code></td>
<td class="org-left">12.749  0.345</td>
<td class="org-right">12.202</td>
<td class="org-right">13.545</td>
<td class="org-right">1.00</td>
</tr>
</tbody>
</table>


<p>
The second Zig implementation <a href="https://github.com/almmiko/1brc-zig">1brc-zig - second implementation</a>
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-right">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>2th Zig implementation</code></td>
<td class="org-left">18.730  2.837</td>
<td class="org-right">15.192</td>
<td class="org-right">24.906</td>
<td class="org-right">1.00</td>
</tr>
</tbody>
</table>

<p>
And the C implementation
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Command</th>
<th scope="col" class="org-left">Mean [s]</th>
<th scope="col" class="org-right">Min [s]</th>
<th scope="col" class="org-right">Max [s]</th>
<th scope="col" class="org-right">Relative</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>C implementation</code></td>
<td class="org-left">8.898  0.591</td>
<td class="org-right">7.507</td>
<td class="org-right">9.510</td>
<td class="org-right">1.00</td>
</tr>
</tbody>
</table>


<p>
In the C implementation, we note that his writer uses a custom hashmap to hash the city names.
He uses a fast multiplication hash combined with a linear search probing.
The load factor of his hashmap is 0.5. <a href="#citeproc_bib_item_13">[13]</a>
</p>

<p>
The first Zig implementation use also a hashmap.
But the hashmap comes from the Zig standard library.
His purpose is generic and uses the Wyhash algorithm to compute the hashes.<a href="#citeproc_bib_item_18">[18]</a>
</p>

<p>
The <code>Hotspot</code> program has been used to create flamegraph of the implementations:
</p>

<p>
If you look at Zig's flamegraph, you can see that 40% of the cycle time is used to insert the city into the hashmap.
</p>

<div id="orgea92bee" class="figure">
<p><img src="../images/flamegraph_1brc_zig_1.png" alt="flamegraph_1brc_zig_1.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Flamegrph of the Zig's 1brc implementation</p>
</div>

<p>
In C, on the other hand, the insertion time in the hashmap is not measurable because it is included in the <code>process_chunck</code> function but does not require any complex hash calculation.
Calculating the base index is mapped into an array, and then, if there are any collisions, the index is incremented.
</p>

<div id="org25b6499" class="figure">
<p><img src="../images/flamegrah_1brc_c.png" alt="flamegrah_1brc_c.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Flamegrph of the C's 1brc implementation</p>
</div>

<p>
In the example below, Danny van Kooten, the writer of the C One Billion Rows Challenge, explains how the hashes are calculated for each city. <a href="#citeproc_bib_item_19">[19]</a>
He uses a simple fast multiplication hash combined with linear probing.
</p>

<p>
In the first bloc, he multiples each letter of the city by 31.
After that, he sums up all the results.
</p>

<p>
In the second bloc, he checks if the hash can be inserted into the hashmap.
If there is a collision, he iterates over the hashmap until he finds a free spot or a matching key.
</p>
<pre class="example" id="org5e839d9">
// hash everything up to ';'
// assumption: key (city name) is at least 1 char
unsigned int len = 1;
unsigned int hash = (unsigned char)buf[0];
while (buf[len] != ';') {
  hash = (hash * 31) + (unsigned char)buf[len++];
}

// probe map until free spot or matching key
unsigned int idx = hashmap[hash &amp; cap-1];
while (idx != 0 &amp;&amp; memcmp(results[idx], buf, len) != 0) {
    hash++;
    idx = hashmap[hash &amp; cap-1];
}

// idx is now either 0 (new entry)
// or contains the index of our key in the results a
</pre>


<p>
For the second implementation of the Zig code, we note that it has been implemented with a <code>btree</code>, used for data merge.
This merge is performed because there are several threads processing the data.
However, it also uses the same hashmap as the one used in the first version.
</p>
</div>
</div>

<div id="outline-container-orgcbd8c03" class="outline-3">
<h3 id="orgcbd8c03"><span class="section-number-3">5.8.</span> Zig package manager</h3>
<div class="outline-text-3" id="text-5-8">
<p>
Since 0.11, Zig has now an official built-in package manager named.
</p>

<p>
There is no global repository like <a href="https://crates.io">crates.io</a>(Rust) or <a href="https://npm.js.com">npmjs</a>(Node.js) for Zig packages. Instead, Zig packages are distributed as git repositories.
</p>

<p>
In order to add packages to your project you are going to create and edit a file in the root of your project named "build.zig.zon" (zon stands for Zig Object Notation, which is an equivalent to json).
</p>
</div>

<div id="outline-container-org84c2d7a" class="outline-4">
<h4 id="org84c2d7a"><span class="section-number-4">5.8.1.</span> Add a package in your project</h4>
<div class="outline-text-4" id="text-5-8-1">
<ol class="org-ol">
<li>Add the packages you want in your build.zig.zon file</li>
</ol>
<div class="org-src-container">
<pre class="src src-zon">.{
    .name = "name-of-my-project",
    .version = "0.0.1",

    .dependencies = .{
        // Here you add all the packages you want, in this exemple I have imported zap which is a web framework
        .zap = .{
            .url = "https://github.com/zigzap/zap/archive/refs/tags/v0.1.7-pre.tar.gz",
            .hash = "1220002d24d73672fe8b1e39717c0671598acc8ec27b8af2e1caf623a4fd0ce0d1bd",
        },
    }
}
</pre>
</div>
<p>
You can get further understanding in how to write your build.zig.zon following the official doc: <a href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md">https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md</a>
</p>

<p>
With 0.12.0 you can now use the "zig fetch" command from the root of your zig project to fetch the packages you need:
</p>
<div class="org-src-container">
<pre class="src src-shell">zig fetch --save git+https://github.com/zigzap/zap/#HEAD
</pre>
</div>

<p>
If you are prior to 0.12.0, you can write the "url" parameter without the "hash", then "zig build" and the outpout will give you the correct hash that you can then put back in your build.zig.zon file.
</p>

<ol class="org-ol">
<li>Add those added packages in your build.zig</li>
</ol>
<p>
Simply add the following code after the "addExectuable" function
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">zap</span> = b.dependency(<span style="color: #e9b96e;">"zap"</span>, .{
        .target = target,
        .optimize = optimize,
});
exe.addModule(<span style="color: #e9b96e;">"zap"</span>, zap.module(<span style="color: #e9b96e;">"zap"</span>));
exe.linkLibrary(zap.artifact(<span style="color: #e9b96e;">"facil.io"</span>));
</pre>
</div>
<p>
Note: here it is specific to the zap package, you might have different options and no need to link a library for an other package (zap uses facil.io under the hood)
</p>

<ol class="org-ol">
<li>Simply "@import" them and use them in your code :)</li>
</ol>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">zap</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"zap"</span>);
</pre>
</div>

<p>
Your packages will be downloaded and compiled when you build your project.
</p>
</div>
</div>

<div id="outline-container-orgbb8e542" class="outline-4">
<h4 id="orgbb8e542"><span class="section-number-4">5.8.2.</span> Sources</h4>
<div class="outline-text-4" id="text-5-8-2">
<p>
<a href="https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e">https://zig.news/edyu/zig-package-manager-wtf-is-zon-558e</a>
<a href="https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3">https://zig.news/edyu/zig-package-manager-wtf-is-zon-2-0110-update-1jo3</a>
<a href="https://ziglang.org/download/0.11.0/release-notes.html#Package-Management">https://ziglang.org/download/0.11.0/release-notes.html#Package-Management</a>
<a href="https://ziggit.dev/t/how-to-package-a-zig-source-module-and-how-to-use-it/3457">https://ziggit.dev/t/how-to-package-a-zig-source-module-and-how-to-use-it/3457</a>
<a href="https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md">https://github.com/ziglang/zig/blob/master/doc/build.zig.zon.md</a>
<a href="https://ziglang.org/download/0.11.0/release-notes.html#Package-Management">https://ziglang.org/download/0.11.0/release-notes.html#Package-Management</a>
<a href="https://github.com/zigzap/zap">https://github.com/zigzap/zap</a>
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7498d7c" class="outline-2">
<h2 id="org7498d7c"><span class="section-number-2">6.</span> Allocator</h2>
<div class="outline-text-2" id="text-6">
<p>
The Zig language doesn't hide the memory management, the mantra of Zig is to have no hidden control flow.
Like the C language, Zig has manual memory management however, Zig will offer the programmer different allocators that allow him to handle exactly how to use his memory.
That's why Zig doesn't have a runtime and it can be used without the <code>libc</code> runtime.
</p>

<p>
Different allocators will be presented in the next sections.
</p>

<p>
This part is documented thanks to various resources:
</p>
<ul class="org-ul">
<li><a href="https://ziglang.org/documentation/0.11.0/#Memory">Zig documentation - Memory</a></li>
<li><a href="https://zig.guide/standard-library/allocators/">Zig guide about allocator</a></li>
<li><a href="https://www.openmymind.net/learning_zig/heap_memory/">openmymind - learning zig - heap memory</a></li>
<li>The Zig's standard library code</li>
</ul>
</div>

<div id="outline-container-org2a1f58f" class="outline-3">
<h3 id="org2a1f58f"><span class="section-number-3">6.1.</span> General pattern</h3>
<div class="outline-text-3" id="text-6-1">
<p>
TODO selon le prof il faudrait "prouver" ou "sourcer" cette affirmation comme quoi cest une good practice mais je ne sais pas trop quoi dire:
</p>

<p>
"In Zig for library development, a good practice is to pass an allocator as a parameter, so the programmer can choose the best allocator for his use case."
</p>

<p>
In the Zig standard library, this pattern is used a lot.
</p>

<p>
For example, the <code>ArrayList</code> of the standard library uses this pattern :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(gpa.allocator());
<span style="color: #b4fa70;">defer</span> list.deinit();

<span style="color: #b4fa70;">try</span> list.append(42);

<span style="color: #b4fa70;">for</span> (list.items) |value| {
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Output:  {d}"</span>, .{value});
}
</pre>
</div>
</div>
</div>


<div id="outline-container-org8c5d449" class="outline-3">
<h3 id="org8c5d449"><span class="section-number-3">6.2.</span> Page allocator (<code>page_allocator</code>)</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The page allocator is the basic allocator that will directly ask the OS for memory. 
This is not the most efficient allocator because it will request memory pages from the OS via systems calls.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = std.heap.page_allocator;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">memory</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 42);
<span style="color: #b4fa70;">defer</span> allocator.free(memory);

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Len of the memory: {}\n"</span>, .{memory.len});

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct); 
<span style="color: #b4fa70;">defer</span> allocator.destroy(myStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});

</pre>
</div>
</div>
</div>

<div id="outline-container-org20a9762" class="outline-3">
<h3 id="org20a9762"><span class="section-number-3">6.3.</span> Fixed buffer allocator</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The <code>FixedBufferAllocator</code> will allocate memory into a fixed buffer, the size of the buffer needs to be known at comptime.
The benefit of this allocator is that it will not make heap allocation. It's very useful for embedded systems and kernel development.
This allocator is very performant and it will give an error if the allocator runs out of memory, with an <code>OutOfMemory</code> error.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [100]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">fixedBuffAlloc</span> = std.heap.FixedBufferAllocator.init(&amp;buffer);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = fixedBuffAlloc.allocator();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">memory</span> = <span style="color: #b4fa70;">try</span> allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 50);
<span style="color: #b4fa70;">defer</span> allocator.free(memory);

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Len of the memory: {}\n"</span>, .{memory.len});

<span style="color: #73d216;">// </span><span style="color: #73d216;">Example of OutOfMemory error</span>
_ = allocator.alloc(<span style="color: #8cc4ff;">u8</span>, 51) <span style="color: #b4fa70;">catch</span> |err| {
  <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"There is an error: {}\n"</span>, .{err});
};

</pre>
</div>

<p>
Moreover, there is also a thread-safe fixed buffer allocator for thread-safety use case: <code>std.heap.ThreadSafeFixedBufferAllocator</code>.
</p>
</div>
</div>

<div id="outline-container-org23c4529" class="outline-3">
<h3 id="org23c4529"><span class="section-number-3">6.4.</span> Arena allocator</h3>
<div class="outline-text-3" id="text-6-4">
<p>
The arena allocator takes a child allocator as input. This pattern is used to allocate multiple pieces of memory and free them at once.
There is no need in the arena allocator to free memory manually, it's the function <code>deinit</code> that is responsible for freeing <b>all</b> the allocated memory by this allocator.
</p>

<p>
The Zig documentation recommends this pattern when an application runs from start to end without a cyclic pattern.
For example: command line application.
</p>

<p>
Here's an example of how to use the arena allocator.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">page_allocator</span> = std.heap.page_allocator;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arena</span> = std.heap.ArenaAllocator.init(page_allocator);
<span style="color: #b4fa70;">defer</span> arena.deinit();
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = arena.allocator();

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});
<span style="color: #73d216;">// </span><span style="color: #73d216;">No need to manual free myStuct</span>

</pre>
</div>
</div>

<div id="outline-container-orgc550ae1" class="outline-4">
<h4 id="orgc550ae1"><span class="section-number-4">6.4.1.</span> Internal working of arena allocator</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
<a href="https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works">Zig how arena allocator works</a>
Internally, the arena allocator uses a linked list to keep track of the created buffers.
</p>

<p>
The example below shows a code snippet of the arena allocation (from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/arena_allocator.zig">arena<sub>allocator.zig</sub></a>).
The internals of the arena allocator are the child allocator and a state that contains a singly linked list of buffers.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">ArenaAllocator</span> = <span style="color: #b4fa70;">struct</span> {
  <span style="color: #fcaf3e;">child_allocator</span>: <span style="color: #8cc4ff;">Allocator</span>,
  <span style="color: #fcaf3e;">state</span>: <span style="color: #8cc4ff;">State</span>,

  <span style="color: #e9b96e;">/// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator</span>
  <span style="color: #e9b96e;">/// as a memory-saving optimization.</span>
  <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">State</span> = <span style="color: #b4fa70;">struct</span> {
      <span style="color: #fcaf3e;">buffer_list</span>: <span style="color: #8cc4ff;">std</span>.SinglyLinkedList(<span style="color: #8cc4ff;">usize</span>) = .{},
      <span style="color: #fcaf3e;">end_index</span>: <span style="color: #8cc4ff;">usize</span> = 0,

      <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">promote</span>(<span style="color: #fcaf3e;">self</span>: <span style="color: #8cc4ff;">State</span>, <span style="color: #fcaf3e;">child_allocator</span>: <span style="color: #8cc4ff;">Allocator</span>) ArenaAllocator {
          <span style="color: #b4fa70;">return</span> .{
              .child_allocator = child_allocator,
              .state = self,
          };
      }
  };
  <span style="color: #e9b96e;">/// ...</span>
};
</pre>
</div>

<p>
The <code>deinit</code> function of the arena allocator will free all the buffers by iterating over each node and calling the <code>rawFree</code> from the child allocator.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/arena_allocator.zig">arena<sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig">  <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: <span style="color: #8cc4ff;">ArenaAllocator</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">NOTE: When changing this, make sure `reset()` is adjusted accordingly!</span>

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">it</span> = self.state.buffer_list.first;
    <span style="color: #b4fa70;">while</span> (it) |node| {
        <span style="color: #73d216;">// </span><span style="color: #73d216;">this has to occur before the free because the free frees node</span>
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">next_it</span> = node.next;
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">align_bits</span> = std.math.log2_int(<span style="color: #8cc4ff;">usize</span>, <span style="color: #e090d7;">@alignOf</span>(BufNode));
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">alloc_buf</span> = <span style="color: #e090d7;">@as</span>([*]<span style="color: #8cc4ff;">u8</span>, <span style="color: #e090d7;">@ptrCast</span>(node))[0..node.data];
        self.child_allocator.rawFree(alloc_buf, align_bits, <span style="color: #e090d7;">@returnAddress</span>());
        it = next_it;
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf1f9200" class="outline-3">
<h3 id="orgf1f9200"><span class="section-number-3">6.5.</span> General purpose allocator</h3>
<div class="outline-text-3" id="text-6-5">
<p>
A general purpose allocator is available in Zig, this is a safe allocator that can prevent double free memory, "use after free" and detect memory leaks.
The general purpose allocator is safety first design, but it's still faster than the page allocator (<a href="https://zig.guide/standard-library/allocators/">Zig guide allocator</a>)
</p>

<p>
Note that it aims to be even faster in the <a href="https://github.com/ziglang/zig/issues/12484">future</a>.
</p>

<p>
The general purpose allocator is a function that takes as argument a comptime configuration struct and return a type.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/general_purpose_allocator.zig">general<sub>purpose</sub><sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">GeneralPurposeAllocator</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #e9b96e;">/// Implementation ....</span>
    };
}
</pre>
</div>

<p>
The configuration struct of the general purpose allocator shown below, has different options, like thread safety, memory limit, and debug utils.
(this code snippet comes from the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/heap/general_purpose_allocator.zig">general<sub>purpose</sub><sub>allocator.zig</sub></a>)
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #e9b96e;">/// Number of stack frames to capture.</span>
    <span style="color: #fcaf3e;">stack_trace_frames</span>: <span style="color: #8cc4ff;">usize</span> = default_stack_trace_frames,

    <span style="color: #e9b96e;">/// If true, the allocator will have two fields:</span>
    <span style="color: #e9b96e;">///  * `total_requested_bytes` which tracks the total allocated bytes of memory requested.</span>
    <span style="color: #e9b96e;">///  * `requested_memory_limit` which causes allocations to return `error.OutOfMemory`</span>
    <span style="color: #e9b96e;">///    when the `total_requested_bytes` exceeds this limit.</span>
    <span style="color: #e9b96e;">/// If false, these fields will be `void`.</span>
    <span style="color: #fcaf3e;">enable_memory_limit</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// Whether to enable safety checks.</span>
    <span style="color: #fcaf3e;">safety</span>: <span style="color: #8cc4ff;">bool</span> = std.debug.runtime_safety,

    <span style="color: #e9b96e;">/// Whether the allocator may be used simultaneously from multiple threads.</span>
    <span style="color: #fcaf3e;">thread_safe</span>: <span style="color: #8cc4ff;">bool</span> = !builtin.single_threaded,

    <span style="color: #e9b96e;">/// What type of mutex you'd like to use, for thread safety.</span>
    <span style="color: #e9b96e;">/// when specified, the mutex type must have the same shape as `std.Thread.Mutex` and</span>
    <span style="color: #e9b96e;">/// `DummyMutex`, and have no required fields. Specifying this field causes</span>
    <span style="color: #e9b96e;">/// the `thread_safe` field to be ignored.</span>
    <span style="color: #e9b96e;">///</span>
    <span style="color: #e9b96e;">/// when null (default):</span>
    <span style="color: #e9b96e;">/// * the mutex type defaults to `std.Thread.Mutex` when thread_safe is enabled.</span>
    <span style="color: #e9b96e;">/// * the mutex type defaults to `DummyMutex` otherwise.</span>
    <span style="color: #fcaf3e;">MutexType</span>: ?<span style="color: #8cc4ff;">type</span> = <span style="color: #e9b2e3;">null</span>,

    <span style="color: #e9b96e;">/// This is a temporary debugging trick you can use to turn segfaults into more helpful</span>
    <span style="color: #e9b96e;">/// logged error messages with stack trace details. The downside is that every allocation</span>
    <span style="color: #e9b96e;">/// will be leaked, unless used with retain_metadata!</span>
    <span style="color: #fcaf3e;">never_unmap</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// This is a temporary debugging aid that retains metadata about allocations indefinitely.</span>
    <span style="color: #e9b96e;">/// This allows a greater range of double frees to be reported. All metadata is freed when</span>
    <span style="color: #e9b96e;">/// deinit is called. When used with never_unmap, deliberately leaked memory is also freed</span>
    <span style="color: #e9b96e;">/// during deinit. Currently should be used with never_unmap to avoid segfaults.</span>
    <span style="color: #e9b96e;">/// TODO https://github.com/ziglang/zig/issues/4298 will allow use without never_unmap</span>
    <span style="color: #fcaf3e;">retain_metadata</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,

    <span style="color: #e9b96e;">/// Enables emitting info messages with the size and address of every allocation.</span>
    <span style="color: #fcaf3e;">verbose_log</span>: <span style="color: #8cc4ff;">bool</span> = <span style="color: #e9b2e3;">false</span>,
};
</pre>
</div>

<p>
The example below shows a basic usage of the Zig's GPA:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">MyStruct</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">myFloat</span>: <span style="color: #8cc4ff;">f32</span>,
    <span style="color: #fcaf3e;">myInt</span>: <span style="color: #8cc4ff;">i32</span>,
};

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

<span style="color: #73d216;">// </span><span style="color: #73d216;">Returns `Check.leak` if there were leaks; `Check.ok` otherwise.</span>
<span style="color: #b4fa70;">defer</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">checkStatus</span> = gpa.deinit();
    <span style="color: #b4fa70;">if</span> (checkStatus == std.heap.Check.leak) {
        std.log.err(<span style="color: #e9b96e;">"Leaks detected !!!"</span>, .{});
    }
}

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = <span style="color: #b4fa70;">try</span> allocator.create(MyStruct);
<span style="color: #b4fa70;">defer</span> allocator.destroy(myStruct);

myStruct.*.myFloat = 3.1415;
myStruct.*.myInt = 42;

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"myStruct: {}\n"</span>, .{myStruct});

</pre>
</div>
</div>
</div>


<div id="outline-container-org0bb22dd" class="outline-3">
<h3 id="org0bb22dd"><span class="section-number-3">6.6.</span> Testing allocator</h3>
<div class="outline-text-3" id="text-6-6">
<p>
The testing allocator is available in tests and the test runner will report all the memory leaks that have occurred during testing.<a href="#citeproc_bib_item_20">[20]</a> <a href="#citeproc_bib_item_21">[21]</a>
</p>

<p>
The example below shows how to use the testing allocator.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Test ArrayList"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">array</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> array.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span>: <span style="color: #8cc4ff;">i32</span> = 42;
    <span style="color: #b4fa70;">try</span> array.append(expected);

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(expected, array.items[0]);
}
</pre>
</div>

<p>
If the code below is run, the test will fail and it will display a leaked test memory.
Zig will help the programmer to detect memory leaks using code tests.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Test ArrayList"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">array</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(std.testing.allocator);
    <span style="color: #73d216;">//</span><span style="color: #73d216;">defer array.deinit(); -&gt; the array will not be free</span>

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span>: <span style="color: #8cc4ff;">i32</span> = 42;
    <span style="color: #b4fa70;">try</span> array.append(expected);

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(expected, array.items[0]);
}
</pre>
</div>

<p>
Under the hood, the testing allocator is an instance of the general purpose allocator.
Below, an extract of testing allocator of the standard library <a href="https://github.com/ziglang/zig/blob/0.11.x/lib/std/testing.zig">testing.zig</a>.
If the testing allocator is used outside of the tests, a compilation error will be thrown.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #e9b96e;">/// This should only be used in temporary test programs.</span>
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = allocator_instance.allocator();
<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">allocator_instance</span> = b: {
    <span style="color: #b4fa70;">if</span> (!builtin.is_test)
        <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Cannot use testing allocator outside of test block"</span>);
    <span style="color: #b4fa70;">break</span> :<span style="color: #8cc4ff;">b</span> std.heap.GeneralPurposeAllocator(.{}){};
};
</pre>
</div>
</div>
</div>

<div id="outline-container-org7e206ef" class="outline-3">
<h3 id="org7e206ef"><span class="section-number-3">6.7.</span> <span class="todo TODO">TODO</span> Failing allocator</h3>
<div class="outline-text-3" id="text-6-7">
<p>
The failing allocator can be used to ensure that the <code>error.OutOfMemory</code> is well handled.
</p>

<p>
The failling allocator need to have a child allocator to run.
In fact, the failing allocator can set in his <code>init</code> function the number of allocation that will be performed without errors (see the <code>numberOfAllocation</code> variable).
This pattern is pretty useful in restricted memory environments such as embedded development.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"test alloc falling"</span> {
  <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">numberOfAllocation</span> = 0;
  <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">failingAlloc</span> = std.testing.FailingAllocator.init(std.testing.allocator, numberOfAllocation);
  <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = std.ArrayList(<span style="color: #8cc4ff;">i32</span>).init(failingAlloc.allocator());
  <span style="color: #b4fa70;">defer</span> list.deinit();

  <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 45;

  <span style="color: #b4fa70;">try</span> std.testing.expectError(std.mem.Allocator.Error.OutOfMemory, list.append(expected));
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc905786" class="outline-3">
<h3 id="orgc905786"><span class="section-number-3">6.8.</span> <span class="todo TODO">TODO</span> C allocator</h3>
<div class="outline-text-3" id="text-6-8">
<p>
The <code>C</code> standard allocator can also be used, this allocator has high performance but it has less safety feature.
</p>

<p>
However, to use this allocator, the <code>libC</code> is required.
Adding the <code>libC</code> in the project will add more dependencies.
</p>
</div>
</div>

<div id="outline-container-org3ad55f7" class="outline-3">
<h3 id="org3ad55f7"><span class="section-number-3">6.9.</span> <span class="todo TODO">TODO</span> How to use Zig to detect memory leaks</h3>
<div class="outline-text-3" id="text-6-9">
</div>
<div id="outline-container-org0087efa" class="outline-4">
<h4 id="org0087efa"><span class="section-number-4">6.9.1.</span> <span class="todo TODO">TODO</span> Comparison between gcc-utils sanitizer, Valgrind, and Zig memory leak detection</h4>
</div>
</div>

<div id="outline-container-org9ea7a16" class="outline-3">
<h3 id="org9ea7a16"><span class="section-number-3">6.10.</span> <span class="todo TODO">TODO</span> ?</h3>
<div class="outline-text-3" id="text-6-10">
<p>
TODO talk about how malloc and calloc work in C with the on demand memory allocation (page fault each time with need more memory) is there a similar system in zig ? can we choose to have on demand memory or can we all allocate at once ?
</p>
</div>
</div>

<div id="outline-container-orgf9d0871" class="outline-3">
<h3 id="orgf9d0871"><span class="section-number-3">6.11.</span> Conclusion</h3>
<div class="outline-text-3" id="text-6-11">
<p>
TODO selon le prof cest bien de faire une conclusion et introduction sur la plupart des concepts abords
</p>
</div>
</div>
</div>

<div id="outline-container-org1800208" class="outline-2">
<h2 id="org1800208"><span class="section-number-2">7.</span> Comptime</h2>
<div class="outline-text-2" id="text-7">
<p>
Zig has a concept called <code>comptime</code>, it's stands for "compile-time".
Comptime is used to evaluate an expression at compile time and not at runtime.
In comparison with C, Zig comptime has the purpose of replacing marco with a more explicit syntax.
In fact, C's macro tends to be error-prone when using it.
The advantage of using comptime over macro is the type safety of Zig when writing comptime.
</p>
</div>

<div id="outline-container-org259969e" class="outline-3">
<h3 id="org259969e"><span class="section-number-3">7.1.</span> When to use and when NOT to use it</h3>
<div class="outline-text-3" id="text-7-1">
</div>
<div id="outline-container-org3328333" class="outline-4">
<h4 id="org3328333"><span class="section-number-4">7.1.1.</span> When to use it</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
Because the compiler can now do things at compilation time, leaving less work to be done at runtime. (if the compiler gives you the power to do things at compile time so easily, you should use it ^^)
</p>

<p>
So you should basically try to use it as much as you can.
</p>
</div>
</div>

<div id="outline-container-org7acf05e" class="outline-4">
<h4 id="org7acf05e"><span class="section-number-4">7.1.2.</span> When NOT to use it (source: ziglings)</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
The following contexts are already IMPLICITLY evaluated at
compile time, and adding the 'comptime' keyword would be
superfluous, redundant, and smelly:
</p>

<ul class="org-ul">
<li>The container-level scope (outside of any function in a source file)</li>
<li>Type declarations of:
<ul class="org-ul">
<li>Variables</li>
<li>Functions (types of parameters and return values)</li>
<li>Structs</li>
<li>Unions</li>
<li>Enums</li>
</ul></li>
<li>The test expressions in inline for and while loops</li>
<li>An expression passed to the @cImport() builtin</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgd6c9315" class="outline-3">
<h3 id="orgd6c9315"><span class="section-number-3">7.2.</span> Compile-time evaluation</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-org5f105a5" class="outline-4">
<h4 id="org5f105a5"><span class="section-number-4">7.2.1.</span> Compile-time variable</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
In Zig, there are variables that can be evaluated at compile-time, in fact, Zig allows computing mutating variables at compile-time but all the inputs need to be known also at compile-time.
If not, the compiler will throw a compile error. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
For a mutating variable at compile-time, Zig requires naming the variables with a <code>comptime var</code>.
But if the variable is a constant, the compiler requires to use a <code>const</code>. 
</p>

<p>
Like in the example below, the variable named <code>variableAtCompileTime</code> is evaluated at compile-time because all the inputs are known.
On the other hand, the variable named <code>constantAtRuntime</code> cannot be a comptime variable because its dependency is based on unknown before runtime.
</p>

<p>
Moreover, in the example, the <code>inline for</code> is used to unroll the for loop.
This allows to use for loops in comptime indeed, if a standard for loop is used, it will cause an error because the capture value will be evaluated at runtime.<a href="#citeproc_bib_item_1">[1]</a> 
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">randVariable</span> = std.crypto.random.float(<span style="color: #8cc4ff;">f32</span>);
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">selectedConstant</span> = 6;

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">constantAtRuntime</span> = randVariable * selectedConstant;

<span style="color: #b4fa70;">comptime</span> <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">variableAtCompileTime</span> = selectedConstant * selectedConstant;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">array</span> = [_]<span style="color: #8cc4ff;">comptime_int</span> { 3, 2, 1};

<span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (array) |item| {
    variableAtCompileTime += item;
}

<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"constant-at-runtime {d:.2}\n"</span>, .{constantAtRuntime});
<span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"variable-at-compile-time  {d}"</span>, .{variableAtCompileTime});

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">constant-at-runtime</td>
<td class="org-right">1.57</td>
</tr>

<tr>
<td class="org-left">variable-at-compile-time</td>
<td class="org-right">42</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgcc40ba3" class="outline-4">
<h4 id="orgcc40ba3"><span class="section-number-4">7.2.2.</span> Compile-time expression</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
In Zig, an expression can have a <code>comptime</code> to tell the compiler to evaluate the expression at compile-time.
Like a compile-time variable, if an expression cannot be evaluated at compile-time, a compile-time error will be thrown.
</p>

<p>
With a prefixed <code>comptime</code> keyword Zig can interpret a function at compile-time instead of runtime. <a href="#citeproc_bib_item_1">[1]</a>
</p>

<p>
A good example of demonstrating comptime expression is in the standard documentation <a href="#citeproc_bib_item_1">[1]</a>.
The results show that the comptime expression is faster than the runtime one when the code is executed (runtime) because the work has already been done.
But this will work only with code that hasn't runtime dependency code.
</p>

<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Timer</span> = std.time.Timer;
<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">fib</span>(<span style="color: #fcaf3e;">iteration</span>: <span style="color: #8cc4ff;">u32</span>) <span style="color: #8cc4ff;">u32</span> {
    <span style="color: #b4fa70;">if</span> (iteration &lt; 2) <span style="color: #b4fa70;">return</span> iteration;

    <span style="color: #b4fa70;">return</span> fib(iteration - 1) + fib(iteration - 2);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"comptime fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">comptime</span> fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-comptime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expectEqual(610, result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"fib"</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">timer</span> = <span style="color: #b4fa70;">try</span> Timer.start();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">result</span> = fib(15);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">elapsed</span> = timer.read();
    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"Elasped-runtime: {d:0.2}ns\n"</span>, .{elapsed});

    <span style="color: #b4fa70;">try</span> std.testing.expect(610 == result);
}

</pre>
</div>
</div>
</div>

<div id="outline-container-orgcc16a21" class="outline-4">
<h4 id="orgcc16a21"><span class="section-number-4">7.2.3.</span> Compile-time parameter</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
Zig implements generic by using duck typing at compile-time.
To use generic, Zig needs to know the type at compile-time.
</p>
<div class="org-src-container">
<pre class="src src-zig">
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">greater</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>, <span style="color: #fcaf3e;">array</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">T</span>) !?T {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">max</span>: ?<span style="color: #8cc4ff;">T</span> = <span style="color: #e9b2e3;">null</span>;
    <span style="color: #b4fa70;">for</span> (array) |item| {
        <span style="color: #b4fa70;">if</span> (max) |m| {
            <span style="color: #b4fa70;">if</span> (m &lt; item) {
                max = item;
            }
        } <span style="color: #b4fa70;">else</span> {
            max = item;
        }
    }
    <span style="color: #b4fa70;">return</span> max;
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an i32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intArray</span> = [_]<span style="color: #8cc4ff;">i32</span>{ 2, 9, 4, 6, 7, 1};
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">i32</span>, &amp;intArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 9);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"should return the max of an f32 array"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">floatArray</span> = [_]<span style="color: #8cc4ff;">f32</span>{ 2.34, 14.55, 4.12, 6.876, 7.111 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = <span style="color: #b4fa70;">try</span> greater(<span style="color: #8cc4ff;">f32</span>, &amp;floatArray);

    <span style="color: #b4fa70;">try</span> std.testing.expect(result == 14.55);
}


</pre>
</div>

<p>
But with duck typing, if the same method is used, an error will be thrown at compile time:
</p>
<div class="org-src-container">
<pre class="src src-Zig">test "should fail with bool" {
    const boolArray = [_]bool{ true, false, true, true };
    const result = greater(bool, &amp;boolArray);
}
</pre>
</div>

<p>
The error will be:
</p>
<pre class="example" id="orge0b7855">
error: operator &lt; not allowed for type 'bool'
</pre>

<p>
Moreover, comptime can also be used as a type definition.
For this, the function needs to return a <code>type</code>.
The example below is based on <a href="https://zig.guide/language-basics/comptime">the zig guide</a> <a href="#citeproc_bib_item_2">[2]</a>, it's shows that it can define a new type with a function.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">width</span>: <span style="color: #8cc4ff;">comptime_int</span>,
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">height</span>: <span style="color: #8cc4ff;">comptime_int</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> [height][width]T;
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">Matrix3x3</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>,
) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> Matrix(T, 3, 3);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a type"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix(<span style="color: #8cc4ff;">f32</span>, 4, 4) == [4][4]<span style="color: #8cc4ff;">f32</span>);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"returning a 3x3 matrix"</span> {
    <span style="color: #b4fa70;">try</span> std.testing.expect(Matrix3x3(<span style="color: #8cc4ff;">f32</span>) == [3][3]<span style="color: #8cc4ff;">f32</span>);
}

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org9249602" class="outline-3">
<h3 id="org9249602"><span class="section-number-3">7.3.</span> Metaprogramming</h3>
<div class="outline-text-3" id="text-7-3">
</div>
<div id="outline-container-org8a72bd7" class="outline-4">
<h4 id="org8a72bd7"><span class="section-number-4">7.3.1.</span> <code>@TypeOf</code></h4>
<div class="outline-text-4" id="text-7-3-1">
<p>
The <code>@TypeOf</code> builtin function can be used to take as a parameter an expression and return a type.
</p>
</div>
</div>

<div id="outline-container-org5e0e519" class="outline-4">
<h4 id="org5e0e519"><span class="section-number-4">7.3.2.</span> <code>@typeInfo</code></h4>
<div class="outline-text-4" id="text-7-3-2">
<p>
This built-in function provides type reflection, it returns information on type.
</p>

<p>
See the example <code>Example with a custom CSV writer based on type</code> to have a view of the usability.
</p>
</div>
</div>
</div>

<div id="outline-container-org55b2b10" class="outline-3">
<h3 id="org55b2b10"><span class="section-number-3">7.4.</span> <span class="todo TODO">TODO</span> Optimization</h3>
<div class="outline-text-3" id="text-7-4">
<p>
inline for / while
</p>
</div>

<div id="outline-container-org0695815" class="outline-4">
<h4 id="org0695815"><span class="section-number-4">7.4.1.</span> How log works in Zig</h4>
<div class="outline-text-4" id="text-7-4-1">
<p>
In the C language, a common use to use debug print is with Marco.
Like in this example, if the <code>DEBUG</code> is defined to <code>1</code> the code will print the debug info.
If the <code>DEBUG</code> is not set, at the compilation, all the print information will be removed.
</p>
<div class="org-src-container">
<pre class="src src-C">
<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">DEBUG</span> 1

<span style="color: #e090d7;">#if</span> DEBUG 
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>) <span style="color: #8cc4ff;">printf</span> <span style="color: #fcaf3e;">x</span>;
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#define</span> <span style="color: #fce94f;">TRACE</span>(<span style="color: #fcaf3e;">x</span>)
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  TRACE((<span style="color: #e9b96e;">"Hello World! : %d\n"</span>, 12));
}
</pre>
</div>

<p>
In Zig, logging uses this same principle, a message level is set at the start of the program (at compile-time) and if the log is not enabled, all the code about the print is removed.
However, if the log level is greater than the limit, the message will be printed.
</p>

<p>
The code below shows an extract of the standard library for logging.
</p>
<div class="org-src-container">
<pre class="src src-zig"> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">log</span>(
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">message_level</span>: <span style="color: #8cc4ff;">Level</span>,
    <span style="color: #b4fa70;">comptime</span> scope: <span style="color: #e090d7;">@Type</span>(.EnumLiteral),
    <span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">format</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">args</span>: <span style="color: #8cc4ff;">anytype</span>,
) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">if</span> (<span style="color: #b4fa70;">comptime</span> !logEnabled(message_level, scope)) <span style="color: #b4fa70;">return</span>;

    std.options.logFn(message_level, scope, format, args);
}
</pre>
</div>

<p>
In addition, Zig provides some helper functions for logging, such as :
</p>
<ul class="org-ul">
<li><code>std.log.debug</code></li>
<li><code>std.log.info</code></li>
<li><code>std.log.warn</code></li>
<li><code>std.log.err</code></li>
</ul>

<p>
And if the release mode is set to <code>Debug</code>, the debug log will be printed.
But if the release mode is set to <code>Release*</code>, the debug log will not print, there is no need to configure the logging to have this behavior.
</p>
</div>
</div>
</div>

<div id="outline-container-orgafc5258" class="outline-3">
<h3 id="orgafc5258"><span class="section-number-3">7.5.</span> Generic data structures</h3>
<div class="outline-text-3" id="text-7-5">
<p>
To create a generic data structure, the same pattern is used as a comptime parameter.
A function needs to return an anonymous struct as a type <code>type</code>.
</p>

<p>
In a generic data structure, the <code>@This()</code> is used to get the type of the data structure because it is anonymous.
</p>

<p>
Moreover, a generic data structure can have two type of function:
</p>
<ol class="org-ol">
<li>a function that can be called on the structure type</li>
<li>a function that can be called on the instance of the structure.</li>
</ol>

<p>
To have an instance function, the first argument needs to be a parameter of the type of the struct.
That's why a constant <code>Self</code> is used with <code>@This()</code>.
And after that, the parameter <code>self</code> can be used to get the members of the struct.
</p>

<p>
The example shows the difference between a function that can be called on a struct and a function that can be called on an instance of a struct.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">structFunction</span>(<span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structFunction\n"</span>, .{});
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">instanceFunction</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"structInstance: {d}\n"</span>, .{self.myNumber});
        }
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();

    <span style="color: #b4fa70;">try</span> MyStruct(<span style="color: #8cc4ff;">f32</span>).structFunction(stdout);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">myStruct</span> = MyStruct(<span style="color: #8cc4ff;">f32</span>){
        .myNumber = 42,
    };

    <span style="color: #b4fa70;">try</span> myStruct.instanceFunction(stdout);
}

</pre>
</div>

<p>
In Zig, a structure name can be explicitly given or Zig can infer the name of a struct when there are created:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">MyStruct</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #fcaf3e;">myNumber</span>: <span style="color: #8cc4ff;">T</span>,
    };
}

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure name is infered</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct1</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>) {
        .myNumber = 42,
    };
    _ = myStruct1;

    <span style="color: #73d216;">// </span><span style="color: #73d216;">The structure has a explicit name</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intStruct</span> = MyStruct(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">myStruct2</span> =  intStruct {
        .myNumber = 42,
    };
    _ = myStruct2;
}
</pre>
</div>

<p>
Here's an compete example of an generic linked list :
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">LinkedList</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Node</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">data</span>: <span style="color: #8cc4ff;">T</span>,
            <span style="color: #fcaf3e;">prev</span>: ?*<span style="color: #8cc4ff;">Node</span>,
            <span style="color: #fcaf3e;">next</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        };

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">LinkedListError</span> = <span style="color: #b4fa70;">error</span>{headNull};
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();
        <span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator,
        <span style="color: #fcaf3e;">head</span>: ?*<span style="color: #8cc4ff;">Node</span>,
        <span style="color: #fcaf3e;">len</span>: <span style="color: #8cc4ff;">u32</span> = 0,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">allocator</span>: <span style="color: #8cc4ff;">std</span>.mem.Allocator) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .head = <span style="color: #e9b2e3;">null</span>,
                .allocator = allocator,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">deinit</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>) <span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">curr</span> = self.head;

            <span style="color: #b4fa70;">while</span> (curr) |currNotNull| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">node</span> = currNotNull;
                curr = currNotNull.next;
                self.allocator.destroy(node);
            }
            self.len = 0;
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">push</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">value</span>: <span style="color: #8cc4ff;">T</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">node</span> = <span style="color: #b4fa70;">try</span> self.allocator.create(Node);
            node.*.data = value;
            self.len += 1;

            <span style="color: #b4fa70;">if</span> (self.head) |head| {
                node.next = head;
                head.prev = node;
                self.head = node;
            } <span style="color: #b4fa70;">else</span> {
                self.head = node;
                node.*.next = <span style="color: #e9b2e3;">null</span>;
                node.*.prev = <span style="color: #e9b2e3;">null</span>;
            }
        }
    };
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a i32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">i32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 42;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}

<span style="color: #b4fa70;">test</span> <span style="color: #e9b96e;">"Should push one item into a f32 list"</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">intLinkedList</span> = LinkedList(<span style="color: #8cc4ff;">f32</span>);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">list</span> = intLinkedList.init(std.testing.allocator);
    <span style="color: #b4fa70;">defer</span> list.deinit();

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">expected</span> = 3.1415;

    <span style="color: #b4fa70;">try</span> list.push(expected);
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">result</span> = list.head.?.data;

    <span style="color: #b4fa70;">try</span> std.testing.expect(expected == result);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb3cd3a7" class="outline-3">
<h3 id="orgb3cd3a7"><span class="section-number-3">7.6.</span> Example with a custom CSV writer based on type</h3>
<div class="outline-text-3" id="text-7-6">
<p>
This example shows that Zig has a type reflection with the keyword <code>@typeInfo</code>.
The goal of this example is to create CSV output with a generic struct as input.
Only with the <code>try csv.stringify(&amp;arrayList, stream.writer());</code> function the <code>CsvWriter</code> can infer at comptime the struct pass as argument.
For this example, a basic struct named <code>Person</code> will be transformed to CSV.
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">CsvWriter</span>(<span style="color: #b4fa70;">comptime</span> <span style="color: #fcaf3e;">T</span>: <span style="color: #8cc4ff;">type</span>) <span style="color: #8cc4ff;">type</span> {
    <span style="color: #b4fa70;">return</span> <span style="color: #b4fa70;">struct</span> {
        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Self</span> = <span style="color: #e090d7;">@This</span>();

        <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Config</span> = <span style="color: #b4fa70;">struct</span> {
            <span style="color: #fcaf3e;">separator</span>: <span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b96e;">','</span>,
        };
        <span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>,

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">init</span>(<span style="color: #fcaf3e;">config</span>: <span style="color: #8cc4ff;">Config</span>) Self {
            <span style="color: #b4fa70;">return</span> Self{
                .config = config,
            };
        }

        <span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">stringify</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">arrayList</span>: *<span style="color: #8cc4ff;">std</span>.ArrayList(T), <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">try</span> writeHeader(self, &amp;writer);
            <span style="color: #b4fa70;">for</span> (arrayList.items) |item| {
                <span style="color: #b4fa70;">try</span> writeType(self, item, &amp;writer);
            }
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeHeader</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{field.name});
                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }

        <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">writeType</span>(<span style="color: #fcaf3e;">self</span>: *<span style="color: #8cc4ff;">Self</span>, <span style="color: #fcaf3e;">item</span>: <span style="color: #8cc4ff;">T</span>, <span style="color: #fcaf3e;">writer</span>: <span style="color: #8cc4ff;">anytype</span>) !<span style="color: #8cc4ff;">void</span> {
            <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">fields</span> = std.meta.fields(T);

            <span style="color: #b4fa70;">if</span> (<span style="color: #e090d7;">@TypeOf</span>(fields) != []<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span>.builtin.Type.StructField)
                <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"The type is not the a struct"</span>);

            <span style="color: #b4fa70;">inline</span> <span style="color: #b4fa70;">for</span> (fields, 1..) |field, i| {
                <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">f</span> = <span style="color: #e090d7;">@field</span>(item, field.name);

                <span style="color: #b4fa70;">switch</span> (<span style="color: #e090d7;">@typeInfo</span>(<span style="color: #e090d7;">@TypeOf</span>(f))) {
                    .Int =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Float =&gt; <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{d}"</span>, .{f}),
                    .Pointer =&gt; |pointer| {
                        <span style="color: #b4fa70;">if</span> (pointer.size == std.builtin.Type.Pointer.Size.Slice <span style="color: #b4fa70;">and</span> pointer.child == <span style="color: #8cc4ff;">u8</span>) {
                            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{s}"</span>, .{f});
                        } <span style="color: #b4fa70;">else</span> {
                            <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>);
                        }
                    },
                    <span style="color: #b4fa70;">else</span> =&gt; <span style="color: #e090d7;">@compileError</span>(<span style="color: #e9b96e;">"Currently, the CsvWriter dosen't support complex types"</span>),
                }

                <span style="color: #b4fa70;">if</span> (fields.len != i) {
                    <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"{c}"</span>, .{self.config.separator});
                }
            }
            <span style="color: #b4fa70;">try</span> writer.print(<span style="color: #e9b96e;">"\n"</span>, .{});
        }
    };
}

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">Person</span> = <span style="color: #b4fa70;">struct</span> {
    <span style="color: #fcaf3e;">sexe</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">name</span>: []<span style="color: #b4fa70;">const</span> <span style="color: #8cc4ff;">u8</span>,
    <span style="color: #fcaf3e;">date</span>: <span style="color: #8cc4ff;">u32</span>,
};


<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">stdout</span> = std.io.getStdOut().writer();
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person1</span> = .{ .sexe = <span style="color: #e9b96e;">"M"</span>, .name = <span style="color: #e9b96e;">"Lucas"</span>, .date = 2000 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person2</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Ava"</span>, .date = 2020 };
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">person3</span> = .{ .sexe = <span style="color: #e9b96e;">"F"</span>, .name = <span style="color: #e9b96e;">"Sophia"</span>, .date = 1989 };

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">arrayList</span> = std.ArrayList(Person).init(gpa.allocator());
    <span style="color: #b4fa70;">defer</span> arrayList.deinit();

    <span style="color: #b4fa70;">try</span> arrayList.append(person1);
    <span style="color: #b4fa70;">try</span> arrayList.append(person2);
    <span style="color: #b4fa70;">try</span> arrayList.append(person3);

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">buffer</span>: [1024]<span style="color: #8cc4ff;">u8</span> = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">stream</span> = std.io.fixedBufferStream(buffer[0..]);

    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">personCsvWriter</span> = CsvWriter(Person);
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">csv</span> = personCsvWriter.init(.{ .separator = <span style="color: #e9b96e;">' '</span> });
    <span style="color: #b4fa70;">try</span> csv.stringify(&amp;arrayList, stream.writer());

    <span style="color: #b4fa70;">try</span> stdout.print(<span style="color: #e9b96e;">"{s}"</span>, .{stream.getWritten()});

}

</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">sexe</td>
<td class="org-left">name</td>
<td class="org-right">date</td>
</tr>

<tr>
<td class="org-left">M</td>
<td class="org-left">Lucas</td>
<td class="org-right">2000</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Ava</td>
<td class="org-right">2020</td>
</tr>

<tr>
<td class="org-left">F</td>
<td class="org-left">Sophia</td>
<td class="org-right">1989</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8a844cf" class="outline-3">
<h3 id="org8a844cf"><span class="section-number-3">7.7.</span> Bonus</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Here is a very nice blog written by a core member of the ZIG community if you want to dig further: <a href="https://kristoff.it/blog/what-is-zig-comptime/">https://kristoff.it/blog/what-is-zig-comptime/</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org19926e2" class="outline-2">
<h2 id="org19926e2"><span class="section-number-2">8.</span> Concurrency</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-orgc39c64c" class="outline-3">
<h3 id="orgc39c64c"><span class="section-number-3">8.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-8-1">
<p>
The objectives of this chapter is to go in depth about the different ways to do concurrency in ZIG.
</p>

<p>
We are going to explore the different ways to do concurrency in general (not Zig related) and then we could use a few of those solutions in ZIG.
</p>

<p>
By the end you should be able to see the pros and cons of each solution and choose the one that fits you in Zig.
</p>
</div>
</div>

<div id="outline-container-org67065c0" class="outline-3">
<h3 id="org67065c0"><span class="section-number-3">8.2.</span> Definitions</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Before diving into the different ways to do concurrency in ZIG, let's first define some terms that are useful to understand the basics of concurrency (not related to Zig).
</p>
</div>

<div id="outline-container-org30cb714" class="outline-4">
<h4 id="org30cb714"><span class="section-number-4">8.2.1.</span> Coroutine</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
Courtines enable the management of concurrent tasks like callbacks do (which make them not concurrent by nature but they are a tool to achieve concurrency). Their great power lies in their ability to write concurent task like you would write sequential code. They achieve this by yielding control between them. They are used for cooperative multitasking, since the control flow is managed by themselves and not the OS. You might see them in a lot of languages like Python, Lua, Kotlin, &#x2026; with keywords like <b><b>yield</b></b>, <b><b>resume</b></b>, <b><b>suspend</b></b>, &#x2026;
</p>

<p>
Coroutines can be either stackful or stackless, we are not gonna dive deep into this concept since most of the time you are going to use stackful coroutines since they allow you to suspend from within a nested stackframe (the only strength of stackless coroutines: efficiency)
</p>

<p>
Coroutines can also be symmetric or asymmetric:
</p>
</div>

<ol class="org-ol">
<li><a id="orga316657"></a>Symmetric coroutines<br />
<div class="outline-text-5" id="text-8-2-1-1">
<p>
The only way to transfer the control flow is by explicitly passing control <b><b>to another coroutine</b></b>.
</p>
</div>
</li>

<li><a id="org281ed42"></a>Asymmetric coroutines (called asymmetric because the control-transfer can go both ways)<br />
<div class="outline-text-5" id="text-8-2-1-2">
<ul class="org-ul">
<li>They have two control-transfer mechanisms:</li>
<li>invoking another coroutine which is going to be the subcoroutine of the calling coroutine</li>
<li>suspending itself and giving control back to the caller</li>
</ul>
</div>
</li>
</ol>
</div>

<div id="outline-container-org6dd9df8" class="outline-4">
<h4 id="org6dd9df8"><span class="section-number-4">8.2.2.</span> Green threads (userland threads)</h4>
<div class="outline-text-4" id="text-8-2-2">
<p>
Green threads, also known as userland threads are managed by a runtime or VM (userspace either way) instead of the OS scheduler (kernel space) that manages standard kernel threads. They are lightweight compared to OS threads as they have a lower overhead (since it is managed in userspace instead of kernel). Even though they are not real OS threads, there are still OS threads that manage them under the hood. Paritculary useful for short-lived tasks. Green threads are most likely to be cooperative and yield control between them, even though it could be possible that they are managed by a runtime that has its own scheduler and can preempt them.
Green threads might be better for multiple short lived tasks (eg: web server) because of their low overhead when context switching and memory usage.
Be careful when using green threads not to use blocking functions, because blocking 1 green thread might mean blocking all the green threads because they most likely all run on the same kernel thread.
</p>
</div>
</div>

<div id="outline-container-orgeac70b6" class="outline-4">
<h4 id="orgeac70b6"><span class="section-number-4">8.2.3.</span> Fibers</h4>
<div class="outline-text-4" id="text-8-2-3">
<p>
TODO
Same as green threads but cooperative multitasking instead of preemptive multitasking
</p>
</div>
</div>

<div id="outline-container-orgcf169a3" class="outline-4">
<h4 id="orgcf169a3"><span class="section-number-4">8.2.4.</span> Preemptive multitasking</h4>
<div class="outline-text-4" id="text-8-2-4">
<p>
In preemptive multitasking it is the underlying architecture (not us, but the OS or the runtime for exemple) that is in charge of choosing which threads to execute and when. This implies that our threads can be stopped (preempted) at any time, even if it is in the middle of a task. This method gives the advantage of not having to worry about a thread being starved, since the underlying architecture is going to make sure that everyone gets enough CPU time.
</p>
</div>
</div>

<div id="outline-container-org6a0139a" class="outline-4">
<h4 id="org6a0139a"><span class="section-number-4">8.2.5.</span> Cooperative multitasking</h4>
<div class="outline-text-4" id="text-8-2-5">
<p>
Contrary to preemptive multitasking, it is the progammer job to choose which and when the differents threads are executed. Threads are going to run until they are explicitly yielding control back. This method gives the advantage to have the progammer to have a fine grained control over his ressources, but also implies that the programmer has to think about not starving threads.
</p>
</div>
</div>

<div id="outline-container-org65f2296" class="outline-4">
<h4 id="org65f2296"><span class="section-number-4">8.2.6.</span> Kernel threads</h4>
<div class="outline-text-4" id="text-8-2-6">
<p>
Multithreading, it is the most basic and history way to do concurrency, it works by running the work on multiple threads that are going to be exectued in parallel (if the CPU can), each thread runs independently of the others. Unlike asynchronous event-driven programming, threads typically block until their assigned task completes.
</p>

<p>
Threads are managed by the OS scheduler which is going to decide when to execute which thread &#x2026;  (TODO image des states des threads etc)
</p>

<p>
Parallelism becomes achievable through multithreading (even though its not 100% guaranteed). Threads also offer robust isolation, with each thread possessing its own execution context, stack, and local variables, ensuring task independence and preventing interference.
</p>

<p>
However, scalability can become a concern when managing numerous threads. The overhead of resource allocation by the operating system kernel for each thread may lead to scalability issues, particularly in high-demand environments. To mitigate this, thread pools are often employed to minimize the overhead of thread creation and destruction, thus optimizing performance and resource utilization.
</p>

<p>
To avoid this overhead, thread pools are often used, which manage a set of threads that can be reused for multiple tasks. This approach reduces the overhead of creating and destroying threads for each task, making it more efficient and scalable.
</p>
</div>
</div>

<div id="outline-container-orgc2fbc76" class="outline-4">
<h4 id="orgc2fbc76"><span class="section-number-4">8.2.7.</span> Event-driven programming</h4>
<div class="outline-text-4" id="text-8-2-7">
<p>
Event-driven programming, is basically an event loop that listen for "events". This architecture. Under the hood this works by having an event loop that is going to poll for events and check regulary if an event has been emitted. Those events can be for exemple interupts or signals.
</p>
</div>
</div>

<div id="outline-container-org5e35baf" class="outline-4">
<h4 id="org5e35baf"><span class="section-number-4">8.2.8.</span> Asynchronous programming (non-blocking IO)</h4>
<div class="outline-text-4" id="text-8-2-8">
<p>
When in this mode the execution flow of the program is unkown because we don't know when a non-blocking function might be ready for use and therefore take back the control flow of the application.
TODO
<a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">https://en.wikipedia.org/wiki/Asynchronous_I/O</a>
Useful if there a lot of IO operations, so that we can start processing other thingswhile waiting for this IO operation.
TODO WHEN NOT TO USE
Can be achieved either by using polling systems (epoll, kqueue, &#x2026;) or events (interupts, signals, &#x2026;)
Under the hood libuv is basically a single threaded <a href="https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop">event-loop</a> which is going to perform all IOs on non-blocking sockets that are polled by pollers like epoll, kqueue, &#x2026;
TODO when interupts are better than pollings (polling mieux si beaucoup)
</p>
</div>
</div>
</div>

<div id="outline-container-org6fbfff0" class="outline-3">
<h3 id="org6fbfff0"><span class="section-number-3">8.3.</span> Zig solutions</h3>
<div class="outline-text-3" id="text-8-3">
<p>
There are multiple ways you currently can do concurent code in ZIG, we are going to explore a few here:
</p>
</div>

<div id="outline-container-org9afeebf" class="outline-4">
<h4 id="org9afeebf"><span class="section-number-4">8.3.1.</span> OS threads (std)</h4>
<div class="outline-text-4" id="text-8-3-1">
</div>
<ol class="org-ol">
<li><a id="org2ffc155"></a>Basics<br />
<div class="outline-text-5" id="text-8-3-1-1">
<p>
Spawning OS thread in Zig is quite simple, since it is built-in in the standard library. Here is an example of how to spawn 2 threads that are going to print numbers from 0 to x in parallel:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #73d216;">//</span><span style="color: #73d216;">std.debug.print("Total CPU cores = {!}\n", .{std.Thread.getCpuCount()});</span>
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">thread1</span> = <span style="color: #b4fa70;">try</span> std.Thread.spawn(.{}, goTo, .{ 1, 5 });
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">thread2</span> = <span style="color: #b4fa70;">try</span> std.Thread.spawn(.{}, goTo, .{ 2, 3 });

    thread1.join();
    thread2.join();
}
<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>(<span style="color: #fcaf3e;">thread_id</span>: <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">max</span>: <span style="color: #8cc4ff;">usize</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">u32</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt;= max) {
        std.debug.print(<span style="color: #e9b96e;">"{} = {}\n"</span>, .{ thread_id, i });
        i += 1;
    }
}
</pre>
</div>
<p>
Note that the std.Thread also offer few other useful functions like `std.Thread.getCpuCount()` to get the number of CPU cores available on the machine.
</p>
<div class="org-src-container">
<pre class="src src-zig">std.debug.print(<span style="color: #e9b96e;">"Total CPU cores = {!}\n"</span>, .{std.Thread.getCpuCount()});
</pre>
</div>
</div>
</li>

<li><a id="orgfc06db9"></a>Thread pool<br />
<div class="outline-text-5" id="text-8-3-1-2">
<p>
You could also use a thread pool in order to have a few threads to multiple jobs and not 1 thread = 1 job
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};
    <span style="color: #b4fa70;">defer</span> _ = gpa.deinit();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pool</span>: <span style="color: #8cc4ff;">std</span>.Thread.Pool = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">try</span> pool.init(.{ .allocator = allocator, .n_jobs = 2 }); <span style="color: #73d216;">// </span><span style="color: #73d216;">if you dont set n_jobs it is simply going to use the total number of cores in your system, but alloactor is obligatory.</span>
    <span style="color: #b4fa70;">defer</span> pool.deinit();

    <span style="color: #b4fa70;">for</span> (0..8) |i| {
        <span style="color: #b4fa70;">try</span> pool.spawn(goTo, .{ <span style="color: #e090d7;">@as</span>(<span style="color: #8cc4ff;">u8</span>, <span style="color: #e090d7;">@intCast</span>(i)), 3 });
    }
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>(<span style="color: #fcaf3e;">thread_id</span>: <span style="color: #8cc4ff;">u8</span>, <span style="color: #fcaf3e;">max</span>: <span style="color: #8cc4ff;">usize</span>) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">i</span>: <span style="color: #8cc4ff;">u32</span> = 0;
    <span style="color: #b4fa70;">while</span> (i &lt;= max) {
        std.debug.print(<span style="color: #e9b96e;">"{} = {}\n"</span>, .{ thread_id, i });
        i += 1;
    }
}
</pre>
</div>
</div>
</li>

<li><a id="orgf635590"></a>Implementation in the std<br />
<div class="outline-text-5" id="text-8-3-1-3">
<p>
Under the hood the threads are either pthread (<a href="https://ziglang.org/documentation/master/std/#std.Thread.use_pthreads">if we are under linux AND linking libc</a>) or it is simpy going to use native OS threads wrapped by a Zig implementation. TODO est ce que cest vrm wrappe ?
</p>

<p>
The advantage of doing multi-threading in Zig is that you don't have to worry about what is the target system going to be, since <b><b>std.Thread</b></b> implementation automatically chooses the native OS threads for the system your are compiling for (except if you want to enforce the use of pthreads). 
</p>

<p>
In C if you are using Windows for exemple, since <b><b>pthreads</b></b> it is not natively supported you would have to use a third-party implementation by adding a compilation tag like so:
</p>
<div class="org-src-container">
<pre class="src src-c">gcc program.c -o program -pthread
</pre>
</div>

<p>
Or worse, you would have to use a completly different library ending up with a lot of pre-processor directives to check if you are using Windows or not which is going to lead to messy code:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdio.h&gt;</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;windows.h&gt;</span>
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;pthread.h&gt;</span>
<span style="color: #e090d7;">#endif</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
DWORD <span style="color: #8cc4ff;">WINAPI</span> <span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">LPVOID</span> <span style="color: #fcaf3e;">lpParam</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> 0;
}
<span style="color: #e090d7;">#else</span>
<span style="color: #8cc4ff;">void</span> *<span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">arg</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> <span style="color: #e9b2e3;">NULL</span>;
}
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #8cc4ff;">HANDLE</span> <span style="color: #fcaf3e;">hThread</span>;
  <span style="color: #8cc4ff;">DWORD</span> <span style="color: #fcaf3e;">dwThreadId</span>;

  hThread = CreateThread(<span style="color: #e9b2e3;">NULL</span>, 0, ThreadFunc, <span style="color: #e9b2e3;">NULL</span>, 0, &amp;dwThreadId);
  <span style="color: #b4fa70;">if</span> (hThread == <span style="color: #e9b2e3;">NULL</span>) {
    printf(<span style="color: #e9b96e;">"Failed to create thread.\n"</span>);
    <span style="color: #b4fa70;">return</span> 1;
  }

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Wait for the thread to finish</span>
  WaitForSingleObject(hThread, INFINITE);

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Close the thread handle</span>
  CloseHandle(hThread);
<span style="color: #e090d7;">#else</span>
  <span style="color: #8cc4ff;">pthread_t</span> <span style="color: #fcaf3e;">thread</span>;
  <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">rc</span>;

  rc = pthread_create(&amp;thread, <span style="color: #e9b2e3;">NULL</span>, ThreadFunc, <span style="color: #e9b2e3;">NULL</span>);
  <span style="color: #b4fa70;">if</span> (rc) {
    printf(<span style="color: #e9b96e;">"Failed to create thread. Return code: %d\n"</span>, rc);
    <span style="color: #b4fa70;">return</span> 1;
  }

  <span style="color: #73d216;">// </span><span style="color: #73d216;">Wait for the thread to finish</span>
  pthread_join(thread, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>

  printf(<span style="color: #e9b96e;">"Everything is done.\n"</span>);

  <span style="color: #b4fa70;">return</span> 0;
}
</pre>
</div>

<p>
Or you could write your own wrapper kind of like the way Zig does (this is not going to work on Windows, but you get the idea):
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdio.h&gt;</span>

<span style="color: #e090d7;">#ifdef</span> _WIN32
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;windows.h&gt;</span>
<span style="color: #e090d7;">#else</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;pthread.h&gt;</span>
<span style="color: #e090d7;">#endif</span>

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">myCreate</span>(<span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">long</span> *<span style="color: #fcaf3e;">thread</span>, <span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">func</span>) {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #b4fa70;">return</span> hThread = CreateThread(<span style="color: #e9b2e3;">NULL</span>, 0, func, <span style="color: #e9b2e3;">NULL</span>, 0, thread);
<span style="color: #e090d7;">#else</span>
  <span style="color: #b4fa70;">return</span> pthread_create(thread, <span style="color: #e9b2e3;">NULL</span>, func, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>
}

<span style="color: #8cc4ff;">void</span> <span style="color: #fce94f;">myJoin</span>(<span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">long</span> <span style="color: #fcaf3e;">thread</span>) {
<span style="color: #e090d7;">#ifdef</span> _WIN32
  <span style="color: #b4fa70;">return</span> WaitForSingleObject(thread, INFINITE);
<span style="color: #e090d7;">#else</span>
  pthread_join(thread, <span style="color: #e9b2e3;">NULL</span>);
<span style="color: #e090d7;">#endif</span>
}

<span style="color: #8cc4ff;">void</span> *<span style="color: #fce94f;">ThreadFunc</span>(<span style="color: #8cc4ff;">void</span> *<span style="color: #fcaf3e;">arg</span>) {
  printf(<span style="color: #e9b96e;">"Thread running...\n"</span>);
  <span style="color: #b4fa70;">return</span> <span style="color: #e9b2e3;">NULL</span>;
}

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
  <span style="color: #8cc4ff;">pthread_t</span> <span style="color: #fcaf3e;">thread</span>; <span style="color: #73d216;">// </span><span style="color: #73d216;">TODO I should also wrap that which is pthread specific</span>

  <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">rc</span> = myCreate(&amp;thread, ThreadFunc);
  <span style="color: #b4fa70;">if</span> (rc) {
    printf(<span style="color: #e9b96e;">"Failed to create thread. Return code: %d\n"</span>, rc);
    <span style="color: #b4fa70;">return</span> 1;
  }

  myJoin(thread);

  printf(<span style="color: #e9b96e;">"Everything is done.\n"</span>);

  <span style="color: #b4fa70;">return</span> 0;
}
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="orgc115139"></a>pthreads vs LinuxThreadImpl<br />
<div class="outline-text-6" id="text-8-3-1-3-1">
<p>
When compiling on Linux, by default your threads are going to use the <a href="https://github.com/ziglang/zig/blob/28476a5ee94d311319941b54e9da66210690ce70/lib/std/Thread.zig#L1042">LinuxThreadImpl</a>. Which under the hood simply is a wrapper around some syscalls in order to manage threads (the code does closely the same thing as the pthread code).
You might have notice that when you are linking libc, Zig is going to use pthreads instead of the <b><b>LinuxThreadImpl</b></b>. This is because pthreads are more performant at the moment and since you are already linking libc it is better to take advantage of that and ue pt hreads.
</p>

<p>
The way we are going to measure which implementation is better is by comparing the time it takes to <b>spawn</b> and <b>destory</b> N threads. It is useless to do work in the threads because no matter the implementation they are going to execute in the same way. It might even be counter-productive because you are going to start comparing the code inside the threads instead of the threads themselves.
</p>

<p>
Note that it is hard to benchmark thread implementations and you can easily end up not directly benchmarking them, if you for exemple try to compare the number of context switches between 2 implementations. Context switch happen <b>randomly</b> whenever the OS scheduler wants it. So trying to analyze that might lead you into false conclusions.
</p>

<p>
TODO tangling psq main
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);

<span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">NB_THREADS</span> = 10000;

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">threads</span>: [NB_THREADS]<span style="color: #8cc4ff;">std</span>.Thread = <span style="color: #e9b2e3;">undefined</span>;

    <span style="color: #b4fa70;">for</span> (0..NB_THREADS) |i| {
        threads[i] = <span style="color: #b4fa70;">try</span> std.Thread.spawn(.{}, goTo, .{});
    }

    <span style="color: #b4fa70;">for</span> (0..NB_THREADS) |i| {
        threads[i].join();
    }
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>() <span style="color: #8cc4ff;">void</span> {}
</pre>
</div>

<p>
If we run this code with hyperfine (100 runs) once while linking libc (using pthreads) and once in vanilla mode (using LinuxThreadImpl), we can sometimes see that there is indeed a slight performance difference between the two:
</p>
<ul class="org-ul">
<li>pthreads = ~274.4 ms += 4.7 ms</li>
<li>LinuxThreadImpl = 280.s ms += 5.9 ms</li>
</ul>

<p>
The difference is so small that even when only spawning and destroying threads we barely see it. In a real world application where this would very unlikely be the bottleneck, which thread implementation you are going to use is very likely to not change anything the way your program perform.
</p>
</div>
</li>
</ol>
</li>

<li><a id="org4307308"></a>Thread synchronization<br />
<div class="outline-text-5" id="text-8-3-1-4">
<p>
Threads can be synchronized with utilities that are the same as most other languages (notably C). So when jumping in the <a href="https://ziglang.org/documentation/master/std/#std.Thread">std doc</a> you should not be suprised and understand most of the features like Mutex and Semaphore.
</p>

<p>
TODO tangling
</p>

<p>
Here is the Zig code:
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">std</span> = <span style="color: #e090d7;">@import</span>(<span style="color: #e9b96e;">"std"</span>);

<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">common</span>: <span style="color: #8cc4ff;">u64</span> = 0;
<span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">m</span> = std.Thread.Mutex{};

<span style="color: #b4fa70;">pub</span> <span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">main</span>() !<span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">gpa</span> = std.heap.GeneralPurposeAllocator(.{}){};
    <span style="color: #b4fa70;">defer</span> _ = gpa.deinit();
    <span style="color: #b4fa70;">const</span> <span style="color: #fcaf3e;">allocator</span> = gpa.allocator();

    <span style="color: #b4fa70;">var</span> <span style="color: #fcaf3e;">pool</span>: <span style="color: #8cc4ff;">std</span>.Thread.Pool = <span style="color: #e9b2e3;">undefined</span>;
    <span style="color: #b4fa70;">try</span> pool.init(.{ .allocator = allocator });

    <span style="color: #b4fa70;">for</span> (0..1000) |_| {
        <span style="color: #b4fa70;">try</span> pool.spawn(goTo, .{});
    }

    pool.deinit();

    std.debug.print(<span style="color: #e9b96e;">"{d}"</span>, .{common});
}

<span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">goTo</span>() <span style="color: #8cc4ff;">void</span> {
    m.lock();
    common += 1;
    m.unlock();
}
</pre>
</div>

<p>
And the equivalent C code:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;pthread.h&gt;</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdio.h&gt;</span>
<span style="color: #e090d7;">#include</span> <span style="color: #e9b96e;">&lt;stdlib.h&gt;</span>

<span style="color: #e090d7;">#define</span> <span style="color: #fcaf3e;">NB_THREADS</span> 10000

<span style="color: #8cc4ff;">pthread_mutex_t</span> <span style="color: #fcaf3e;">mutex</span>;
<span style="color: #8cc4ff;">unsigned</span> <span style="color: #8cc4ff;">long</span> <span style="color: #8cc4ff;">long</span> <span style="color: #fcaf3e;">common</span> = 0;

<span style="color: #8cc4ff;">void</span>* <span style="color: #fce94f;">goTo</span>(<span style="color: #8cc4ff;">void</span>* <span style="color: #fcaf3e;">arg</span>) {
    pthread_mutex_lock(&amp;mutex);
    common += 1;
    pthread_mutex_unlock(&amp;mutex);
    <span style="color: #b4fa70;">return</span> <span style="color: #e9b2e3;">NULL</span>;
}

<span style="color: #8cc4ff;">int</span> <span style="color: #fce94f;">main</span>() {
    <span style="color: #8cc4ff;">pthread_t</span> <span style="color: #fcaf3e;">threads</span>[NB_THREADS];
    <span style="color: #8cc4ff;">int</span> <span style="color: #fcaf3e;">i</span>;

    <span style="color: #b4fa70;">if</span> (pthread_mutex_init(&amp;mutex, <span style="color: #e9b2e3;">NULL</span>) != 0) {
        printf(<span style="color: #e9b96e;">"Mutex initialization failed\n"</span>);
        <span style="color: #b4fa70;">return</span> 1;
    }

    <span style="color: #b4fa70;">for</span> (i = 0; i &lt; NB_THREADS; i++) {
        <span style="color: #b4fa70;">if</span> (pthread_create(&amp;threads[i], <span style="color: #e9b2e3;">NULL</span>, goTo, <span style="color: #e9b2e3;">NULL</span>) != 0) {
            printf(<span style="color: #e9b96e;">"Thread creation failed\n"</span>);
            <span style="color: #b4fa70;">return</span> 1;
        }
    }

    <span style="color: #b4fa70;">for</span> (i = 0; i &lt; NB_THREADS; i++) {
        pthread_join(threads[i], <span style="color: #e9b2e3;">NULL</span>);
    }

    pthread_mutex_destroy(&amp;mutex);

    printf(<span style="color: #e9b96e;">"%llu\n"</span>, common);

    <span style="color: #b4fa70;">return</span> 0;
}
</pre>
</div>
</div>
</li>



<li><a id="orge4074c7"></a>Leaky abstraction<br />
<div class="outline-text-5" id="text-8-3-1-5">
<p>
There are 2 things you can tweak when using <b>std.Thread</b>: the stack size and the allocator that is going to allocate the memory for the thread.
TODO: est ce que je peux fine tuned threads en Zig ? (priority, stack size, &#x2026;)
</p>
</div>
</li>

<li><a id="org21e52ef"></a>Conclusion<br />
<div class="outline-text-5" id="text-8-3-1-6">
<p>
Zig threads are really useful since they have a very user-friendly abstraction with not a lot of functionalites that are almost never used anyway. This abstraction is also very useful for what we saw earlier, you don't have to worry about the target system, Zig is going to choose the right implementation for you.
</p>

<p>
But this leaky abstraction comes at a cost, you can not fine-tune your threads as much as you would like to.
</p>

<p>
If you need specific thread functionalities, like the ones we talked about, you can still do that in Zig by wrapping the C pthread library for exemple or directly use the OS native threads you want.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org702e7c7" class="outline-4">
<h4 id="org702e7c7"><span class="section-number-4">8.3.2.</span> async/await</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
This method uses suspensible stackless coroutines, this solution does not necessarly mean that you are going to have multiple threads or parallelism.
</p>

<p>
We are not going to dive deeper into this solution because it has been deprecated since 0.11 and is not coming back soon.
</p>

<p>
However it is still a good reading and way to understand concurency to read this <a href="https://zig.guide/async/introduction/">very good guide</a> that was made for this solution.
By reading this you might notice that <b><b>async/await</b></b> might <b><b>never</b></b> come out.
</p>

<p>
Note that if this solution is to be brought again it might come with breaking changes, so the syntax might change.
</p>

<p>
You can find a <a href="https://github.com/ziglang/zig/issues/6025">Github discussion</a> about the progress of this feature and why it is not implemented in the current version.
</p>

<p>
You can see <a href="https://ziglang.org/download/0.12.0/release-notes.html#AsyncAwait-Feature-Status">here</a> the main reasons why this solution is not implemented yet.
</p>
</div>

<ol class="org-ol">
<li><a id="org1cb478b"></a>Function coloring<br />
<div class="outline-text-5" id="text-8-3-2-1">
<p>
Green threads make function colors disapear ???? (dependences entre threads)
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org30ba5c9" class="outline-4">
<h4 id="org30ba5c9"><span class="section-number-4">8.3.3.</span> libxev</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
Using an event loop (by wrapping libuv or using libxev which is the equivalent buz in ZIG)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-org571dff4" class="outline-4">
<h4 id="org571dff4"><span class="section-number-4">8.3.4.</span> Fibers</h4>
<div class="outline-text-4" id="text-8-3-4">
<p>
Using fibers (<a href="https://github.com/kprotty/zefi">https://github.com/kprotty/zefi</a>, <a href="https://github.com/kassane/fiber">https://github.com/kassane/fiber</a>)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-org2440aea" class="outline-4">
<h4 id="org2440aea"><span class="section-number-4">8.3.5.</span> zigcoro</h4>
<div class="outline-text-4" id="text-8-3-5">
<p>
This solution uses stackful asymmetric coroutines.
stackful asymmetric coroutines
This library is made to provide similar functionalities to async/await "old" model, so that if/when the official async/await solution is coming back, it will be easy to switch your project from using zigcoro to the official async/await.
async/await built on top of libxev (<a href="https://github.com/rsepassi/zigcoro">https://github.com/rsepassi/zigcoro</a>)
TODO exemple
</p>
</div>
</div>

<div id="outline-container-org9836cd2" class="outline-4">
<h4 id="org9836cd2"><span class="section-number-4">8.3.6.</span> Using C libraries</h4>
<div class="outline-text-4" id="text-8-3-6">
<p>
&#x2026; obviously you can still use C libraries that do async stuff :)
TODO exemple
</p>
</div>
</div>
</div>

<div id="outline-container-org234870a" class="outline-3">
<h3 id="org234870a"><span class="section-number-3">8.4.</span> Conclusion</h3>
<div class="outline-text-3" id="text-8-4">
<p>
TODO: qu est ce que je pourrais bien dire de + que dans le contenu, parler du potentiel ?
</p>

<p>
TODO MES NOTES ---&#x2013;&#x2014; pas besoin de lire ca, cest juste pour moi pour approfondir certains sujets plus tard
</p>

<ul class="org-ul">
<li>"libuv and OSes will usually run background/worker threads and/or polling to perform tasks in a non-blocking manner." est ce que cest comment ca under the hood les non blocking async ?</li>

<li>"The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on"</li>

<li>tokio equivalent in zig ?</li>
</ul>
</div>
</div>

<div id="outline-container-org9d9a2b9" class="outline-3">
<h3 id="org9d9a2b9"><span class="section-number-3">8.5.</span> Sources:</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li><a href="https://dl.acm.org/doi/pdf/10.1145/1462166.1462167">https://dl.acm.org/doi/pdf/10.1145/1462166.1462167</a></li>
<li><a href="https://www.lua.org/pil/9.1.html">https://www.lua.org/pil/9.1.html</a></li>
<li><a href="https://blog.orhun.dev/zig-bits-04/">https://blog.orhun.dev/zig-bits-04/</a> (regarder regul pour voir si il m a rep)</li>
<li><a href="https://github.com/mitchellh/libxev/issues/92">https://github.com/mitchellh/libxev/issues/92</a> (regul &#x2026;)</li>
<li>ChatGPT et GH Copilot</li>
<li><a href="https://github.com/lewissbaker/cppcoro">https://github.com/lewissbaker/cppcoro</a></li>
<li><a href="https://ericniebler.com/2020/11/08/structured-concurrency/">https://ericniebler.com/2020/11/08/structured-concurrency/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">https://en.wikipedia.org/wiki/Fiber_(computer_science)</a></li>
<li><a href="https://github.com/rsepassi/zigcoro">https://github.com/rsepassi/zigcoro</a></li>
<li><a href="https://github.com/mitchellh/libxev">https://github.com/mitchellh/libxev</a></li>
<li><a href="https://github.com/libuv/libuv">https://github.com/libuv/libuv</a></li>
<li><a href="https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst">https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/guide/basics.html">https://docs.libuv.org/en/v1.x/guide/basics.html</a> (ptetre le meme que celui au dessus)</li>
<li><a href="https://github.com/dotnet/runtimelab/issues/2398">https://github.com/dotnet/runtimelab/issues/2398</a></li>
<li><a href="https://kristoff.it/blog/zig-colorblind-async-await/">https://kristoff.it/blog/zig-colorblind-async-await/</a></li>
<li><a href="https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/">https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop">https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop</a></li>
<li><a href="https://docs.libuv.org/en/v1.x/guide/threads.html">https://docs.libuv.org/en/v1.x/guide/threads.html</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i">https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i</a></li>
<li><a href="https://github.com/ziglang/zig/issues/6025">https://github.com/ziglang/zig/issues/6025</a></li>
<li><a href="https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/">https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/</a></li>
<li><a href="https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network">https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network</a></li>
<li><a href="https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines">https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines</a></li>
<li><a href="https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time">https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time</a>.</li>
<li><a href="https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines">https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf95db38" class="outline-2">
<h2 id="orgf95db38"><span class="section-number-2">9.</span> Web frameworks</h2>
<div class="outline-text-2" id="text-9">
<p>
In this section we are going to explore the different ways of doing WEB servers in Zig.
</p>
</div>

<div id="outline-container-org7901eff" class="outline-3">
<h3 id="org7901eff"><span class="section-number-3">9.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-9-1">
<p>
TODO talk about WEB in general 
</p>
</div>
</div>

<div id="outline-container-orge04c6d9" class="outline-3">
<h3 id="orge04c6d9"><span class="section-number-3">9.2.</span> Zig solutions</h3>
</div>

<div id="outline-container-orgbc3ed27" class="outline-3">
<h3 id="orgbc3ed27"><span class="section-number-3">9.3.</span> Zap</h3>
<div class="outline-text-3" id="text-9-3">
</div>
<div id="outline-container-org8b160f8" class="outline-4">
<h4 id="org8b160f8"><span class="section-number-4">9.3.1.</span> Description</h4>
<div class="outline-text-4" id="text-9-3-1">
<p>
Zap is a micro web framework that is mainly uses to write REST APIs.
</p>

<p>
Zap isn't really a fully Zig project, it just wraps and leverages the power of <a href="https://facil.io">facil.io</a>. By that I want to emphasize 2 things:
</p>
<ul class="org-ul">
<li>All the heavy lifting is done in C, so we can't give much of the performances merits to Zig on this</li>
<li>From the programmer point of view it seems to you like your project is 100% Zig, so you have no C overhead (except linking libc)</li>
</ul>

<p>
The framework works by defining callbacks that are going to be called when a certain event happens. For example, you can define a callback that is going to be called when a request is received.
</p>

<p>
Here you define the callback
+#BEGIN<sub>SRC</sub> zig
var listener = zap.Endpoint.Listener.init(
    allocator,
    .{
        .port = 3000,
        .on<sub>request</sub> = on<sub>request</sub>, // HERE
        .log = true,
        .public<sub>folder</sub> = "examples/endpoint/html",
        .max<sub>clients</sub> = 100000,
        .max<sub>body</sub><sub>size</sub> = 100 * 1024 * 1024,
    },
);
#+END<sub>SRC</sub>
</p>

<p>
And then it is going to call the following function
</p>
<div class="org-src-container">
<pre class="src src-zig"><span style="color: #b4fa70;">fn</span> <span style="color: #fce94f;">on_request</span>(<span style="color: #fcaf3e;">r</span>: <span style="color: #8cc4ff;">zap</span>.Request) <span style="color: #8cc4ff;">void</span> {
    <span style="color: #b4fa70;">if</span> (r.path) |the_path| {
        std.debug.print(<span style="color: #e9b96e;">"REQUESTED PATH: {s}\n"</span>, .{the_path});
    }

    r.sendBody(<span style="color: #e9b96e;">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from ZAP!!!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>) <span style="color: #b4fa70;">catch</span> <span style="color: #b4fa70;">return</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgde54771" class="outline-4">
<h4 id="orgde54771"><span class="section-number-4">9.3.2.</span> Exemples</h4>
<div class="outline-text-4" id="text-9-3-2">
<p>
The <a href="https://github.com/zigzap/zap">repo</a> gives you a lot of <a href="https://github.com/zigzap/zap/tree/master/examples">exemples</a> in order to get started.
</p>
</div>
</div>

<div id="outline-container-org36d49a4" class="outline-4">
<h4 id="org36d49a4"><span class="section-number-4">9.3.3.</span> Alternatives and performance comparaison</h4>
<div class="outline-text-4" id="text-9-3-3">
<p>
The zap library provides a few other REST API frameworks to compare with Zap, all the codes fromt he different languages/framework just return a simple "Hello World" message when their endpoint is called.
</p>

<p>
The benchmarks compare 2 different metrics:
</p>


<div id="orgf823a94" class="figure">
<p><img src="./images/req_per_sec_graph.png" alt="req_per_sec_graph.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Requests per second for different frameworks</p>
</div>


<div id="org0255578" class="figure">
<p><img src="./images/xfer_per_sec_graph.png" alt="xfer_per_sec_graph.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Transfers per second for different frameworks</p>
</div>

<p>
We can see that zap is very performant which is what was excepted from something that leverages a powerful C library like facil.io.
</p>

<p>
TODO I plan to add more frameworks in order to have more comparaison in the future
 I think it yould be more intersting to compare it with other frameworks that those here, like
</p>
</div>
</div>

<div id="outline-container-orgcd2d344" class="outline-4">
<h4 id="orgcd2d344"><span class="section-number-4">9.3.4.</span> Conclusion</h4>
<div class="outline-text-4" id="text-9-3-4">
<p>
Zap is a very intersting project that is not used in production as far I know by anyone except by the author of the framework itself. So I couldn't find any repository of a project uszing zap anywhere, I tried asking on the official Discord but I didn't get any answer.
</p>

<p>
Even though it should be working for almost all your use cases, it still is a microframework which means that there are not a lot of batteries included and if you need advanced features, you might have to those yourself.
</p>

<p>
Since Zig is a low level language you are going to have a lot of boilerplate and small things like memory to manage manually. Those are things than can easily be avoided by using other languages (Java, Go, Node, &#x2026;)
</p>

<p>
It is also important to note that this is a young project with not a lot of contributors and a very small community. So if you are going to use Zap you might have to figure out things on your own or write on the <a href="https://discord.gg/gcZm8f8K">project discord</a>. You might aswell find codes or documentations that are oudated.
</p>

<p>
To conclude if you don't need <b><b>high</b></b> performances (C like), I wouldn't recommend this framework to build your REST APIs.
</p>
</div>
</div>

<div id="outline-container-orgd59fa09" class="outline-4">
<h4 id="orgd59fa09"><span class="section-number-4">9.3.5.</span> Mes notes</h4>
<div class="outline-text-4" id="text-9-3-5">
<p>
Callback based, we define certain callbacks, we configure from there
often not updated, hard to find yourself
je devrai aussi analyer facilio qui est ce qui est derriere la scene
</p>
</div>
</div>
</div>

<div id="outline-container-orgb8faf58" class="outline-3">
<h3 id="orgb8faf58"><span class="section-number-3">9.4.</span> HTTP from the std</h3>
<div class="outline-text-3" id="text-9-4">
</div>
<div id="outline-container-org737481a" class="outline-4">
<h4 id="org737481a"><span class="section-number-4">9.4.1.</span> Description</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
Http.zig: Dispatcher based, you create the dispatch chai (As far as I understand it)
</p>

<p>
just a server
</p>

<p>
from discord creator of zap: To put it simply: std.http has no concept of multiple concurrent connections. So you have to write your own "framework" handling that, e.g. using a thread-pool for handling requests and implementing some sort of polling to know when there's activity on the connections, and combine the two (poll &amp; pool).
</p>

<p>
std.http is very useful for what it was designed for. The Client was added to fetch packages, the Server to test the client. It's not designed to be a 100% out-of-the-box integratable implementation of everything HTTP/web, nor is it meant to be used in production in a massively multithreaded setup. 
</p>
</div>
</div>
<div id="outline-container-orgea2726d" class="outline-4">
<h4 id="orgea2726d"><span class="section-number-4">9.4.2.</span> Exemples</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
TODO
</p>
</div>
</div>

<div id="outline-container-org11ff70e" class="outline-4">
<h4 id="org11ff70e"><span class="section-number-4">9.4.3.</span> Tokamak</h4>
<div class="outline-text-4" id="text-9-4-3">
<p>
Middleware (scoped) and DI Based
</p>
</div>
</div>

<div id="outline-container-orged912be" class="outline-4">
<h4 id="orged912be"><span class="section-number-4">9.4.4.</span> Jetzig</h4>
<div class="outline-text-4" id="text-9-4-4">
<p>
Middleware (as part of a request chain) and Convention based
built on top of std.http for the moment
</p>

<p>
TODO: faire un benchmark avec plein de techo (rust, go, node, bun, &#x2026;) ET toutes les methodes vues au dessus
points forts/points faibles de chacun
</p>
</div>
</div>
</div>

<div id="outline-container-orge0fd39b" class="outline-3">
<h3 id="orge0fd39b"><span class="section-number-3">9.5.</span> Conclusion</h3>
<div class="outline-text-3" id="text-9-5">
<p>
Sources:
<a href="https://www.reddit.com/r/reactjs/comments/16blsh3/how_do_i_use_react_with_an_express_application/">https://www.reddit.com/r/reactjs/comments/16blsh3/how_do_i_use_react_with_an_express_application/</a>
<a href="https://lemire.me/blog/2023/10/07/web-server-hello-world-benchmark-go-vs-node-js-vs-nim-vs-bun/">https://lemire.me/blog/2023/10/07/web-server-hello-world-benchmark-go-vs-node-js-vs-nim-vs-bun/</a>
</p>
</div>
</div>
</div>

<div id="outline-container-orgbb603f3" class="outline-2">
<h2 id="orgbb603f3"><span class="section-number-2">10.</span> Case studies</h2>
<div class="outline-text-2" id="text-10">
</div>
<div id="outline-container-org2891e31" class="outline-3">
<h3 id="org2891e31"><span class="section-number-3">10.1.</span> Interacting with processuses</h3>
<div class="outline-text-3" id="text-10-1">
<p>
TODO
<a href="https://github.com/Pismice/rename-i3-workspace">https://github.com/Pismice/rename-i3-workspace</a>
Was zig the good choice ?
Was it easy ?
What were the problems ?
What libraries did i use ?
</p>
</div>
</div>
</div>

<div id="outline-container-org33dc4c1" class="outline-2">
<h2 id="org33dc4c1"><span class="section-number-2">11.</span> Bibliography</h2>
<div class="outline-text-2" id="text-11">
<style>.csl-left-margin{float: left; padding-right: 0em;}
 .csl-right-inline{margin: 0 0 0 2em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">[1]</div><div class="csl-right-inline">Documentation - The Zig Programming Language. Accessed: Mar. 02, 2024. [Online]. Available: <a href="https://ziglang.org/documentation/0.11.0/#Introduction">https://ziglang.org/documentation/0.11.0/#Introduction</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>
    <div class="csl-left-margin">[2]</div><div class="csl-right-inline">Comptime | zig.guide. Accessed: Mar. 17, 2024. [Online]. Available: <a href="https://zig.guide/language-basics/comptime">https://zig.guide/language-basics/comptime</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_3"></a>
    <div class="csl-left-margin">[3]</div><div class="csl-right-inline">Cross compilation | zig.guide. Accessed: Mar. 05, 2024. [Online]. Available: <a href="https://zig.guide/build-system/cross-compilation">https://zig.guide/build-system/cross-compilation</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_4"></a>
    <div class="csl-left-margin">[4]</div><div class="csl-right-inline">Welcome | zig.guide. Accessed: Mar. 02, 2024. [Online]. Available: <a href="https://zig.guide/">https://zig.guide/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_5"></a>
    <div class="csl-left-margin">[5]</div><div class="csl-right-inline">Documentation - The Zig Programming Language - Vectors. Accessed: May 21, 2024. [Online]. Available: <a href="https://ziglang.org/documentation/0.12.0/#Vectors">https://ziglang.org/documentation/0.12.0/#Vectors</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_6"></a>
    <div class="csl-left-margin">[6]</div><div class="csl-right-inline">Niklas-heer/speed-comparison: A repo which compares the speed of different programming languages. Accessed: Mar. 26, 2024. [Online]. Available: <a href="https://github.com/niklas-heer/speed-comparison/tree/master">https://github.com/niklas-heer/speed-comparison/tree/master</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_7"></a>
    <div class="csl-left-margin">[7]</div><div class="csl-right-inline">Leibniz formula for , <i>Wikipedia</i>. Apr. 04, 2024. Accessed: Apr. 14, 2024. [Online]. Available: <a href="https://en.wikipedia.org/w/index.php?title=Leibniz_formula_for_%CF%80&oldid=1217146933">https://en.wikipedia.org/w/index.php?title=Leibniz_formula_for_%CF%80&#38;oldid=1217146933</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_8"></a>
    <div class="csl-left-margin">[8]</div><div class="csl-right-inline">Intel Intrinsics Guide. Accessed: May 21, 2024. [Online]. Available: <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_9"></a>
    <div class="csl-left-margin">[9]</div><div class="csl-right-inline">Arm A64 Instruction Set Architecture. Accessed: May 21, 2024. [Online]. Available: <a href="https://developer.arm.com/documentation/ddi0596/2021-03/SIMD-FP-Instructions/FMADD--Floating-point-fused-Multiply-Add--scalar--?lang=en">https://developer.arm.com/documentation/ddi0596/2021-03/SIMD-FP-Instructions/FMADD--Floating-point-fused-Multiply-Add--scalar--?lang=en</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_10"></a>
    <div class="csl-left-margin">[10]</div><div class="csl-right-inline">D. Peter, Hyperfine. Mar. 2023. Accessed: Apr. 23, 2024. [Online]. Available: <a href="https://github.com/sharkdp/hyperfine">https://github.com/sharkdp/hyperfine</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_11"></a>
    <div class="csl-left-margin">[11]</div><div class="csl-right-inline">Hanabi1224/Programming-Language-Benchmarks: Yet another implementation of computer language benchmarks game. Accessed: May 05, 2024. [Online]. Available: <a href="https://github.com/hanabi1224/Programming-Language-Benchmarks">https://github.com/hanabi1224/Programming-Language-Benchmarks</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_12"></a>
    <div class="csl-left-margin">[12]</div><div class="csl-right-inline">Zig VS C benchmarks, Which programming language or compiler is faster. Accessed: May 05, 2024. [Online]. Available: <a href="https://programming-language-benchmarks.vercel.app/zig-vs-c">https://programming-language-benchmarks.vercel.app/zig-vs-c</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_13"></a>
    <div class="csl-left-margin">[13]</div><div class="csl-right-inline">1 Billion Row Challenge. Accessed: May 07, 2024. [Online]. Available: <a href="https://1brc.dev/">https://1brc.dev/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_14"></a>
    <div class="csl-left-margin">[14]</div><div class="csl-right-inline">D. van Kooten, Dannyvankooten/1brc. Mar. 11, 2024. Accessed: Mar. 26, 2024. [Online]. Available: <a href="https://github.com/dannyvankooten/1brc">https://github.com/dannyvankooten/1brc</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_15"></a>
    <div class="csl-left-margin">[15]</div><div class="csl-right-inline">One Billion Rows Challenge in C. Accessed: May 05, 2024. [Online]. Available: <a href="https://www.dannyvankooten.com/blog/2024/1brc/">https://www.dannyvankooten.com/blog/2024/1brc/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_16"></a>
    <div class="csl-left-margin">[16]</div><div class="csl-right-inline">A. Lee, Candrewlee14/1brc-zig. Apr. 26, 2024. Accessed: May 05, 2024. [Online]. Available: <a href="https://github.com/candrewlee14/1brc-zig">https://github.com/candrewlee14/1brc-zig</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_17"></a>
    <div class="csl-left-margin">[17]</div><div class="csl-right-inline">A. Mykolaichuk, Almmiko/1brc-zig. Mar. 17, 2024. Accessed: Mar. 26, 2024. [Online]. Available: <a href="https://github.com/almmiko/1brc-zig">https://github.com/almmiko/1brc-zig</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_18"></a>
    <div class="csl-left-margin">[18]</div><div class="csl-right-inline">WangYi , Wangyi-fudan/wyhash. May 12, 2024. Accessed: May 12, 2024. [Online]. Available: <a href="https://github.com/wangyi-fudan/wyhash">https://github.com/wangyi-fudan/wyhash</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_19"></a>
    <div class="csl-left-margin">[19]</div><div class="csl-right-inline">One Billion Rows Challenge in C. Accessed: May 07, 2024. [Online]. Available: <a href="https://www.dannyvankooten.com/blog/2024/1brc/">https://www.dannyvankooten.com/blog/2024/1brc/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_20"></a>
    <div class="csl-left-margin">[20]</div><div class="csl-right-inline">Learning Zig - Heap Memory &#38; Allocators. Accessed: Mar. 03, 2024. [Online]. Available: <a href="https://www.openmymind.net/learning_zig/heap_memory/">https://www.openmymind.net/learning_zig/heap_memory/</a></div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_21"></a>
    <div class="csl-left-margin">[21]</div><div class="csl-right-inline">Ziglang/zig. Zig Programming Language, Mar. 02, 2024. Accessed: Mar. 02, 2024. [Online]. Available: <a href="https://github.com/ziglang/zig">https://github.com/ziglang/zig</a></div>
  </div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: tetratrux</p>
<p class="date">Created: 2024-05-23 gio 14:01</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
