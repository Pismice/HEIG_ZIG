* Concurrency
** Introduction
The objectives of this chapter is to go in depth about the different ways to do concurrency in ZIG.

We are going to explore the different ways to do concurrency in general (not Zig related) and then we could use a few of those solutions in ZIG.

By the end you should be able to see the pros and cons of each solution and choose the one that fits you in Zig.

** Definitions
Before diving into the different ways to do concurrency in ZIG, let's first define some terms that are useful to understand the basics of concurrency (not related to Zig).

*** Coroutine
Courtines enable the management of concurrent tasks like callbacks do (which make them not concurrent by nature but they are a tool to achieve concurrency). Their great power lies in their ability to write concurent task like you would write sequential code. They achieve this by yielding control between them. They are used for cooperative multitasking, since the control flow is managed by themselves and not the OS. You might see them in a lot of languages like Python, Lua, Kotlin, ... with keywords like **yield**, **resume**, **suspend**, ...

Coroutines can be either stackful or stackless, we are not gonna dive deep into this concept since most of the time you are going to use stackful coroutines since they allow you to suspend from within a nested stackframe (the only strength of stackless coroutines: efficiency)

Coroutines can also be symmetric or asymmetric:

**** Symmetric coroutines
The only way to transfer the control flow is by explicitly passing control **to another coroutine**.

**** Asymmetric coroutines (called asymmetric because the control-transfer can go both ways)
- They have two control-transfer mechanisms:
1. invoking another coroutine which is going to be the subcoroutine of the calling coroutine
2. suspending itself and giving control back to the caller

*** Green threads (userland threads)
Green threads, also known as userland threads are managed by a runtime or VM instead of the OS with standard kernel threads. They are lightweight compared to OS threads as they have a lower overhead (since it is managed in userspace instead of kernel). Even though they are not real OS threads, there are still OS threads that manage them under the hood. Paritculary useful for short-lived tasks.
- preemptive multitasking ou cooperative (TODO JE NE SAIS TOUJOURS PAS psq le runtime peut toujours les preempter)

*** Fibers
Same as green threads but cooperative multitasking instead of preemptive multitasking

*** Preemptive multitasking
In preemptive multitasking it is the underlying architecture (not us, but the OS or the runtime for exemple) that is in charge of choosing which threads to execute and when. This implies that our threads can be stopped (preempted) at any time, even if it is in the middle of a task. This method gives the advantage of not having to worry about a thread being starved, since the underlying architecture is going to make sure that everyone gets enough CPU time.

*** Cooperative multitasking
Contrary to preemptive multitasking, it is the progammer job to choose which and when the differents threads are executed. Threads are going to run until they are explicitly yielding control back. This method gives the advantage to have the progammer to have a fine grained control over his ressources, but also implies that the programmer has to think about not starving threads.

*** Thread
Multithreading, it is the most basic and history way to do concurrency, it works by running the work on multiple threads that are going to be exectued in parallel (if the CPU can), each thread runs independently of the others. Unlike asynchronous event-driven programming, threads typically block until their assigned task completes.

Parallelism becomes achievable through multithreading (even though its not 100% guaranteed). Threads also offer robust isolation, with each thread possessing its own execution context, stack, and local variables, ensuring task independence and preventing interference.

However, scalability can become a concern when managing numerous threads. The overhead of resource allocation by the operating system kernel for each thread may lead to scalability issues, particularly in high-demand environments. To mitigate this, thread pools are often employed to minimize the overhead of thread creation and destruction, thus optimizing performance and resource utilization.
To avoid this overhead, thread pools are often used, which manage a set of threads that can be reused for multiple tasks. This approach reduces the overhead of creating and destroying threads for each task, making it more efficient and scalable.

*** Event-driven programming
Event-driven programming, is basically an event loop that listen for "events". This architecture. Under the hood this works by having an event loop that is going to poll for events and check regulary if an event has been emitted. Those events can be for exemple interupts or signals.

*** Asynchronous programming (non-blocking IO)
TODO
https://en.wikipedia.org/wiki/Asynchronous_I/O
Useful if there a lot of IO operations, so that we can start processing other thingswhile waiting for this IO operation.
TODO WHEN NOT TO USE
Can be achieved either by using polling systems (epoll, kqueue, ...) or events (interupts, signals, ...)
Under the hood libuv is basically a single threaded [[https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop][event-loop]] which is going to perform all IOs on non-blocking sockets that are polled by pollers like epoll, kqueue, ...

** Zig solutions
There are multiple ways you currently can do concurent code in ZIG, we are going to explore a few here:

*** OS threads (std)
**** Basics
Spawning OS thread in Zig is quite simple, since it is built-in in the standard library. Here is an example of how to spawn 2 threads that are going to print numbers from 0 to x in parallel:
#+begin_src zig :imports '(std) :main 'no :testsuite 'no
pub fn main() !void {
    //std.debug.print("Total CPU cores = {!}\n", .{std.Thread.getCpuCount()});
    const thread1 = try std.Thread.spawn(.{}, goTo, .{ 1, 5 });
    const thread2 = try std.Thread.spawn(.{}, goTo, .{ 2, 3 });

    thread1.join();
    thread2.join();
}
fn goTo(thread_id: u8, max: usize) void {
    var i: u32 = 0;
    while (i <= max) {
        std.debug.print("{} = {}\n", .{ thread_id, i });
        i += 1;
    }
}
#+end_src
Note that the std.Thread also offer few other useful functions like `std.Thread.getCpuCount()` to get the number of CPU cores available on the machine.
#+begin_src zig :imports '(std) :main 'yes :testsuite 'no
std.debug.print("Total CPU cores = {!}\n", .{std.Thread.getCpuCount()});
#+end_src

**** Thread pool
You could also use a thread pool in order to have a few threads to multiple jobs and not 1 thread = 1 job
#+begin_src zig :imports '(std) :main 'yes :testsuite 'no
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var pool: std.Thread.Pool = undefined;
    try pool.init(.{ .allocator = allocator, .n_jobs = 2 }); // if you dont set n_jobs it is simply going to use the total number of cores in your system, but alloactor is obligatory.
    defer pool.deinit();

    for (0..8) |i| {
        try pool.spawn(goTo, .{ @as(u8, @intCast(i)), 3 });
    }
}

fn goTo(thread_id: u8, max: usize) void {
    var i: u32 = 0;
    while (i <= max) {
        std.debug.print("{} = {}\n", .{ thread_id, i });
        i += 1;
    }
}
#+end_src

**** Implementation in the std
Under the hood the threads are either pthread ([[https://ziglang.org/documentation/master/std/#std.Thread.use_pthreads][if we are under linux AND linking libc]]) or it is simpy going to use native OS threads wrapped by a Zig implementation. TODO est ce que cest vrm wrappe ?

The advantage of doing multi-threading in Zig is that you don't have to worry about what is the target system going to be, since **std.Thread** implementation automatically chooses the native OS threads for the system your are compiling for (except if you want to enforce the use of pthreads). 

In C if you are using Windows for exemple, since **pthreads** it is not natively supported you would have to use a third-party implementation by adding a compilation tag like so:
#+begin_src c
gcc program.c -o program -pthread
#+end_src

Or worse, you would have to use a completly different library ending up with a lot of pre-processor directives to check if you are using Windows or not which is going to lead to messy code:
#+begin_src c
#include <stdio.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

#ifdef _WIN32
DWORD WINAPI ThreadFunc(LPVOID lpParam) {
  printf("Thread running...\n");
  return 0;
}
#else
void *ThreadFunc(void *arg) {
  printf("Thread running...\n");
  return NULL;
}
#endif

int main() {
#ifdef _WIN32
  HANDLE hThread;
  DWORD dwThreadId;

  hThread = CreateThread(NULL, 0, ThreadFunc, NULL, 0, &dwThreadId);
  if (hThread == NULL) {
    printf("Failed to create thread.\n");
    return 1;
  }

  // Wait for the thread to finish
  WaitForSingleObject(hThread, INFINITE);

  // Close the thread handle
  CloseHandle(hThread);
#else
  pthread_t thread;
  int rc;

  rc = pthread_create(&thread, NULL, ThreadFunc, NULL);
  if (rc) {
    printf("Failed to create thread. Return code: %d\n", rc);
    return 1;
  }

  // Wait for the thread to finish
  pthread_join(thread, NULL);
#endif

  printf("Everything is done.\n");

  return 0;
}
#+end_src

Or you could write your own wrapper kind of like the way Zig does (this is not going to work on Windows, but you get the idea):
#+begin_src c
#include <stdio.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

int myCreate(unsigned long *thread, void *func) {
#ifdef _WIN32
  return hThread = CreateThread(NULL, 0, func, NULL, 0, thread);
#else
  return pthread_create(thread, NULL, func, NULL);
#endif
}

void myJoin(unsigned long thread) {
#ifdef _WIN32
  return WaitForSingleObject(thread, INFINITE);
#else
  pthread_join(thread, NULL);
#endif
}

void *ThreadFunc(void *arg) {
  printf("Thread running...\n");
  return NULL;
}

int main() {
  pthread_t thread; // TODO I should also wrap that which is pthread specific

  int rc = myCreate(&thread, ThreadFunc);
  if (rc) {
    printf("Failed to create thread. Return code: %d\n", rc);
    return 1;
  }

  myJoin(thread);

  printf("Everything is done.\n");

  return 0;
}
#+end_src

***** pthreads vs LinuxThreadImpl
When compiling on Linux, by default your threads are going to use the [[https://github.com/ziglang/zig/blob/28476a5ee94d311319941b54e9da66210690ce70/lib/std/Thread.zig#L1042][LinuxThreadImpl]]. TODO parler under the hood.
You might have notice that when you are linking libc, Zig is going to use pthreads instead of the native OS threads. This is because pthreads are more performant at the moment and since you are already linking libc it is better to use pthreads.

The way we measure are going to measure which implementation is better is by comparing the time it takes to *spawn* and *destory* N threads. It is useless to do work in the threads because no matter the implementation they are going to execute in the same way. It might even be counter-productive because you are going to start comparing the code inside the threads instead of the threads themselves.

TODO tangling psq main
#+begin_src zig :imports '(std) :main 'yes :testsuite 'no
const std = @import("std");

const NB_THREADS = 10000;

pub fn main() !void {
    var threads: [NB_THREADS]std.Thread = undefined;

    for (0..NB_THREADS) |i| {
        threads[i] = try std.Thread.spawn(.{}, goTo, .{});
    }

    for (0..NB_THREADS) |i| {
        threads[i].join();
    }
}

fn goTo() void {}
#+end_src

If we run this code with hyperfine (100 runs) once while linking libc (using pthreads) and once in vanilla mode (using LinuxThreadImpl), we can sometimes see that there is indeed a slight performance difference between the two:
- pthreads = ~274.4 ms += 4.7 ms
- LinuxThreadImpl = 280.s ms += 5.9 ms

The difference is so small that even when only spawning and destroying threads we barely see it. In a real world application where this would very unlikely be the bottleneck, which thread implementation you are going to use is very likely to not change anything the way your program perform.

**** Thread synchronization
Threads can be synchronized with utilities that are the same as most other languages (notably C). So when jumping in the [[https://ziglang.org/documentation/master/std/#std.Thread][std doc]] you should not be suprised and understand most of the features like Mutex and Semaphore.

TODO tangling

Here is the Zig code:
#+begin_src zig :imports '(std) :main 'yes :testsuite 'no
const std = @import("std");

var common: u64 = 0;
var m = std.Thread.Mutex{};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var pool: std.Thread.Pool = undefined;
    try pool.init(.{ .allocator = allocator });

    for (0..1000) |_| {
        try pool.spawn(goTo, .{});
    }

    pool.deinit();

    std.debug.print("{d}", .{common});
}

fn goTo() void {
    m.lock();
    common += 1;
    m.unlock();
}
#+end_src

And the equivalent C code:
#+begin_src c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NB_THREADS 10000

pthread_mutex_t mutex;
unsigned long long common = 0;

void* goTo(void* arg) {
    pthread_mutex_lock(&mutex);
    common += 1;
    pthread_mutex_unlock(&mutex);
    return NULL;
}

int main() {
    pthread_t threads[NB_THREADS];
    int i;

    if (pthread_mutex_init(&mutex, NULL) != 0) {
        printf("Mutex initialization failed\n");
        return 1;
    }

    for (i = 0; i < NB_THREADS; i++) {
        if (pthread_create(&threads[i], NULL, goTo, NULL) != 0) {
            printf("Thread creation failed\n");
            return 1;
        }
    }

    for (i = 0; i < NB_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    pthread_mutex_destroy(&mutex);

    printf("%llu\n", common);

    return 0;
}
#+end_src



**** Leaky abstraction
There are 2 things you can tweak when using *std.Thread*: the stack size and the allocator that is going to allocate the memory for the thread.
TODO: est ce que je peux fine tuned threads en Zig ? (priority, stack size, ...)

**** Conclusion
Zig threads are really useful since they have a very user-friendly abstraction with not a lot of functionalites that are almost never used anyway. This abstraction is also very useful for what we saw earlier, you don't have to worry about the target system, Zig is going to choose the right implementation for you.

But this leaky abstraction comes at a cost, you can not fine-tune your threads as much as you would like to.

If you need specific thread functionalities, like the ones we talked about, you can still do that in Zig by wrapping the C pthread library for exemple or directly use the OS native threads you want.

*** async/await
This method uses suspensible stackless coroutines, this solution does not necessarly mean that you are going to have multiple threads or parallelism.

We are not going to dive deeper into this solution because it has been deprecated since 0.11 and is not coming back soon.

However it is still a good reading and way to understand concurency to read this [[https://zig.guide/async/introduction/][very good guide]] that was made for this solution.
By reading this you might notice that **async/await** might **never** come out.

Note that if this solution is to be brought again it might come with breaking changes, so the syntax might change.

You can find a [[https://github.com/ziglang/zig/issues/6025][Github discussion]] about the progress of this feature and why it is not implemented in the current version.

You can see [[https://ziglang.org/download/0.12.0/release-notes.html#AsyncAwait-Feature-Status][here]] the main reasons why this solution is not implemented yet.

**** Function coloring
Green threads make function colors disapear ???? (dependences entre threads)

*** libxev
Using an event loop (by wrapping libuv or using libxev which is the equivalent buz in ZIG)
TODO exemple

*** Fibers
Using fibers (https://github.com/kprotty/zefi, https://github.com/kassane/fiber)
TODO exemple

*** zigcoro
This solution uses stackful asymmetric coroutines.
stackful asymmetric coroutines
This library is made to provide similar functionalities to async/await "old" model, so that if/when the official async/await solution is coming back, it will be easy to switch your project from using zigcoro to the official async/await.
async/await built on top of libxev (https://github.com/rsepassi/zigcoro)
TODO exemple

*** Using C libraries
... obviously you can still use C libraries that do async stuff :)
TODO exemple

** Conclusion
TODO: qu est ce que je pourrais bien dire de + que dans le contenu, parler du potentiel ?

TODO MES NOTES -------- pas besoin de lire ca, cest juste pour moi pour approfondir certains sujets plus tard

- "libuv and OSes will usually run background/worker threads and/or polling to perform tasks in a non-blocking manner." est ce que cest comment ca under the hood les non blocking async ?

- "The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on"

- tokio equivalent in zig ? 

** Sources:
- https://dl.acm.org/doi/pdf/10.1145/1462166.1462167
- https://www.lua.org/pil/9.1.html
- https://blog.orhun.dev/zig-bits-04/ (regarder regul pour voir si il m a rep)
- https://github.com/mitchellh/libxev/issues/92 (regul ...)
- ChatGPT et GH Copilot
- https://github.com/lewissbaker/cppcoro
- https://ericniebler.com/2020/11/08/structured-concurrency/
- https://en.wikipedia.org/wiki/Fiber_(computer_science)
- https://github.com/rsepassi/zigcoro
- https://github.com/mitchellh/libxev
- https://github.com/libuv/libuv
- https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst
- https://docs.libuv.org/en/v1.x/guide/basics.html (ptetre le meme que celui au dessus)
- https://github.com/dotnet/runtimelab/issues/2398
- https://kristoff.it/blog/zig-colorblind-async-await/
- https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/
- https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop
- https://docs.libuv.org/en/v1.x/guide/threads.html
- https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i
- https://github.com/ziglang/zig/issues/6025
- https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/
- https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network
- https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines
- https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time.
- https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines
