** Definitions
Coroutine (cooperative multitasking): 
- a coroutine itself is not concurrent !, it allows to manage concurrent tasks in the same way as callbacks for example
- single threaded
- allows to write code in a sequential manner
- allows not to have context switch
- 2 types of coroutine: symmetric vs asymmetric (relative to the control-transfer mechanism, explained a bit below)
- coroutines are not preemptive, they are cooperative, therefore they must explicitly give back control by **yielding**
- usually uses keywords like **yield**, **resume**, **suspend**, ...
- Coroutines can be either stackful or stackless, we are not gonna dive deep into this concept since most of the time you are going to use stackful coroutines since they allow you to suspend from within a nested stackframe (strength of stacless coroutines: efficiency)

Symmetric coroutines:
- Their only control-transfer mechanism is: 
1. explicitly passing control to another coroutine

Asymmetric coroutines (called asymmetric because the control-transfer can go both ways):
- They have two control-transfer mechanisms:
1. invoking another coroutine which is going to be the subcoroutine of the calling coroutine
2. suspending itself and giving control back to the caller

Green threads (userland threads):
- preemptive multitasking (PAS VRAI !)
- managed by a VM/runtime instead of the OS (TODO: A CONIRMER AVEC LE PROF JLUI POSERAI LA QUESTION)
- has the advantage to be managed in user space instead of kernel space which allows to avoid the overhead of making system calls to open and close threads
- still use several native threads behind the scenes
- used more for short-lived tasks

Fibers :
- Same as green threads but cooperative multitasking instead of preemptive multitasking
- TODO: confirmer avec le prof si ya pas autre chose

Preemptive multitasking:
- The underlying architecture (NOT us) is going to be deciding what to execute and when
- This means that our threads can be interrupted at any time

Cooperative multitasking:
- A thread will continue to run until it decides to give up control (yielding)
- We are in full control of the execution flow of our threads
- The drawback of this method is that YOU have to think and code in a way to not have starving threads for exemple

Thread (multithreading -> the threads are still blocking):
- Main and historical way of doing concurrency
- Parallelism (eventually): Threads allow for true parallel execution on multi-core CPUs, enabling better utilization of hardware resources and potentially improving performance.
- Isolation: Threads provide strong isolation between concurrent tasks, with each thread having its own execution context, stack, and local variables.
- Scalability: Managing a large number of threads can be challenging and may lead to scalability issues, as the operating system kernel has to allocate resources for each thread.
- Usually used with a thread pool to avoid the overhead of creating and destroying threads for each task which is very expensive
QUESTION: est ce que je parle pas des virtual threads la ?

Event-driven programming (ex: NodeJS):
- Event loop that regularly checks if "events" are launched
- Scalability: Event-driven architectures are inherently scalable, as they can handle a large number of concurrent connections with low memory and CPU overhead.
- Code behind NodeJS: https://github.com/libuv/libuv

** Zig current state
There a multiple ways you currently can do concurent code in ZIG:
- Spawning OS threads (https://ziglang.org/documentation/master/std/#std.Thread)
- Using old async/await from before 0.11 (not recommanded because unstable !!! https://github.com/ziglang/zig/issues/6025)
- Using an event loop (by wrapping libuv or using libxev which is the equivalent buz in ZIG)
- Using fibers (https://github.com/kprotty/zefi, https://github.com/kassane/fiber)
- async/await built on top of libxev (https://github.com/rsepassi/zigcoro)
- Low level single threaded concurrency if you want to craft your owng thing (https://github.com/kassane/context)
- ... obviously you can still use C libraries that do async stuff :)

** Function coloring
Green threads make function colors disapear ???? (dependences entre threads)

** MES NOTES -------- pas besoin de lire ca, cest juste pour moi

- "libuv and OSes will usually run background/worker threads and/or polling to perform tasks in a non-blocking manner." est ce que cest comment ca under the hood les non blocking async ?

- "The event loop follows the rather usual single threaded asynchronous I/O approach: all (network) I/O is performed on non-blocking sockets which are polled using the best mechanism available on the given platform: epoll on Linux, kqueue on OSX and other BSDs, event ports on SunOS and IOCP on"

** Sources:
- https://dl.acm.org/doi/pdf/10.1145/1462166.1462167
- https://www.lua.org/pil/9.1.html
- https://blog.orhun.dev/zig-bits-04/ (regarder regul pour voir si il m a rep)
- https://github.com/mitchellh/libxev/issues/92 (regul ...)
- ChatGPT et GH Copilot
- https://github.com/lewissbaker/cppcoro
- https://ericniebler.com/2020/11/08/structured-concurrency/
- https://en.wikipedia.org/wiki/Fiber_(computer_science)
- https://github.com/rsepassi/zigcoro
- https://github.com/mitchellh/libxev
- https://github.com/libuv/libuv
- https://github.com/libuv/libuv/blob/v1.x/docs/src/guide/basics.rst
- https://docs.libuv.org/en/v1.x/guide/basics.html (ptetre le meme que celui au dessus)
- https://github.com/dotnet/runtimelab/issues/2398
- https://kristoff.it/blog/zig-colorblind-async-await/
- https://tigerbeetle.com/blog/a-friendly-abstraction-over-iouring-and-kqueue/
- https://docs.libuv.org/en/v1.x/design.html#the-i-o-loop
- https://docs.libuv.org/en/v1.x/guide/threads.html
- https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i
- https://github.com/ziglang/zig/issues/6025
- https://www.reddit.com/r/Zig/comments/177e4cb/what_are_you_doing_for_async/
- https://github.com/catdevnull/awesome-zig?tab=readme-ov-file#network
- https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines
- https://www.baeldung.com/java-threading-models#:~:text=The%20big%20difference%20between%20green,executing%20at%20any%20given%20time.
- https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines
