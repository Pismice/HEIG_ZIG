#+bibliography: bibliography.bib
#+cite_export: csl ieee.csl

#+HTML_MATHJAX: align: left indent: 5em tagside: left

* Compilation - build system
** TODO Comptime

** TODO How to use the build system

** TODO Build modes

*** TODO Build steps
https://zig.guide/build-system/build-steps

*** TODO Generate automatically documentation
In Zig there is an experimental feature, it's automatically generated documentation.
It will scan all the public structures and functions and will create documentation.
Moreover, the comments like ~///~ are used to give more information to types.

This example is created with the help of the ~build.zig~ of the Zig language GitHub repository.
This is used the same way as the Zig teams auto-generate the standard library documentation. See: [[https://github.com/ziglang/zig/blob/master/build.zig][build.zig]]
#+begin_src zig
 pub fn build(b: *std.Build) void {
     const autodoc_test = b.addTest(.{
          .root_source_file = .{ .path = "src/main.zig" },
      });
      const install_std_docs = b.addInstallDirectory(.{
          .source_dir = autodoc_test.getEmittedDocs(),
          .install_dir = .prefix,
          .install_subdir = "doc",
      });

      const doc_step = b.step("docs", "Generate documentation");
      doc_step.dependOn(&install_std_docs.step);
      doc_step.makeFn = generateDocumentation;
  }

  fn generateDocumentation(self: *std.build.Step, progress: *std.Progress.Node) !void {
      _ = self;
      _ = progress;
      std.log.info("The documentation has been generated", .{});
  }
#+end_src

*** Strip output binary in Zig in Linux
[[http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf][ELF format]]
In an ~ELF~ executable there are various sections that hold program and control information.
For example:
- ~.bss~: it holds uninitialized variables and data.
- ~.text~: it holds the instruction of the program
- ~.debug~: it holds unspecified information for debugging

Removing the debug symbols will reduce his size, make it harder to reverse engineering, and improve speed performance.

By default, Zig will produce an executable that has all the debug symbols.
However, Zig has reproduced a drop-in replacement for the program GNU ~objcopy~.

To strip an output in the zig command line :
#+begin_src sh
  zig build-exe -fstrip src/main.zig
#+end_src

To be sure that the output executable is stripped, the command ~file~ can be useful :
#+begin_src sh
 file main
#+end_src
And the output : 
#+begin_src 
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
#+end_src

With the Zig build system (~build.zig~) there is an option to strip an executable :
#+begin_src zig
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    var exe = b.addExecutable(.{
        .name = "linkedlist",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    exe.strip = true;
#+end_src

If the option strip is set to false, we have :
#+begin_src 
 $file linkedlist
 linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
#+end_src

And with the option to ~true~ :
#+begin_src 
 $file linkedlist
 linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
#+end_src

*** Separate debug symbols from ELF executable
The chapter above shows how to remove all the symbols for the executable directly in the Zig build system.
In this section, the interest is more about the Zig objcopy command.
In fact, Zig has implemented his own ~objcopy~ utils to strip, and remove symbols like the objcopy from the bin utils (GNU utils).
(/Note: for now, the Zig objcopy has fewer features/)

The interest in having objcopy directly in Zig is there is no need to have multiple objcopy executables.
Indeed, in a cross-compilation world, each binutil needs to be compatible with the CPU architecture target.
So, it avoids using different toolchains and scripts to build on various targets.

Here's how to invoke the help of the Zig build objcopy:
#+begin_src sh
   zig objcopy --help
#+end_src

The following example illustrates several applications of the objcopy command.
First, remove the debug symbols of the executable.
After that, keep only the debug symbols in a separate file.
And finally, how to link the debug symbols file to an executable (that has no debug file).

For this example, the output executable of the Zig build toolchain is named ~main~.
#+begin_src sh
  $file main
  main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
#+end_src

The first step is to strip the debug file from the executable:
#+begin_src sh
  zig objcopy --strip-debug main mainStripped
#+end_src

The small flag alternative can also be used:
#+begin_src sh
  zig objcopy -g main mainNoDebugInfo
#+end_src

After this command, the new executable has no longer the debug info.
#+begin_src sh
  $file mainNoDebugInfo
  mainNoDebugInfo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
#+end_src

The second step shows how to keep only the debug symbols in the ~main.dbg~ file:
#+begin_src sh
  zig objcopy --only-keep-debug main main.dbg
#+end_src

Finally, to recreate an executable with a link to a debug symbols file, the following command can be used:
#+begin_src sh
  zig objcopy --add-gnu-debuglink=main.dbg mainNoDebugInfo mainWithDbgSymbols
#+end_src

Now, the executable named ~mainWithDbgSymbols~ can be used, for example in GDB to debug it (GDB will know where its debug symbols file is located).

Removing the debug symbol will create a smaller executable.
Bellow shows the process with a mini-example:

| executable name    | size |
|--------------------+------|
| main               | 1.9M |
| main.dbg           | 1.2M |
| mainNoDebugInfo    | 690K |
| mainWithDbgSymbols | 690K |

The advantage of this method is that the executable can be sent to production without debug symbols (it's more difficult to reverse engineering the exe, and it has a smaller size).
But when a bug is reported, it is always possible to debug it because all you have to do is link the debug symbol to the executable.
*** TODO Separate object file from ELF executable

** Cross-compilation

*** TODO Cross-compile with an embedded linux
TODO: Add iterate programming to cross compile automaticlly the app

The ~-target~ flag of ~zig build-exe~ can select the target architecture for the cross-compilation.
There are multiple target selections, see [cite:@CrossCompilationZig2024] to have the entire list of targets.

Here's an example of a test that was performed, the aim being to run an executable produced by Zig (from a ~x86_64~) for a -nanopi neo plus 2- which has an arm64 architecture and runs a Linux kernel.
The information of the embedded target :
#+begin_src sh
uname -a
Linux csel 5.15.148 #2 SMP PREEMPT Mon Mar 4 21:21:00 UTC 2024 aarch64 GNU/Linux
#+end_src

Here's the command to cross-compile the executable (the executable is also stripped to have a smaller size):
#+begin_src sh
  zig build-exe src/main.zig -target aarch64-linux -fstrip
#+end_src

The executable on the embedded target runs flawlessly, below is shown the output of the target:
#+begin_example
# ./main
All your codebase are belong to us.
Run `zig build test` to run the tests.
#+end_example


* Performance comparaison + SMID

Leibniz algorithm :
https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80

\begin{equation}
\frac{\pi}{4} = 1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7} + \frac{1}{9} - \ldots = \sum_{k = 0}^{\infty} \frac{(-1)^k}{2k + 1}
\end{equation}

https://github.com/niklas-heer/speed-comparison/tree/master

| Command              | Mean [ms]  | Min [ms] | Max [ms] | Relative    |
|----------------------+------------+----------+----------+-------------|
| =./leibniz_zig=      | 85.9 ± 0.4 |     85.0 |     87.0 | 2.02 ± 0.03 |
| =./leibniz_zig_smid= | 42.5 ± 0.5 |     41.6 |     43.7 | 1.00        |
| =./leibniz_c=        | 43.3 ± 0.8 |     42.2 |     45.4 | 1.02 ± 0.02 |
| =./leibniz_rs=       | 86.4 ± 1.5 |     85.2 |     94.3 | 2.03 ± 0.04 |
| =./leibniz_avx2=     | 43.3 ± 0.5 |     42.1 |     44.3 | 1.02 ± 0.02 |

| Command              | Mean [ms]   | Min [ms] | Max [ms] | Relative    |
|----------------------+-------------+----------+----------+-------------|
| =./leibniz_zig=      | 883.9 ± 9.5 |    864.1 |    896.0 | 1.99 ± 0.03 |
| =./leibniz_zig_smid= | 443.8 ± 5.2 |    437.2 |    452.0 | 1.00        |
| =./leibniz_c=        | 481.5 ± 4.4 |    476.8 |    489.2 | 1.08 ± 0.02 |
| =./leibniz_rs=       | 912.7 ± 9.7 |    897.1 |    925.1 | 2.06 ± 0.03 |
| =./leibniz_avx2=     | 451.2 ± 6.3 |    443.8 |    465.7 | 1.02 ± 0.02 |


| Command              | Mean [s]      | Min [s] | Max [s] | Relative     |
|----------------------+---------------+---------+---------+--------------|
| =./leibniz_zig=      | 8.889 ± 0.095 |   8.722 |   9.058 | 13.91 ± 0.33 |
| =./leibniz_zig_smid= | 4.386 ± 0.028 |   4.357 |   4.420 | 6.86 ± 0.15  |
| =./leibniz_c=        | 0.665 ± 0.003 |   0.658 |   0.669 | 1.04 ± 0.02  |
| =./leibniz_rs=       | 8.903 ± 0.053 |   8.855 |   8.973 | 13.93 ± 0.31 |
| =./leibniz_avx2=     | 0.639 ± 0.013 |   0.618 |   0.657 | 1.00         |

