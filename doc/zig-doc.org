#+title: Zig documentation

* Intro
** TODO UTF-8 encoding
Write about string UTF-8 encoding in Zig.

** TODO Undefined
Write about ~undefined~ and how it behaves between debug and release mode.

* Allocator
The Zig language doesn't hide the memory management, the mantra of Zig is to have no hidden control flow.
Like the C language, Zig has manual memory management however, Zig will offer the programmer different allocators that allow him to handle exactly how to use his memory.
That's why Zig doesn't have a runtime and it can be used without the ~libc~ runtime.

Different allocators will be presented in the next sections.

This part is documented thanks to various resources:
- [[https://ziglang.org/documentation/0.11.0/#Memory][Zig documentation - Memory]]
- [[https://zig.guide/standard-library/allocators/][Zig guide about allocator]]
- [[https://www.openmymind.net/learning_zig/heap_memory/][openmymind - learning zig - heap memory]]
- The Zig's standard library code

** Page allocator (~page_allocator~)
The page allocator is the basic allocator that will directly ask the OS for memory. 
This is not the most efficient allocator because it will request memory pages from the OS via systems calls.

#+begin_src zig :imports '(std)
  const allocator = std.heap.page_allocator;
  const stdout = std.io.getStdOut().writer();

  const MyStruct = struct {
      myFloat: f32,
      myInt: i32,
  };

  const memory = try allocator.alloc(u8, 42);
  defer allocator.free(memory);

  try stdout.print("Len of the memory: {}\n", .{memory.len});

  var myStruct = try allocator.create(MyStruct); 
  defer allocator.destroy(myStruct);

  myStruct.*.myFloat = 3.1415;
  myStruct.*.myInt = 42;

  try stdout.print("myStruct: {}\n", .{myStruct});

#+end_src

#+RESULTS:
| Len of the memory: 42                                             |               |
| myStruct: Zig-src-RbksET.main.MyStruct{ .myFloat = 3.14149999e+00 | .myInt = 42 } |

** Fixed buffer allocator
The ~FixedBufferAllocator~ will allocate memory into a fixed buffer, the size of the buffer needs to be known at comptime.
The benefit of this allocator is that it will not make heap allocation. It's very useful for embedded systems and kernel development.
This allocator is very performant and it will give an error if the allocator runs out of memory, with an ~OutOfMemory~ error.

#+begin_src zig :imports '(std)
  const stdout = std.io.getStdOut().writer();

  var buffer: [100]u8 = undefined;
  var fixedBuffAlloc = std.heap.FixedBufferAllocator.init(&buffer);
  const allocator = fixedBuffAlloc.allocator();

  const memory = try allocator.alloc(u8, 50);
  defer allocator.free(memory);

  try stdout.print("Len of the memory: {}\n", .{memory.len});

  // Example of OutOfMemory error
  _ = allocator.alloc(u8, 51) catch |err| {
    try stdout.print("There is an error: {}\n", .{err});
  };

#+end_src

#+RESULTS:
| Len   | of | the | memory: |                50 |
| There | is | an  | error:  | error.OutOfMemory |

Moreover, there is also a thread-safe fixed buffer allocator for thread-safety use case: ~std.heap.ThreadSafeFixedBufferAllocator~.

** Arena allocator
The arena allocator takes a child allocator as input. This pattern is used to allocate multiple pieces of memory and free them at once.
There is no need in the arena allocator to free memory manually, it's the function ~deinit~ that is responsible for freeing all to allocated memory.

The Zig documentation recommends this pattern when an application runs from start to end without a cyclic pattern.
For example: command line application.

Here's an example of how to use the arena allocator.
#+begin_src zig :imports '(std)
  const stdout = std.io.getStdOut().writer();

  const MyStruct = struct {
      myFloat: f32,
      myInt: i32,
  };

  const page_allocator = std.heap.page_allocator;
  var arena = std.heap.ArenaAllocator.init(page_allocator);
  defer arena.deinit();
  const allocator = arena.allocator();

  var myStruct = try allocator.create(MyStruct);

  myStruct.*.myFloat = 3.1415;
  myStruct.*.myInt = 42;

  try stdout.print("myStruct: {}\n", .{myStruct});
  // No need to manual free myStuct

#+end_src

#+RESULTS:
| myStruct: Zig-src-a2oNQA.main.MyStruct{ .myFloat = 3.14149999e+00 | .myInt = 42 } |

*** Internal working of arena allocator
[[https://www.huy.rocks/everyday/01-12-2022-zig-how-arenaallocator-works][Zig how arena allocator works]]
Internally, the arena allocator uses a linked list to keep track of the created buffers.

The example below shows a code snippet of the arena allocation (from the standard library).
The internals of the arena allocator are the child allocator and a state that contains a singly linked list of buffers.
#+begin_src zig
  pub const ArenaAllocator = struct {
    child_allocator: Allocator,
    state: State,

    /// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator
    /// as a memory-saving optimization.
    pub const State = struct {
        buffer_list: std.SinglyLinkedList(usize) = .{},
        end_index: usize = 0,

        pub fn promote(self: State, child_allocator: Allocator) ArenaAllocator {
            return .{
                .child_allocator = child_allocator,
                .state = self,
            };
        }
    };
    /// ...
  };
#+end_src

The ~deinit~ function of the arena allocator will free all the buffers by iterating over each node and calling the ~rawFree~ from the child allocator.
(this code snippet comes from the standard library)
#+begin_src zig
      pub fn deinit(self: ArenaAllocator) void {
        // NOTE: When changing this, make sure `reset()` is adjusted accordingly!

        var it = self.state.buffer_list.first;
        while (it) |node| {
            // this has to occur before the free because the free frees node
            const next_it = node.next;
            const align_bits = std.math.log2_int(usize, @alignOf(BufNode));
            const alloc_buf = @as([*]u8, @ptrCast(node))[0..node.data];
            self.child_allocator.rawFree(alloc_buf, align_bits, @returnAddress());
            it = next_it;
        }
    }
#+end_src

** General purpose allocator
A general purpose allocator is available in Zig, this is a safe allocator that can prevent double free memory, "use after free" and detect memory leaks.
The general purpose allocator is safety first design, but it's still faster than the page allocator ([[https://zig.guide/standard-library/allocators/][Zig guide allocator]])

The general purpose allocator is a function that takes as argument a comptime configuration struct and return a type.
(this code snippet comes from the standard library)
#+begin_src zig
  pub fn GeneralPurposeAllocator(comptime config: Config) type {
      return struct {
          /// Implementation ....
      };
  }
#+end_src

The configuration struct of the general purpose allocator shown below, has different options, like thread safety, memory limit, and debug utils.
(this code snippet comes from the standard library)
#+begin_src zig
pub const Config = struct {
    /// Number of stack frames to capture.
    stack_trace_frames: usize = default_stack_trace_frames,

    /// If true, the allocator will have two fields:
    ///  * `total_requested_bytes` which tracks the total allocated bytes of memory requested.
    ///  * `requested_memory_limit` which causes allocations to return `error.OutOfMemory`
    ///    when the `total_requested_bytes` exceeds this limit.
    /// If false, these fields will be `void`.
    enable_memory_limit: bool = false,

    /// Whether to enable safety checks.
    safety: bool = std.debug.runtime_safety,

    /// Whether the allocator may be used simultaneously from multiple threads.
    thread_safe: bool = !builtin.single_threaded,

    /// What type of mutex you'd like to use, for thread safety.
    /// when specified, the mutex type must have the same shape as `std.Thread.Mutex` and
    /// `DummyMutex`, and have no required fields. Specifying this field causes
    /// the `thread_safe` field to be ignored.
    ///
    /// when null (default):
    /// * the mutex type defaults to `std.Thread.Mutex` when thread_safe is enabled.
    /// * the mutex type defaults to `DummyMutex` otherwise.
    MutexType: ?type = null,

    /// This is a temporary debugging trick you can use to turn segfaults into more helpful
    /// logged error messages with stack trace details. The downside is that every allocation
    /// will be leaked, unless used with retain_metadata!
    never_unmap: bool = false,

    /// This is a temporary debugging aid that retains metadata about allocations indefinitely.
    /// This allows a greater range of double frees to be reported. All metadata is freed when
    /// deinit is called. When used with never_unmap, deliberately leaked memory is also freed
    /// during deinit. Currently should be used with never_unmap to avoid segfaults.
    /// TODO https://github.com/ziglang/zig/issues/4298 will allow use without never_unmap
    retain_metadata: bool = false,

    /// Enables emitting info messages with the size and address of every allocation.
    verbose_log: bool = false,
};
#+end_src

The example below shows a basic usage of the Zig's GPA:
#+begin_src zig :imports '(std)
  const stdout = std.io.getStdOut().writer();

  const MyStruct = struct {
      myFloat: f32,
      myInt: i32,
  };

  var gpa = std.heap.GeneralPurposeAllocator(.{}){};
  const allocator = gpa.allocator();

  // Returns `Check.leak` if there were leaks; `Check.ok` otherwise.
  defer {
      const checkStatus = gpa.deinit();
      if (checkStatus == std.heap.Check.leak) {
          std.log.err("Leaks detected !!!", .{});
      }
  }

  var myStruct = try allocator.create(MyStruct);
  defer allocator.destroy(myStruct);

  myStruct.*.myFloat = 3.1415;
  myStruct.*.myInt = 42;

  try stdout.print("myStruct: {}\n", .{myStruct});

#+end_src

#+RESULTS:
| myStruct: Zig-src-MFk0Tx.main.MyStruct{ .myFloat = 3.14149999e+00 | .myInt = 42 } |


** TODO Testing allocator

** TODO Failing allocator

** TODO C allocator

** TODO How to use Zig to detect memory leaks
*** TODO Comparison between gcc-utils sanitizer, Valgrind, and Zig memory leak detection

* Log
*** TODO log comptime
Write about how Zig's log module uses ~comptime~ and whether the log system will be or not in the executable thanks to the log configuration.

* Errors
** TODO Errors and compilation mode
Check whether compilation modes will affect the error behaviors.

* Compilation - build system
** TODO Comptime

** TODO How to use the build system

** TODO Build modes

*** TODO Build steps
https://zig.guide/build-system/build-steps

*** TODO Generate automatically documentation
In Zig there is an experimental feature, it's automatically generated documentation.
It will scan all the public structures and functions and will create documentation.
Moreover, the comments like ~///~ are used to give more information to types.

This example is created with the help of the ~build.zig~ of the Zig language GitHub repository.
This is used the same way as the Zig teams auto-generate the standard library documentation. See: [[https://github.com/ziglang/zig/blob/master/build.zig][build.zig]]
#+begin_src zig
 pub fn build(b: *std.Build) void {
     const autodoc_test = b.addTest(.{
          .root_source_file = .{ .path = "src/main.zig" },
      });
      const install_std_docs = b.addInstallDirectory(.{
          .source_dir = autodoc_test.getEmittedDocs(),
          .install_dir = .prefix,
          .install_subdir = "doc",
      });

      const doc_step = b.step("docs", "Generate documentation");
      doc_step.dependOn(&install_std_docs.step);
      doc_step.makeFn = generateDocumentation;
  }

  fn generateDocumentation(self: *std.build.Step, progress: *std.Progress.Node) !void {
      _ = self;
      _ = progress;
      std.log.info("The documentation has been generated", .{});
  }
#+end_src

*** Strip output binary in Zig in Linux
[[http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf][ELF format]]
In an ~ELF~ executable there are various sections that hold program and control information.
For example:
- ~.bss~: it holds uninitialized variables and data.
- ~.text~: it holds the instruction of the program
- ~.debug~: it holds unspecified information for debugging

Removing the debug symbols will reduce his size, make it harder to reverse engineering, and improve speed performance.

By default, Zig will produce an executable that has all the debug symbols.
However, Zig has reproduced a drop-in replacement for the program GNU ~objcopy~.

To strip an output in the zig command line :
#+begin_src sh
  zig build-exe -fstrip src/main.zig
#+end_src

To be sure that the output executable is stripped, the command ~file~ can be useful :
#+begin_src sh
 file main
#+end_src
And the output : 
#+begin_src 
main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
#+end_src

With the Zig build system (~build.zig~) there is an option to strip an executable :
#+begin_src zig
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    var exe = b.addExecutable(.{
        .name = "linkedlist",
        .root_source_file = .{ .path = "src/main.zig" },
        .target = target,
        .optimize = optimize,
    });

    exe.strip = true;
#+end_src

If the option strip is set to false, we have :
#+begin_src 
 $file linkedlist
 linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, with debug_info, not stripped
#+end_src

And with the option to ~true~ :
#+begin_src 
 $file linkedlist
 linkedlist: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped
#+end_src

*** TODO Separate object file from ELF executable

* Standard library
** TCP stream
*** TODO How Zig manages stream
Does Zig manage tcp stream with the OS stream or has it created its own implementation ?

** Threading
*** Compare Zig threading library with ~p_thread~


