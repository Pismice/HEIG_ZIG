#+title: Zigcoro
#+weight: 2
#+hugo_cascade_type: docs

*** zigcoro
[[https://github.com/rsepassi/zigcoro][This solution]] uses stackful asymmetric coroutines.
This library is made to provide similar functionalities to async/await "old" model, so that if/when the official async/await solution is coming back, it will be easy to switch your project from using zigcoro to the official async/await. Under the hood this library uses the [[https://github.com/mitchellh/libxev][libxev]] library that we talked about earlier in order to have an event loop.

But that is not the only features that zigcoro provide, it also provides chanels.
Chanels are notably well known in Go, they are used to communicate between coroutines, they are a way pass data between them, it therefore is a good way to synchronize them.

We are going to do the same thing in Zig in order to communicate between threads without basics thread synchronization primivites like mutexes or semaphores.

First we are going to run all of them in a single-threaded environment, so that we can familiarize with the syntax.
#+begin_src zig
  const std = @import("std");
  const libcoro = @import("libcoro");
  
  const BurgerOrder = struct {
      burger: u8,
      fries: u8,
  };
  
  pub fn main() !void {
      const allocator = std.heap.page_allocator;
      var exec = libcoro.Executor.init();
      libcoro.initEnv(.{ .stack_allocator = allocator, .executor = &exec });
  
      // Creation of a Type that represents a channel that can passe floats
      const BurgeOrderChanel = libcoro.Channel(BurgerOrder, .{});
  
      // Creation of a channel that can pass Burger Orders
      var road_between_restaurant_and_house = BurgeOrderChanel.init(null);
  
      const delivery_man = try libcoro.xasync(sender, .{ &road_between_restaurant_and_house, BurgerOrder{ .burger = 2, .fries = 3 } }, null);
      defer delivery_man.deinit();
  
      const hungry_client = try libcoro.xasync(recvr, .{&road_between_restaurant_and_house}, null);
      defer hungry_client.deinit();
  
      while (exec.tick()) {
          // While there are deliveries to do, they will be made
          // After that point, the delivery man does not take any more orders
      }
  
      libcoro.xawait(delivery_man); // Delivery man finished his job
      const order = libcoro.xawait(hungry_client); // Hungry client received his order
      std.debug.print("Burger = {} | Fries = {}", .{ order.burger, order.fries });
  }
  
  fn sender(chan: anytype, order: BurgerOrder) void {
      defer chan.close();
      chan.send(order) catch unreachable;
  }
  
  fn recvr(chan: anytype) BurgerOrder {
      return chan.recv() orelse BurgerOrder{ .burger = 0, .fries = 0 }; // The delivery might fail to arrive
  }
#+end_src

Note that chanels are made for inter coroutine communication only. I tried to use them for inter thread communication but it can not work as states in this [[https://github.com/rsepassi/zigcoro/issues/22][issue]].

Zigcoro is only maintained by 2 people, even though they still update frequently for the new zig versions, the library has not evolved for a while and there are some PR that are just hanging there for a while.

The library can still be useful to leverage async/await powers before Zig makes it official with its own event loop as well and not [[https://github.com/mitchellh/libxev][libxev]].
