#+title: Zigcoro
#+weight: 2
#+hugo_cascade_type: docs

*** zigcoro
[[https://github.com/rsepassi/zigcoro][This solution]] uses stackful asymmetric coroutines.
This library is made to provide similar functionalities to async/await "old" model, so that if/when the official async/await solution is coming back, it will be easy to switch your project from using zigcoro to the official async/await. Under the hood this library uses the [[https://github.com/mitchellh/libxev][libxev]] library that we talked about earlier in order to have an event loop.

But that is not the only features that zigcoro provides, it also provides chanels.
Chanels are notably well known in Go, they are used to communicate between coroutines, they are a way pass data to between coroutines.

**** Example
Here I made a simple example where I simply use chanels to communicate between asynchronous funtions.
I used an analogy to help understand better the code. A client wants its burder order to come to his house, for that the we create the road between the restaurant and the house =road_between_restaurant_and_house=, the delivery man then knows he has to do his job and that he will transmit the order through that road. The client then waits and listens for his order to arrive. Once the delivery man finished the job the order can be consumed by the =hungry_client=.

#+begin_src zig
  const std = @import("std");
  const libcoro = @import("libcoro");
  
  const BurgerOrder = struct {
      burger: u8,
      fries: u8,
  };
  
  pub fn main() !void {
      const allocator = std.heap.page_allocator;
      var exec = libcoro.Executor.init();
      libcoro.initEnv(.{ .stack_allocator = allocator, .executor = &exec });
  
      // Creation of a Type that represents a channel that can passe Burger Orders
      const BurgeOrderChanel = libcoro.Channel(BurgerOrder, .{});
  
      // Creation of a channel that can pass Burger Orders
      var road_between_restaurant_and_house = BurgeOrderChanel.init(null);
  
      const delivery_man = try libcoro.xasync(sender, .{ &road_between_restaurant_and_house, BurgerOrder{ .burger = 2, .fries = 3 } }, null);
      defer delivery_man.deinit();
  
      const hungry_client = try libcoro.xasync(recvr, .{&road_between_restaurant_and_house}, null);
      defer hungry_client.deinit();
  
      libcoro.xawait(delivery_man); // Delivery man finished his job
      const order = libcoro.xawait(hungry_client); // Hungry client received his order
      std.debug.print("Burger = {} | Fries = {}", .{ order.burger, order.fries });
  }
  
  fn sender(chan: anytype, order: BurgerOrder) void {
      defer chan.close();
      chan.send(order) catch unreachable;
  }
  
  fn recvr(chan: anytype) BurgerOrder {
      return chan.recv() orelse BurgerOrder{ .burger = 0, .fries = 0 }; // The delivery might fail to arrive
  }
#+end_src

Note that chanels are made for inter coroutine communication only. I tried to use them for inter thread communication but it can not work as stated in this [[https://github.com/rsepassi/zigcoro/issues/22][issue]].

Zigcoro is only maintained by 2 people, even though they still update frequently for the new zig versions, the library has not evolved for a while and there are some PR that are just hanging there for a while.

The library can still be useful to leverage async/await powers before Zig makes it official with its own event loop as well and not [[https://github.com/mitchellh/libxev][libxev]].
